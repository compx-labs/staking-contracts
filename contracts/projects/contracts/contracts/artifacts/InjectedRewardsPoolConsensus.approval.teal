#pragma version 10

// This TEAL was generated by TEALScript v0.103.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *call_DeleteApplication *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication(address,address)void
*abi_route_createApplication:
	// oracleAdminAddress: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 0 (oracleAdminAddress) for createApplication must be a address
	assert

	// adminAddress: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (adminAddress) for createApplication must be a address
	assert

	// execute createApplication(address,address)void
	callsub createApplication
	int 1
	return

// createApplication(adminAddress: Address, oracleAdminAddress: Address): void
createApplication:
	proto 2 0

	// contracts/InjectedRewardsPoolConsensus.algo.ts:71
	// this.adminAddress.value = adminAddress
	byte 0x61646d696e41646472657373 // "adminAddress"
	frame_dig -1 // adminAddress: Address
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:72
	// this.oracleAdminAddress.value = oracleAdminAddress
	byte 0x6f7261636c6541646d696e41646472657373 // "oracleAdminAddress"
	frame_dig -2 // oracleAdminAddress: Address
	app_global_put
	retsub

// initApplication(uint64,uint64,uint64,uint64,uint64)void
*abi_route_initApplication:
	// commision: uint64
	txna ApplicationArgs 5
	btoi

	// lstTokenId: uint64
	txna ApplicationArgs 4
	btoi

	// minStakePeriodForRewards: uint64
	txna ApplicationArgs 3
	btoi

	// rewardAssetId: uint64
	txna ApplicationArgs 2
	btoi

	// stakedAsset: uint64
	txna ApplicationArgs 1
	btoi

	// execute initApplication(uint64,uint64,uint64,uint64,uint64)void
	callsub initApplication
	int 1
	return

// initApplication(stakedAsset: uint64, rewardAssetId: uint64, minStakePeriodForRewards: uint64, lstTokenId: uint64, commision: uint64): void
initApplication:
	proto 5 0

	// contracts/InjectedRewardsPoolConsensus.algo.ts:82
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can init application')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can init application
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:84
	// this.stakedAssetId.value = stakedAsset
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	frame_dig -1 // stakedAsset: uint64
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:85
	// this.rewardAssetId.value = rewardAssetId
	byte 0x72657761726441737365744964 // "rewardAssetId"
	frame_dig -2 // rewardAssetId: uint64
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:86
	// this.totalStaked.value = 0
	byte 0x746f74616c5374616b6564 // "totalStaked"
	int 0
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:87
	// this.minStakePeriodForRewards.value = minStakePeriodForRewards
	byte 0x6d696e5374616b65506572696f64466f7252657761726473 // "minStakePeriodForRewards"
	frame_dig -3 // minStakePeriodForRewards: uint64
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:88
	// this.lastRewardInjectionTime.value = 0
	byte 0x6c617374526577617264496e6a656374696f6e54696d65 // "lastRewardInjectionTime"
	int 0
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:89
	// this.freeze.value = false
	byte 0x667265657a65 // "freeze"
	int 0
	byte 0x00
	int 0
	uncover 2
	setbit
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:90
	// this.injectedASARewards.value = 0
	byte 0x696e6a656374656441534152657761726473 // "injectedASARewards"
	int 0
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:91
	// this.numStakers.value = 0
	byte 0x6e756d5374616b657273 // "numStakers"
	int 0
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:92
	// this.algoInjectedRewards.value = 0
	byte 0x616c676f496e6a656374656452657761726473 // "algoInjectedRewards"
	int 0
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:93
	// this.totalConsensusRewards.value = 0
	byte 0x746f74616c436f6e73656e73757352657761726473 // "totalConsensusRewards"
	int 0
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:94
	// this.lstTokenId.value = lstTokenId
	byte 0x6c7374546f6b656e4964 // "lstTokenId"
	frame_dig -4 // lstTokenId: uint64
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:95
	// this.commision.value = commision
	byte 0x636f6d6d6973696f6e // "commision"
	frame_dig -5 // commision: uint64
	app_global_put

	// *if0_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:97
	// this.stakedAssetId.value !== 0
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	app_global_get
	int 0
	!=
	bz *if0_end

	// *if0_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:98
	// sendAssetTransfer({
	//         xferAsset: AssetID.fromUint64(stakedAsset),
	//         assetReceiver: this.app.address,
	//         assetAmount: 0,
	//       })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/InjectedRewardsPoolConsensus.algo.ts:99
	// xferAsset: AssetID.fromUint64(stakedAsset)
	frame_dig -1 // stakedAsset: uint64
	itxn_field XferAsset

	// contracts/InjectedRewardsPoolConsensus.algo.ts:100
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/InjectedRewardsPoolConsensus.algo.ts:101
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if0_end:
	retsub

// updateMinStakePeriod(uint64)void
*abi_route_updateMinStakePeriod:
	// minStakePeriodForRewards: uint64
	txna ApplicationArgs 1
	btoi

	// execute updateMinStakePeriod(uint64)void
	callsub updateMinStakePeriod
	int 1
	return

// updateMinStakePeriod(minStakePeriodForRewards: uint64): void
updateMinStakePeriod:
	proto 1 0

	// contracts/InjectedRewardsPoolConsensus.algo.ts:107
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can update min stake period')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can update min stake period
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:108
	// this.minStakePeriodForRewards.value = minStakePeriodForRewards
	byte 0x6d696e5374616b65506572696f64466f7252657761726473 // "minStakePeriodForRewards"
	frame_dig -1 // minStakePeriodForRewards: uint64
	app_global_put
	retsub

// updateAdminAddress(address)void
*abi_route_updateAdminAddress:
	// adminAddress: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (adminAddress) for updateAdminAddress must be a address
	assert

	// execute updateAdminAddress(address)void
	callsub updateAdminAddress
	int 1
	return

// updateAdminAddress(adminAddress: Address): void
updateAdminAddress:
	proto 1 0

	// contracts/InjectedRewardsPoolConsensus.algo.ts:111
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can update admin address')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can update admin address
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:112
	// this.adminAddress.value = adminAddress
	byte 0x61646d696e41646472657373 // "adminAddress"
	frame_dig -1 // adminAddress: Address
	app_global_put
	retsub

// updateOracleAdminAddress(address)void
*abi_route_updateOracleAdminAddress:
	// oracleAdminAddress: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (oracleAdminAddress) for updateOracleAdminAddress must be a address
	assert

	// execute updateOracleAdminAddress(address)void
	callsub updateOracleAdminAddress
	int 1
	return

// updateOracleAdminAddress(oracleAdminAddress: Address): void
updateOracleAdminAddress:
	proto 1 0

	// contracts/InjectedRewardsPoolConsensus.algo.ts:115
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can update oracle admin address')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can update oracle admin address
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:116
	// this.oracleAdminAddress.value = oracleAdminAddress
	byte 0x6f7261636c6541646d696e41646472657373 // "oracleAdminAddress"
	frame_dig -1 // oracleAdminAddress: Address
	app_global_put
	retsub

// updateCommision(uint64)void
*abi_route_updateCommision:
	// commision: uint64
	txna ApplicationArgs 1
	btoi

	// execute updateCommision(uint64)void
	callsub updateCommision
	int 1
	return

// updateCommision(commision: uint64): void
updateCommision:
	proto 1 0

	// contracts/InjectedRewardsPoolConsensus.algo.ts:119
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can update commision')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can update commision
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:120
	// this.commision.value = commision
	byte 0x636f6d6d6973696f6e // "commision"
	frame_dig -1 // commision: uint64
	app_global_put
	retsub

// setPrices(uint64,uint64)void
*abi_route_setPrices:
	// lstPrice: uint64
	txna ApplicationArgs 2
	btoi

	// stakeTokenPrice: uint64
	txna ApplicationArgs 1
	btoi

	// execute setPrices(uint64,uint64)void
	callsub setPrices
	int 1
	return

// setPrices(stakeTokenPrice: uint64, lstPrice: uint64): void
setPrices:
	proto 2 0

	// contracts/InjectedRewardsPoolConsensus.algo.ts:123
	// assert(this.txn.sender === this.oracleAdminAddress.value, 'Only oracle admin can set prices')
	txn Sender
	byte 0x6f7261636c6541646d696e41646472657373 // "oracleAdminAddress"
	app_global_get
	==

	// Only oracle admin can set prices
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:124
	// assert(stakeTokenPrice > 0, 'Invalid stake token price')
	frame_dig -1 // stakeTokenPrice: uint64
	int 0
	>

	// Invalid stake token price
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:125
	// assert(lstPrice > 0, 'Invalid reward token price')
	frame_dig -2 // lstPrice: uint64
	int 0
	>

	// Invalid reward token price
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:127
	// this.stakeTokenPrice.value = stakeTokenPrice
	byte 0x7374616b65546f6b656e5072696365 // "stakeTokenPrice"
	frame_dig -1 // stakeTokenPrice: uint64
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:128
	// this.lstPrice.value = lstPrice
	byte 0x6c73745072696365 // "lstPrice"
	frame_dig -2 // lstPrice: uint64
	app_global_put
	retsub

// costForBoxStorage(totalNumBytes: uint64): uint64
costForBoxStorage:
	proto 1 1

	// contracts/InjectedRewardsPoolConsensus.algo.ts:135
	// return SCBOX_PERBOX + totalNumBytes * SCBOX_PERBYTE
	int 2500
	frame_dig -1 // totalNumBytes: uint64
	int 400
	*
	+
	retsub

// getMBRForPoolCreation()(uint64)
*abi_route_getMBRForPoolCreation:
	// The ABI return prefix
	byte 0x151f7c75

	// execute getMBRForPoolCreation()(uint64)
	callsub getMBRForPoolCreation
	concat
	log
	int 1
	return

// getMBRForPoolCreation(): mbrReturn
getMBRForPoolCreation:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/InjectedRewardsPoolConsensus.algo.ts:139
	// nonAlgoRewardMBR = 0
	int 0
	frame_bury 0 // nonAlgoRewardMBR: uint64

	// *if1_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:140
	// this.rewardAssetId.value !== 0
	byte 0x72657761726441737365744964 // "rewardAssetId"
	app_global_get
	int 0
	!=
	bz *if1_end

	// *if1_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:141
	// nonAlgoRewardMBR += ASSET_HOLDING_FEE
	frame_dig 0 // nonAlgoRewardMBR: uint64
	int 100000
	+
	frame_bury 0 // nonAlgoRewardMBR: uint64

*if1_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:143
	// mbr = ALGORAND_ACCOUNT_MIN_BALANCE +
	//       nonAlgoRewardMBR +
	//       this.costForBoxStorage(7 + len<StakeInfo>() * MAX_STAKERS_PER_POOL) +
	//       this.costForBoxStorage(7 + len<uint64>() * 15)
	int 100000
	frame_dig 0 // nonAlgoRewardMBR: uint64
	+
	int 24007
	callsub costForBoxStorage
	+
	int 127
	callsub costForBoxStorage
	+
	frame_bury 1 // mbr: uint64

	// contracts/InjectedRewardsPoolConsensus.algo.ts:148
	// return {
	//       mbrPayment: mbr
	//     }
	frame_dig 1 // mbr: uint64
	itob

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// initStorage(pay)void
*abi_route_initStorage:
	// mbrPayment: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==

	// argument 0 (mbrPayment) for initStorage must be a pay transaction
	assert

	// execute initStorage(pay)void
	callsub initStorage
	int 1
	return

// initStorage(mbrPayment: PayTxn): void
initStorage:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/InjectedRewardsPoolConsensus.algo.ts:154
	// assert(!this.stakers.exists, 'staking pool already initialized')
	byte 0x7374616b657273 // "stakers"
	box_len
	swap
	pop
	!

	// staking pool already initialized
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:155
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can init storage')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can init storage
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:157
	// nonAlgoRewardMBR = 0
	int 0
	frame_bury 0 // nonAlgoRewardMBR: uint64

	// *if2_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:158
	// this.rewardAssetId.value !== 0
	byte 0x72657761726441737365744964 // "rewardAssetId"
	app_global_get
	int 0
	!=
	bz *if2_end

	// *if2_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:159
	// nonAlgoRewardMBR += ASSET_HOLDING_FEE
	frame_dig 0 // nonAlgoRewardMBR: uint64
	int 100000
	+
	frame_bury 0 // nonAlgoRewardMBR: uint64

*if2_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:161
	// poolMBR = ALGORAND_ACCOUNT_MIN_BALANCE +
	//       nonAlgoRewardMBR +
	//       this.costForBoxStorage(7 + len<StakeInfo>() * MAX_STAKERS_PER_POOL) +
	//       this.costForBoxStorage(7 + len<uint64>() * 15)
	int 100000
	frame_dig 0 // nonAlgoRewardMBR: uint64
	+
	int 24007
	callsub costForBoxStorage
	+
	int 127
	callsub costForBoxStorage
	+
	frame_bury 1 // poolMBR: uint64

	// contracts/InjectedRewardsPoolConsensus.algo.ts:167
	// verifyPayTxn(mbrPayment, { receiver: this.app.address, amount: poolMBR })
	// verify receiver
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Amount
	frame_dig 1 // poolMBR: uint64
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"amount","expected":"poolMBR"}
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:168
	// this.stakers.create()
	byte 0x7374616b657273 // "stakers"
	int 24000
	box_create
	pop

	// contracts/InjectedRewardsPoolConsensus.algo.ts:169
	// this.minimumBalance.value = poolMBR
	byte 0x6d696e696d756d42616c616e6365 // "minimumBalance"
	frame_dig 1 // poolMBR: uint64
	app_global_put

	// *if3_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:171
	// nonAlgoRewardMBR > 0
	frame_dig 0 // nonAlgoRewardMBR: uint64
	int 0
	>
	bz *if3_end

	// *if3_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:173
	// sendAssetTransfer({
	//         xferAsset: AssetID.fromUint64(this.rewardAssetId.value),
	//         assetReceiver: this.app.address,
	//         assetAmount: 0,
	//       })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/InjectedRewardsPoolConsensus.algo.ts:174
	// xferAsset: AssetID.fromUint64(this.rewardAssetId.value)
	byte 0x72657761726441737365744964 // "rewardAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/InjectedRewardsPoolConsensus.algo.ts:175
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/InjectedRewardsPoolConsensus.algo.ts:176
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if3_end:
	retsub

// injectRewards(axfer,uint64,uint64)void
*abi_route_injectRewards:
	// rewardAssetId: uint64
	txna ApplicationArgs 2
	btoi

	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// rewardTxn: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==

	// argument 2 (rewardTxn) for injectRewards must be a axfer transaction
	assert

	// execute injectRewards(axfer,uint64,uint64)void
	callsub injectRewards
	int 1
	return

// injectRewards(rewardTxn: AssetTransferTxn, quantity: uint64, rewardAssetId: uint64): void
injectRewards:
	proto 3 0

	// contracts/InjectedRewardsPoolConsensus.algo.ts:184
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can inject rewards')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can inject rewards
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:186
	// verifyAssetTransferTxn(rewardTxn, {
	//       sender: this.adminAddress.value,
	//       assetReceiver: this.app.address,
	//       xferAsset: AssetID.fromUint64(rewardAssetId),
	//       assetAmount: quantity,
	//     })
	// verify sender
	frame_dig -1 // rewardTxn: AssetTransferTxn
	gtxns Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// transaction verification failed: {"txn":"rewardTxn","field":"sender","expected":"this.adminAddress.value"}
	assert

	// verify assetReceiver
	frame_dig -1 // rewardTxn: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"rewardTxn","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig -1 // rewardTxn: AssetTransferTxn
	gtxns XferAsset
	frame_dig -3 // rewardAssetId: uint64
	==

	// transaction verification failed: {"txn":"rewardTxn","field":"xferAsset","expected":"AssetID.fromUint64(rewardAssetId)"}
	assert

	// verify assetAmount
	frame_dig -1 // rewardTxn: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -2 // quantity: uint64
	==

	// transaction verification failed: {"txn":"rewardTxn","field":"assetAmount","expected":"quantity"}
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:192
	// this.injectedASARewards.value += quantity
	byte 0x696e6a656374656441534152657761726473 // "injectedASARewards"
	app_global_get
	frame_dig -2 // quantity: uint64
	+
	byte 0x696e6a656374656441534152657761726473 // "injectedASARewards"
	swap
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:193
	// this.lastRewardInjectionTime.value = globals.latestTimestamp
	byte 0x6c617374526577617264496e6a656374696f6e54696d65 // "lastRewardInjectionTime"
	global LatestTimestamp
	app_global_put
	retsub

// injectAlgoRewards(pay,uint64)void
*abi_route_injectAlgoRewards:
	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// payTxn: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==

	// argument 1 (payTxn) for injectAlgoRewards must be a pay transaction
	assert

	// execute injectAlgoRewards(pay,uint64)void
	callsub injectAlgoRewards
	int 1
	return

// injectAlgoRewards(payTxn: PayTxn, quantity: uint64): void
injectAlgoRewards:
	proto 2 0

	// contracts/InjectedRewardsPoolConsensus.algo.ts:197
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can inject rewards')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can inject rewards
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:199
	// verifyPayTxn(payTxn, {
	//       receiver: this.app.address,
	//       amount: quantity,
	//     })
	// verify receiver
	frame_dig -1 // payTxn: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payTxn","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // payTxn: PayTxn
	gtxns Amount
	frame_dig -2 // quantity: uint64
	==

	// transaction verification failed: {"txn":"payTxn","field":"amount","expected":"quantity"}
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:204
	// this.algoInjectedRewards.value += quantity
	byte 0x616c676f496e6a656374656452657761726473 // "algoInjectedRewards"
	app_global_get
	frame_dig -2 // quantity: uint64
	+
	byte 0x616c676f496e6a656374656452657761726473 // "algoInjectedRewards"
	swap
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:205
	// this.lastRewardInjectionTime.value = globals.latestTimestamp
	byte 0x6c617374526577617264496e6a656374696f6e54696d65 // "lastRewardInjectionTime"
	global LatestTimestamp
	app_global_put
	retsub

// pickupAlgoRewards()void
*abi_route_pickupAlgoRewards:
	// execute pickupAlgoRewards()void
	callsub pickupAlgoRewards
	int 1
	return

// pickupAlgoRewards(): void
pickupAlgoRewards:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/InjectedRewardsPoolConsensus.algo.ts:210
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can inject rewards')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can inject rewards
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:212
	// amount = this.app.address.balance - this.minimumBalance.value - this.totalConsensusRewards.value - this.algoInjectedRewards.value - this.totalStaked.value
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	byte 0x6d696e696d756d42616c616e6365 // "minimumBalance"
	app_global_get
	-
	byte 0x746f74616c436f6e73656e73757352657761726473 // "totalConsensusRewards"
	app_global_get
	-
	byte 0x616c676f496e6a656374656452657761726473 // "algoInjectedRewards"
	app_global_get
	-
	byte 0x746f74616c5374616b6564 // "totalStaked"
	app_global_get
	-
	frame_bury 0 // amount: uint64

	// *if4_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:213
	// amount > MINIMUM_ALGO_REWARD
	frame_dig 0 // amount: uint64
	int 1000000
	>
	bz *if4_end

	// *if4_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:214
	// this.algoInjectedRewards.value += amount
	byte 0x616c676f496e6a656374656452657761726473 // "algoInjectedRewards"
	app_global_get
	frame_dig 0 // amount: uint64
	+
	byte 0x616c676f496e6a656374656452657761726473 // "algoInjectedRewards"
	swap
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:215
	// this.lastRewardInjectionTime.value = globals.latestTimestamp
	byte 0x6c617374526577617264496e6a656374696f6e54696d65 // "lastRewardInjectionTime"
	global LatestTimestamp
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:216
	// this.totalConsensusRewards.value += amount
	byte 0x746f74616c436f6e73656e73757352657761726473 // "totalConsensusRewards"
	app_global_get
	frame_dig 0 // amount: uint64
	+
	byte 0x746f74616c436f6e73656e73757352657761726473 // "totalConsensusRewards"
	swap
	app_global_put

*if4_end:
	retsub

// deleteApplication()void
*abi_route_deleteApplication:
	// execute deleteApplication()void
	callsub deleteApplication
	int 1
	return

// deleteApplication(): void
deleteApplication:
	proto 0 0

	// contracts/InjectedRewardsPoolConsensus.algo.ts:222
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can delete application')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can delete application
	assert
	retsub

// stake(pay,uint64)void
*abi_route_stake:
	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// payTxn: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==

	// argument 1 (payTxn) for stake must be a pay transaction
	assert

	// execute stake(pay,uint64)void
	callsub stake
	int 1
	return

// stake(payTxn: PayTxn, quantity: uint64): void
stake:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// contracts/InjectedRewardsPoolConsensus.algo.ts:237
	// currentTimeStamp = globals.latestTimestamp
	global LatestTimestamp
	frame_bury 0 // currentTimeStamp: uint64

	// contracts/InjectedRewardsPoolConsensus.algo.ts:238
	// assert(quantity > 0, 'Invalid quantity')
	frame_dig -2 // quantity: uint64
	int 0
	>

	// Invalid quantity
	assert

	// *if5_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:239
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if5_end

	// *if5_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:240
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if5_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:242
	// verifyPayTxn(payTxn, {
	//       sender: this.txn.sender,
	//       receiver: this.app.address,
	//       amount: quantity,
	//     })
	// verify sender
	frame_dig -1 // payTxn: PayTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"payTxn","field":"sender","expected":"this.txn.sender"}
	assert

	// verify receiver
	frame_dig -1 // payTxn: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payTxn","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // payTxn: PayTxn
	gtxns Amount
	frame_dig -2 // quantity: uint64
	==

	// transaction verification failed: {"txn":"payTxn","field":"amount","expected":"quantity"}
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:247
	// actionComplete: boolean = false
	int 0
	frame_bury 1 // actionComplete: boolean

	// *if6_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:248
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if6_end

	// *if6_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:249
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if6_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:251
	// for (let i = 0; i < this.stakers.value.length; i += 1)
	int 0
	frame_bury 2 // i: uint64

*for_0:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:251
	// i < this.stakers.value.length
	frame_dig 2 // i: uint64
	int 250
	<
	bz *for_0_end

	// *if7_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:252
	// actionComplete
	frame_dig 1 // actionComplete: boolean
	bz *if7_end

	// *if7_consequent
	b *for_0_end

*if7_end:
	// *if8_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:254
	// this.stakers.value[i].account === this.txn.sender
	frame_dig 2 // i: uint64
	int 96
	* // acc * typeLength
	int 0
	+
	int 32
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	txn Sender
	==
	bz *if8_elseif1_condition

	// *if8_consequent
	// *if9_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:257
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if9_end

	// *if9_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:258
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if9_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:261
	// staker = clone(this.stakers.value[i])
	frame_dig 2 // i: uint64
	int 96
	* // acc * typeLength
	int 96
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	frame_bury 3 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/InjectedRewardsPoolConsensus.algo.ts:262
	// staker.stake += payTxn.amount
	frame_dig 3 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 32 // headOffset
	frame_dig 3 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig -1 // payTxn: PayTxn
	gtxns Amount
	+
	itob
	replace3
	frame_bury 3 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// *if10_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:264
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if10_end

	// *if10_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:265
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if10_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:267
	// staker.stakeDuration = 0
	frame_dig 3 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	byte 0x0000000000000000
	replace2 40
	frame_bury 3 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/InjectedRewardsPoolConsensus.algo.ts:268
	// staker.stakeStartTime = currentTimeStamp
	frame_dig 3 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 48 // headOffset
	frame_dig 0 // currentTimeStamp: uint64
	itob
	replace3
	frame_bury 3 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// *if11_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:269
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if11_end

	// *if11_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:270
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if11_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:272
	// this.stakers.value[i] = staker
	frame_dig 2 // i: uint64
	int 96
	* // acc * typeLength
	frame_dig 3 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace

	// *if12_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:273
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if12_end

	// *if12_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:274
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if12_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:276
	// this.totalStaked.value += payTxn.amount
	byte 0x746f74616c5374616b6564 // "totalStaked"
	app_global_get
	frame_dig -1 // payTxn: PayTxn
	gtxns Amount
	+
	byte 0x746f74616c5374616b6564 // "totalStaked"
	swap
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:277
	// actionComplete = true
	int 1
	frame_bury 1 // actionComplete: boolean
	b *if8_end

*if8_elseif1_condition:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:279
	// this.stakers.value[i].account === globals.zeroAddress
	frame_dig 2 // i: uint64
	int 96
	* // acc * typeLength
	int 0
	+
	int 32
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	global ZeroAddress
	==
	bz *if8_end

	// *if8_elseif1_consequent
	// *if13_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:280
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if13_end

	// *if13_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:281
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if13_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:283
	// this.totalStaked.value = this.totalStaked.value + payTxn.amount
	byte 0x746f74616c5374616b6564 // "totalStaked"
	dup
	app_global_get
	frame_dig -1 // payTxn: PayTxn
	gtxns Amount
	+
	app_global_put

	// *if14_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:284
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if14_end

	// *if14_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:285
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if14_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:287
	// this.stakers.value[i] = {
	//           account: this.txn.sender,
	//           stake: payTxn.amount,
	//           stakeDuration: 0,
	//           stakeStartTime: currentTimeStamp,
	//           algoAccuredRewards: 0,
	//           lastUpdateTime: currentTimeStamp,
	//           accruedASARewards: 0,
	//           userSharePercentage: 0,
	//           lstMinted: 0
	//         }
	frame_dig 2 // i: uint64
	int 96
	* // acc * typeLength
	txn Sender
	frame_dig -1 // payTxn: PayTxn
	gtxns Amount
	itob
	concat
	byte 0x0000000000000000
	concat
	frame_dig 0 // currentTimeStamp: uint64
	itob
	concat
	byte 0x0000000000000000
	concat
	frame_dig 0 // currentTimeStamp: uint64
	itob
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace

	// *if15_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:298
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if15_end

	// *if15_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:299
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if15_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:301
	// this.numStakers.value = this.numStakers.value + 1
	byte 0x6e756d5374616b657273 // "numStakers"
	dup
	app_global_get
	int 1
	+
	app_global_put

	// *if16_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:302
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if16_end

	// *if16_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:303
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if16_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:305
	// actionComplete = true
	int 1
	frame_bury 1 // actionComplete: boolean

*if8_end:
	// *if17_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:308
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if17_end

	// *if17_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:309
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if17_end:

*for_0_continue:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:251
	// i += 1
	frame_dig 2 // i: uint64
	int 1
	+
	frame_bury 2 // i: uint64
	b *for_0

*for_0_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:312
	// assert(actionComplete, 'Stake  failed')
	frame_dig 1 // actionComplete: boolean

	// Stake  failed
	assert
	retsub

// accrueRewards()void
*abi_route_accrueRewards:
	// execute accrueRewards()void
	callsub accrueRewards
	int 1
	return

// accrueRewards(): void
accrueRewards:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 9

	// contracts/InjectedRewardsPoolConsensus.algo.ts:316
	// algoRewards = (this.algoInjectedRewards.value / 100 * (100 - this.commision.value))
	byte 0x616c676f496e6a656374656452657761726473 // "algoInjectedRewards"
	app_global_get
	int 100
	/
	int 100
	byte 0x636f6d6d6973696f6e // "commision"
	app_global_get
	-
	*
	frame_bury 0 // algoRewards: uint64

	// contracts/InjectedRewardsPoolConsensus.algo.ts:318
	// additionalASARewards = this.injectedASARewards.value
	byte 0x696e6a656374656441534152657761726473 // "injectedASARewards"
	app_global_get
	frame_bury 1 // additionalASARewards: uint64

	// *if18_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:319
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if18_end

	// *if18_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:320
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if18_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:322
	// totalViableStake = 0
	int 0
	frame_bury 2 // totalViableStake: uint64

	// contracts/InjectedRewardsPoolConsensus.algo.ts:323
	// for (let i = 0; i < this.numStakers.value; i += 1)
	int 0
	frame_bury 3 // i: uint64

*for_1:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:323
	// i < this.numStakers.value
	frame_dig 3 // i: uint64
	byte 0x6e756d5374616b657273 // "numStakers"
	app_global_get
	<
	bz *for_1_end

	// *if19_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:324
	// this.stakers.value[i].stake > 0
	frame_dig 3 // i: uint64
	int 96
	* // acc * typeLength
	int 32 // headOffset
	+
	int 8
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	btoi
	int 0
	>
	bz *if19_end

	// *if19_consequent
	// *if20_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:325
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if20_end

	// *if20_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:326
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if20_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:328
	// this.stakers.value[i].stakeDuration = globals.latestTimestamp - this.stakers.value[i].stakeStartTime
	frame_dig 3 // i: uint64
	int 96
	* // acc * typeLength
	int 40 // headOffset
	+
	global LatestTimestamp
	frame_dig 3 // i: uint64
	int 96
	* // acc * typeLength
	int 48 // headOffset
	+
	int 8
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	btoi
	-
	itob
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace

	// *if21_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:330
	// this.stakers.value[i].stakeDuration >= this.minStakePeriodForRewards.value
	frame_dig 3 // i: uint64
	int 96
	* // acc * typeLength
	int 40 // headOffset
	+
	int 8
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	btoi
	byte 0x6d696e5374616b65506572696f64466f7252657761726473 // "minStakePeriodForRewards"
	app_global_get
	>=
	bz *if21_end

	// *if21_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:331
	// totalViableStake += this.stakers.value[i].stake
	frame_dig 2 // totalViableStake: uint64
	frame_dig 3 // i: uint64
	int 96
	* // acc * typeLength
	int 32 // headOffset
	+
	int 8
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	btoi
	+
	frame_bury 2 // totalViableStake: uint64

*if21_end:

*if19_end:

*for_1_continue:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:323
	// i += 1
	frame_dig 3 // i: uint64
	int 1
	+
	frame_bury 3 // i: uint64
	b *for_1

*for_1_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:336
	// for (let i = 0; i < this.numStakers.value; i += 1)
	int 0
	frame_bury 4 // i: uint64

*for_2:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:336
	// i < this.numStakers.value
	frame_dig 4 // i: uint64
	byte 0x6e756d5374616b657273 // "numStakers"
	app_global_get
	<
	bz *for_2_end

	// *if22_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:337
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if22_end

	// *if22_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:338
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if22_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:340
	// stake = this.stakers.value[i].stake
	frame_dig 4 // i: uint64
	int 96
	* // acc * typeLength
	int 32 // headOffset
	+
	int 8
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	btoi
	frame_bury 5 // stake: uint64

	// *if23_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:342
	// stake > 0
	frame_dig 5 // stake: uint64
	int 0
	>
	bz *if23_end

	// *if23_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:343
	// staker = clone(this.stakers.value[i])
	frame_dig 4 // i: uint64
	int 96
	* // acc * typeLength
	int 96
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	frame_bury 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// *if24_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:345
	// staker.stakeDuration > this.minStakePeriodForRewards.value
	frame_dig 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 40 8
	btoi
	byte 0x6d696e5374616b65506572696f64466f7252657761726473 // "minStakePeriodForRewards"
	app_global_get
	>
	bz *if24_end

	// *if24_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:347
	// stakerShare = wideRatio([stake, PRECISION], [totalViableStake])
	frame_dig 5 // stake: uint64
	int 1000000000000000
	mulw
	int 0
	frame_dig 2 // totalViableStake: uint64
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 7 // stakerShare: uint64

	// contracts/InjectedRewardsPoolConsensus.algo.ts:348
	// staker.userSharePercentage = stakerShare
	frame_dig 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 80 // headOffset
	frame_dig 7 // stakerShare: uint64
	itob
	replace3
	frame_bury 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// *if25_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:350
	// algoRewards > 0
	frame_dig 0 // algoRewards: uint64
	int 0
	>
	bz *if25_end

	// *if25_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:351
	// algoRewardRate = wideRatio([algoRewards, stakerShare], [PRECISION])
	frame_dig 0 // algoRewards: uint64
	frame_dig 7 // stakerShare: uint64
	mulw
	int 0
	int 1000000000000000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 8 // algoRewardRate: uint64

	// *if26_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:352
	// algoRewardRate === 0
	frame_dig 8 // algoRewardRate: uint64
	int 0
	==
	bz *if26_end

	// *if26_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:353
	// algoRewardRate = 1
	int 1
	frame_bury 8 // algoRewardRate: uint64

*if26_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:355
	// staker.algoAccuredRewards = staker.algoAccuredRewards + algoRewardRate
	frame_dig 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 56 // headOffset
	frame_dig 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 56 8
	btoi
	frame_dig 8 // algoRewardRate: uint64
	+
	itob
	replace3
	frame_bury 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/InjectedRewardsPoolConsensus.algo.ts:356
	// this.algoInjectedRewards.value = this.algoInjectedRewards.value - algoRewardRate
	byte 0x616c676f496e6a656374656452657761726473 // "algoInjectedRewards"
	dup
	app_global_get
	frame_dig 8 // algoRewardRate: uint64
	-
	app_global_put

	// *if27_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:358
	// this.stakedAssetId.value === 0
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	app_global_get
	int 0
	==
	bz *if27_end

	// *if27_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:359
	// staker.stake = staker.stake + algoRewardRate
	frame_dig 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 32 // headOffset
	frame_dig 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig 8 // algoRewardRate: uint64
	+
	itob
	replace3
	frame_bury 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/InjectedRewardsPoolConsensus.algo.ts:360
	// this.totalStaked.value = this.totalStaked.value + algoRewardRate
	byte 0x746f74616c5374616b6564 // "totalStaked"
	dup
	app_global_get
	frame_dig 8 // algoRewardRate: uint64
	+
	app_global_put

*if27_end:

*if25_end:
	// *if28_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:364
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if28_end

	// *if28_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:365
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if28_end:
	// *if29_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:368
	// additionalASARewards > 0
	frame_dig 1 // additionalASARewards: uint64
	int 0
	>
	bz *if29_end

	// *if29_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:369
	// rewardRate = wideRatio([additionalASARewards, stakerShare], [PRECISION])
	frame_dig 1 // additionalASARewards: uint64
	frame_dig 7 // stakerShare: uint64
	mulw
	int 0
	int 1000000000000000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 9 // rewardRate: uint64

	// *if30_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:370
	// rewardRate === 0
	frame_dig 9 // rewardRate: uint64
	int 0
	==
	bz *if30_end

	// *if30_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:371
	// rewardRate = 1
	int 1
	frame_bury 9 // rewardRate: uint64

*if30_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:375
	// this.injectedASARewards.value = this.injectedASARewards.value - rewardRate
	byte 0x696e6a656374656441534152657761726473 // "injectedASARewards"
	dup
	app_global_get
	frame_dig 9 // rewardRate: uint64
	-
	app_global_put

	// *if31_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:376
	// this.rewardAssetId.value === this.stakedAssetId.value
	byte 0x72657761726441737365744964 // "rewardAssetId"
	app_global_get
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	app_global_get
	==
	bz *if31_else

	// *if31_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:378
	// staker.stake = staker.stake + rewardRate
	frame_dig 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 32 // headOffset
	frame_dig 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig 9 // rewardRate: uint64
	+
	itob
	replace3
	frame_bury 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/InjectedRewardsPoolConsensus.algo.ts:379
	// this.totalStaked.value = this.totalStaked.value + rewardRate
	byte 0x746f74616c5374616b6564 // "totalStaked"
	dup
	app_global_get
	frame_dig 9 // rewardRate: uint64
	+
	app_global_put
	b *if31_end

*if31_else:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:381
	// staker.accruedASARewards = staker.accruedASARewards + rewardRate
	frame_dig 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 72 // headOffset
	frame_dig 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 72 8
	btoi
	frame_dig 9 // rewardRate: uint64
	+
	itob
	replace3
	frame_bury 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

*if31_end:

*if29_end:

*if24_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:385
	// staker.lastUpdateTime = globals.latestTimestamp
	frame_dig 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 64 // headOffset
	global LatestTimestamp
	itob
	replace3
	frame_bury 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/InjectedRewardsPoolConsensus.algo.ts:386
	// this.stakers.value[i] = staker
	frame_dig 4 // i: uint64
	int 96
	* // acc * typeLength
	frame_dig 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace

*if23_end:

*for_2_continue:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:336
	// i += 1
	frame_dig 4 // i: uint64
	int 1
	+
	frame_bury 4 // i: uint64
	b *for_2

*for_2_end:
	retsub

// getStaker(address: Address): StakeInfo
getStaker:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/InjectedRewardsPoolConsensus.algo.ts:392
	// for (let i = 0; i < this.numStakers.value; i += 1)
	int 0
	frame_bury 0 // i: uint64

*for_3:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:392
	// i < this.numStakers.value
	frame_dig 0 // i: uint64
	byte 0x6e756d5374616b657273 // "numStakers"
	app_global_get
	<
	bz *for_3_end

	// *if32_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:393
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if32_end

	// *if32_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:394
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if32_end:
	// *if33_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:396
	// this.stakers.value[i].account === address
	frame_dig 0 // i: uint64
	int 96
	* // acc * typeLength
	int 0
	+
	int 32
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	frame_dig -1 // address: Address
	==
	bz *if33_end

	// *if33_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:397
	// return clone(this.stakers.value[i]);
	frame_dig 0 // i: uint64
	int 96
	* // acc * typeLength
	int 96
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	b *getStaker*return

*if33_end:

*for_3_continue:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:392
	// i += 1
	frame_dig 0 // i: uint64
	int 1
	+
	frame_bury 0 // i: uint64
	b *for_3

*for_3_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:400
	// return {
	//       account: globals.zeroAddress,
	//       stake: 0,
	//       stakeDuration: 0,
	//       stakeStartTime: 0,
	//       lastUpdateTime: 0,
	//       algoAccuredRewards: 0,
	//       accruedASARewards: 0,
	//       userSharePercentage: 0,
	//       lstMinted: 0
	//     }
	global ZeroAddress
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat

*getStaker*return:
	// set the subroutine return value
	frame_bury 0
	retsub

// setStaker(stakerAccount: Address, staker: StakeInfo): void
setStaker:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/InjectedRewardsPoolConsensus.algo.ts:413
	// for (let i = 0; i < this.numStakers.value; i += 1)
	int 0
	frame_bury 0 // i: uint64

*for_4:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:413
	// i < this.numStakers.value
	frame_dig 0 // i: uint64
	byte 0x6e756d5374616b657273 // "numStakers"
	app_global_get
	<
	bz *for_4_end

	// *if34_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:414
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if34_end

	// *if34_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:415
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if34_end:
	// *if35_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:417
	// this.stakers.value[i].account === stakerAccount
	frame_dig 0 // i: uint64
	int 96
	* // acc * typeLength
	int 0
	+
	int 32
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	frame_dig -1 // stakerAccount: Address
	==
	bz *if35_end

	// *if35_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:418
	// this.stakers.value[i] = staker
	frame_dig 0 // i: uint64
	int 96
	* // acc * typeLength
	frame_dig -2 // staker: StakeInfo
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace

	// contracts/InjectedRewardsPoolConsensus.algo.ts:419
	// return;
	retsub

*if35_end:

*for_4_continue:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:413
	// i += 1
	frame_dig 0 // i: uint64
	int 1
	+
	frame_bury 0 // i: uint64
	b *for_4

*for_4_end:
	retsub

// claimRewards()void
*abi_route_claimRewards:
	// execute claimRewards()void
	callsub claimRewards
	int 1
	return

// claimRewards(): void
claimRewards:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// *if36_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:425
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if36_end

	// *if36_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:426
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if36_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:428
	// staker = this.getStaker(this.txn.sender)
	txn Sender
	callsub getStaker
	frame_bury 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// *if37_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:431
	// staker.algoAccuredRewards > 0
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 56 8
	btoi
	int 0
	>
	bz *if37_end

	// *if37_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:432
	// sendPayment({
	//         amount: staker.algoAccuredRewards,
	//         receiver: this.txn.sender,
	//         sender: this.app.address,
	//         fee: 1_000,
	//       })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/InjectedRewardsPoolConsensus.algo.ts:433
	// amount: staker.algoAccuredRewards
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 56 8
	btoi
	itxn_field Amount

	// contracts/InjectedRewardsPoolConsensus.algo.ts:434
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/InjectedRewardsPoolConsensus.algo.ts:435
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/InjectedRewardsPoolConsensus.algo.ts:436
	// fee: 1_000
	int 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/InjectedRewardsPoolConsensus.algo.ts:438
	// staker.algoAccuredRewards = 0
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	byte 0x0000000000000000
	replace2 56
	frame_bury 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

*if37_end:
	// *if38_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:442
	// staker.accruedASARewards > 0
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 72 8
	btoi
	int 0
	>
	bz *if38_end

	// *if38_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:443
	// sendAssetTransfer({
	//         xferAsset: AssetID.fromUint64(this.rewardAssetId.value),
	//         assetReceiver: this.txn.sender,
	//         sender: this.app.address,
	//         assetAmount: staker.accruedASARewards,
	//         fee: 1_000,
	//       })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/InjectedRewardsPoolConsensus.algo.ts:444
	// xferAsset: AssetID.fromUint64(this.rewardAssetId.value)
	byte 0x72657761726441737365744964 // "rewardAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/InjectedRewardsPoolConsensus.algo.ts:445
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/InjectedRewardsPoolConsensus.algo.ts:446
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/InjectedRewardsPoolConsensus.algo.ts:447
	// assetAmount: staker.accruedASARewards
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 72 8
	btoi
	itxn_field AssetAmount

	// contracts/InjectedRewardsPoolConsensus.algo.ts:448
	// fee: 1_000
	int 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/InjectedRewardsPoolConsensus.algo.ts:450
	// staker.accruedASARewards = 0
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	byte 0x0000000000000000
	replace2 72
	frame_bury 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

*if38_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:454
	// staker.lastUpdateTime = globals.latestTimestamp
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 64 // headOffset
	global LatestTimestamp
	itob
	replace3
	frame_bury 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/InjectedRewardsPoolConsensus.algo.ts:455
	// this.setStaker(staker.account, staker)
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 0 32
	callsub setStaker

	// *if39_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:456
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if39_end

	// *if39_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:457
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if39_end:
	retsub

// unstake(axfer,uint64)void
*abi_route_unstake:
	// percentageQuantity: uint64
	txna ApplicationArgs 1
	btoi

	// axferTxn: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==

	// argument 1 (axferTxn) for unstake must be a axfer transaction
	assert

	// execute unstake(axfer,uint64)void
	callsub unstake
	int 1
	return

// unstake(axferTxn: AssetTransferTxn, percentageQuantity: uint64): void
unstake:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 4

	// contracts/InjectedRewardsPoolConsensus.algo.ts:462
	// staker = this.getStaker(this.txn.sender)
	txn Sender
	callsub getStaker
	frame_bury 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/InjectedRewardsPoolConsensus.algo.ts:465
	// burnQuantity = staker.lstMinted / 100 * (100 - percentageQuantity)
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 88 8
	btoi
	int 100
	/
	int 100
	frame_dig -2 // percentageQuantity: uint64
	-
	*
	frame_bury 1 // burnQuantity: uint64

	// contracts/InjectedRewardsPoolConsensus.algo.ts:466
	// unstakeQuantity = staker.stake / 100 * (100 - percentageQuantity)
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	int 100
	/
	int 100
	frame_dig -2 // percentageQuantity: uint64
	-
	*
	frame_bury 2 // unstakeQuantity: uint64

	// contracts/InjectedRewardsPoolConsensus.algo.ts:468
	// verifyAssetTransferTxn(axferTxn, {
	//       assetAmount: burnQuantity,
	//       assetReceiver: this.app.address,
	//       assetSender: this.txn.sender,
	//       xferAsset: AssetID.fromUint64(this.stakedAssetId.value)
	//     })
	// verify assetAmount
	frame_dig -1 // axferTxn: AssetTransferTxn
	gtxns AssetAmount
	frame_dig 1 // burnQuantity: uint64
	==

	// transaction verification failed: {"txn":"axferTxn","field":"assetAmount","expected":"burnQuantity"}
	assert

	// verify assetReceiver
	frame_dig -1 // axferTxn: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"axferTxn","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify assetSender
	frame_dig -1 // axferTxn: AssetTransferTxn
	gtxns AssetSender
	txn Sender
	==

	// transaction verification failed: {"txn":"axferTxn","field":"assetSender","expected":"this.txn.sender"}
	assert

	// verify xferAsset
	frame_dig -1 // axferTxn: AssetTransferTxn
	gtxns XferAsset
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	app_global_get
	==

	// transaction verification failed: {"txn":"axferTxn","field":"xferAsset","expected":"AssetID.fromUint64(this.stakedAssetId.value)"}
	assert

	// *if40_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:475
	// staker.stake > 0
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	int 0
	>
	bz *if40_end

	// *if40_consequent
	// *if41_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:477
	// this.stakedAssetId.value === 0
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	app_global_get
	int 0
	==
	bz *if41_else

	// *if41_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:478
	// sendPayment({
	//           amount: unstakeQuantity,
	//           receiver: this.txn.sender,
	//           sender: this.app.address,
	//           fee: 1_000,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/InjectedRewardsPoolConsensus.algo.ts:479
	// amount: unstakeQuantity
	frame_dig 2 // unstakeQuantity: uint64
	itxn_field Amount

	// contracts/InjectedRewardsPoolConsensus.algo.ts:480
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/InjectedRewardsPoolConsensus.algo.ts:481
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/InjectedRewardsPoolConsensus.algo.ts:482
	// fee: 1_000
	int 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if41_end

*if41_else:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:487
	// sendAssetTransfer({
	//           xferAsset: AssetID.fromUint64(this.stakedAssetId.value),
	//           assetReceiver: this.txn.sender,
	//           sender: this.app.address,
	//           assetAmount: unstakeQuantity,
	//           fee: 1_000,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/InjectedRewardsPoolConsensus.algo.ts:488
	// xferAsset: AssetID.fromUint64(this.stakedAssetId.value)
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/InjectedRewardsPoolConsensus.algo.ts:489
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/InjectedRewardsPoolConsensus.algo.ts:490
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/InjectedRewardsPoolConsensus.algo.ts:491
	// assetAmount: unstakeQuantity
	frame_dig 2 // unstakeQuantity: uint64
	itxn_field AssetAmount

	// contracts/InjectedRewardsPoolConsensus.algo.ts:492
	// fee: 1_000
	int 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if41_end:

*if40_end:
	// *if42_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:498
	// staker.accruedASARewards > 0
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 72 8
	btoi
	int 0
	>
	bz *if42_end

	// *if42_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:499
	// sendAssetTransfer({
	//         xferAsset: AssetID.fromUint64(this.rewardAssetId.value),
	//         assetReceiver: this.txn.sender,
	//         sender: this.app.address,
	//         assetAmount: staker.accruedASARewards,
	//         fee: 1_000,
	//       })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/InjectedRewardsPoolConsensus.algo.ts:500
	// xferAsset: AssetID.fromUint64(this.rewardAssetId.value)
	byte 0x72657761726441737365744964 // "rewardAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/InjectedRewardsPoolConsensus.algo.ts:501
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/InjectedRewardsPoolConsensus.algo.ts:502
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/InjectedRewardsPoolConsensus.algo.ts:503
	// assetAmount: staker.accruedASARewards
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 72 8
	btoi
	itxn_field AssetAmount

	// contracts/InjectedRewardsPoolConsensus.algo.ts:504
	// fee: 1_000
	int 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/InjectedRewardsPoolConsensus.algo.ts:506
	// staker.accruedASARewards = 0
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	byte 0x0000000000000000
	replace2 72
	frame_bury 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

*if42_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:510
	// this.totalStaked.value = this.totalStaked.value - unstakeQuantity
	byte 0x746f74616c5374616b6564 // "totalStaked"
	dup
	app_global_get
	frame_dig 2 // unstakeQuantity: uint64
	-
	app_global_put

	// *if43_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:512
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if43_end

	// *if43_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:513
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if43_end:
	// *if44_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:516
	// percentageQuantity === 100
	frame_dig -2 // percentageQuantity: uint64
	int 100
	==
	bz *if44_else

	// *if44_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:517
	// removedStaker: StakeInfo = {
	//         account: globals.zeroAddress,
	//         stake: 0,
	//         stakeDuration: 0,
	//         stakeStartTime: 0,
	//         lastUpdateTime: 0,
	//         algoAccuredRewards: 0,
	//         accruedASARewards: 0,
	//         userSharePercentage: 0,
	//         lstMinted: 0
	//       }
	global ZeroAddress
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	frame_bury 3 // removedStaker: StakeInfo

	// contracts/InjectedRewardsPoolConsensus.algo.ts:528
	// this.setStaker(staker.account, removedStaker)
	frame_dig 3 // removedStaker: StakeInfo
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 0 32
	callsub setStaker

	// contracts/InjectedRewardsPoolConsensus.algo.ts:530
	// lastStaker = this.getStaker(this.stakers.value[this.numStakers.value].account)
	byte 0x6e756d5374616b657273 // "numStakers"
	app_global_get
	int 96
	* // acc * typeLength
	int 0
	+
	int 32
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	callsub getStaker
	frame_bury 4 // lastStaker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/InjectedRewardsPoolConsensus.algo.ts:531
	// this.setStaker(staker.account, lastStaker)
	frame_dig 4 // lastStaker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 0 32
	callsub setStaker

	// contracts/InjectedRewardsPoolConsensus.algo.ts:533
	// this.numStakers.value = this.numStakers.value - 1
	byte 0x6e756d5374616b657273 // "numStakers"
	dup
	app_global_get
	int 1
	-
	app_global_put
	b *if44_end

*if44_else:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:537
	// staker.stake = staker.stake - unstakeQuantity
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 32 // headOffset
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig 2 // unstakeQuantity: uint64
	-
	itob
	replace3
	frame_bury 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/InjectedRewardsPoolConsensus.algo.ts:538
	// staker.lstMinted = staker.lstMinted - burnQuantity
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 88 // headOffset
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 88 8
	btoi
	frame_dig 1 // burnQuantity: uint64
	-
	itob
	replace3
	frame_bury 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/InjectedRewardsPoolConsensus.algo.ts:539
	// staker.accruedASARewards = 0
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	byte 0x0000000000000000
	replace2 72
	frame_bury 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

*if44_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:541
	// staker.lastUpdateTime = globals.latestTimestamp
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 64 // headOffset
	global LatestTimestamp
	itob
	replace3
	frame_bury 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/InjectedRewardsPoolConsensus.algo.ts:542
	// this.setStaker(staker.account, staker)
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 0 32
	callsub setStaker
	retsub

// setFreeze(bool)void
*abi_route_setFreeze:
	// enabled: bool
	txna ApplicationArgs 1
	dup
	len
	int 1
	==

	// argument 0 (enabled) for setFreeze must be a bool
	assert
	int 0
	getbit

	// execute setFreeze(bool)void
	callsub setFreeze
	int 1
	return

// setFreeze(enabled: boolean): void
setFreeze:
	proto 1 0

	// contracts/InjectedRewardsPoolConsensus.algo.ts:546
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can freeze payouts')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can freeze payouts
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:547
	// this.freeze.value = enabled
	byte 0x667265657a65 // "freeze"
	frame_dig -1 // enabled: boolean
	byte 0x00
	int 0
	uncover 2
	setbit
	app_global_put
	retsub

// getGoOnlineFee(): uint64
getGoOnlineFee:
	proto 0 1

	// contracts/InjectedRewardsPoolConsensus.algo.ts:555
	// return 2000;
	int 2000
	retsub

// goOnline(pay,byte[],byte[],byte[],uint64,uint64,uint64)void
*abi_route_goOnline:
	// voteKeyDilution: uint64
	txna ApplicationArgs 6
	btoi

	// voteLast: uint64
	txna ApplicationArgs 5
	btoi

	// voteFirst: uint64
	txna ApplicationArgs 4
	btoi

	// stateProofPK: byte[]
	txna ApplicationArgs 3
	extract 2 0

	// selectionPK: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// votePK: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// feePayment: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==

	// argument 6 (feePayment) for goOnline must be a pay transaction
	assert

	// execute goOnline(pay,byte[],byte[],byte[],uint64,uint64,uint64)void
	callsub goOnline
	int 1
	return

// goOnline(feePayment: PayTxn, votePK: bytes, selectionPK: bytes, stateProofPK: bytes, voteFirst: uint64, voteLast: uint64, voteKeyDilution: uint64): void
goOnline:
	proto 7 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/InjectedRewardsPoolConsensus.algo.ts:567
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can go online')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can go online
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:569
	// extraFee = this.getGoOnlineFee()
	callsub getGoOnlineFee
	frame_bury 0 // extraFee: uint64

	// contracts/InjectedRewardsPoolConsensus.algo.ts:570
	// verifyPayTxn(feePayment, { receiver: this.app.address, amount: extraFee })
	// verify receiver
	frame_dig -1 // feePayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"feePayment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // feePayment: PayTxn
	gtxns Amount
	frame_dig 0 // extraFee: uint64
	==

	// transaction verification failed: {"txn":"feePayment","field":"amount","expected":"extraFee"}
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:571
	// sendOnlineKeyRegistration({
	//       votePK: votePK,
	//       selectionPK: selectionPK,
	//       stateProofPK: stateProofPK,
	//       voteFirst: voteFirst,
	//       voteLast: voteLast,
	//       voteKeyDilution: voteKeyDilution,
	//       fee: extraFee,
	//     })
	itxn_begin
	int keyreg
	itxn_field TypeEnum

	// contracts/InjectedRewardsPoolConsensus.algo.ts:572
	// votePK: votePK
	frame_dig -2 // votePK: bytes
	itxn_field VotePK

	// contracts/InjectedRewardsPoolConsensus.algo.ts:573
	// selectionPK: selectionPK
	frame_dig -3 // selectionPK: bytes
	itxn_field SelectionPK

	// contracts/InjectedRewardsPoolConsensus.algo.ts:574
	// stateProofPK: stateProofPK
	frame_dig -4 // stateProofPK: bytes
	itxn_field StateProofPK

	// contracts/InjectedRewardsPoolConsensus.algo.ts:575
	// voteFirst: voteFirst
	frame_dig -5 // voteFirst: uint64
	itxn_field VoteFirst

	// contracts/InjectedRewardsPoolConsensus.algo.ts:576
	// voteLast: voteLast
	frame_dig -6 // voteLast: uint64
	itxn_field VoteLast

	// contracts/InjectedRewardsPoolConsensus.algo.ts:577
	// voteKeyDilution: voteKeyDilution
	frame_dig -7 // voteKeyDilution: uint64
	itxn_field VoteKeyDilution

	// contracts/InjectedRewardsPoolConsensus.algo.ts:578
	// fee: extraFee
	frame_dig 0 // extraFee: uint64
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// goOffline()void
*abi_route_goOffline:
	// execute goOffline()void
	callsub goOffline
	int 1
	return

// goOffline(): void
goOffline:
	proto 0 0

	// contracts/InjectedRewardsPoolConsensus.algo.ts:584
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can go offline')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can go offline
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:585
	// sendOfflineKeyRegistration({})
	itxn_begin
	int keyreg
	itxn_field TypeEnum

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// linkToNFD(uint64,string,uint64)void
*abi_route_linkToNFD:
	// nfdRegistryAppId: uint64
	txna ApplicationArgs 3
	btoi

	// nfdName: string
	txna ApplicationArgs 2
	extract 2 0

	// nfdAppId: uint64
	txna ApplicationArgs 1
	btoi

	// execute linkToNFD(uint64,string,uint64)void
	callsub linkToNFD
	int 1
	return

// linkToNFD(nfdAppId: uint64, nfdName: string, nfdRegistryAppId: uint64): void
linkToNFD:
	proto 3 0

	// contracts/InjectedRewardsPoolConsensus.algo.ts:589
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can link to NFD')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can link to NFD
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:591
	// sendAppCall({
	//       applicationID: AppID.fromUint64(nfdRegistryAppId),
	//       applicationArgs: ['verify_nfd_addr', nfdName, itob(nfdAppId), rawBytes(this.app.address)],
	//       applications: [AppID.fromUint64(nfdAppId)],
	//     })
	itxn_begin
	int appl
	itxn_field TypeEnum

	// contracts/InjectedRewardsPoolConsensus.algo.ts:592
	// applicationID: AppID.fromUint64(nfdRegistryAppId)
	frame_dig -3 // nfdRegistryAppId: uint64
	itxn_field ApplicationID

	// contracts/InjectedRewardsPoolConsensus.algo.ts:593
	// applicationArgs: ['verify_nfd_addr', nfdName, itob(nfdAppId), rawBytes(this.app.address)]
	byte 0x7665726966795f6e66645f61646472 // "verify_nfd_addr"
	itxn_field ApplicationArgs
	frame_dig -2 // nfdName: string
	itxn_field ApplicationArgs
	frame_dig -1 // nfdAppId: uint64
	itob
	itxn_field ApplicationArgs
	global CurrentApplicationAddress
	itxn_field ApplicationArgs

	// contracts/InjectedRewardsPoolConsensus.algo.ts:594
	// applications: [AppID.fromUint64(nfdAppId)]
	frame_dig -1 // nfdAppId: uint64
	itxn_field Applications

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// addLST(axfer,uint64)void
*abi_route_addLST:
	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// axferTxn: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==

	// argument 1 (axferTxn) for addLST must be a axfer transaction
	assert

	// execute addLST(axfer,uint64)void
	callsub addLST
	int 1
	return

// addLST(axferTxn: AssetTransferTxn, quantity: uint64): void
addLST:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/InjectedRewardsPoolConsensus.algo.ts:599
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can send LST')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can send LST
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:600
	// lstTokenId = this.lstTokenId.value
	byte 0x6c7374546f6b656e4964 // "lstTokenId"
	app_global_get
	frame_bury 0 // lstTokenId: uint64

	// contracts/InjectedRewardsPoolConsensus.algo.ts:602
	// verifyAssetTransferTxn(axferTxn, {
	//       assetAmount: quantity,
	//       assetReceiver: this.app.address,
	//       assetSender: this.txn.sender,
	//       xferAsset: AssetID.fromUint64(lstTokenId)
	//     })
	// verify assetAmount
	frame_dig -1 // axferTxn: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -2 // quantity: uint64
	==

	// transaction verification failed: {"txn":"axferTxn","field":"assetAmount","expected":"quantity"}
	assert

	// verify assetReceiver
	frame_dig -1 // axferTxn: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"axferTxn","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify assetSender
	frame_dig -1 // axferTxn: AssetTransferTxn
	gtxns AssetSender
	txn Sender
	==

	// transaction verification failed: {"txn":"axferTxn","field":"assetSender","expected":"this.txn.sender"}
	assert

	// verify xferAsset
	frame_dig -1 // axferTxn: AssetTransferTxn
	gtxns XferAsset
	frame_dig 0 // lstTokenId: uint64
	==

	// transaction verification failed: {"txn":"axferTxn","field":"xferAsset","expected":"AssetID.fromUint64(lstTokenId)"}
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:609
	// sendAssetTransfer({
	//       xferAsset: AssetID.fromUint64(lstTokenId),
	//       assetReceiver: this.app.address,
	//       sender: this.app.address,
	//       assetAmount: 0,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/InjectedRewardsPoolConsensus.algo.ts:610
	// xferAsset: AssetID.fromUint64(lstTokenId)
	frame_dig 0 // lstTokenId: uint64
	itxn_field XferAsset

	// contracts/InjectedRewardsPoolConsensus.algo.ts:611
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/InjectedRewardsPoolConsensus.algo.ts:612
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/InjectedRewardsPoolConsensus.algo.ts:613
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// mintLST(uint64)void
*abi_route_mintLST:
	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// execute mintLST(uint64)void
	callsub mintLST
	int 1
	return

// mintLST(quantity: uint64): void
mintLST:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/InjectedRewardsPoolConsensus.algo.ts:618
	// staker = this.getStaker(this.txn.sender)
	txn Sender
	callsub getStaker
	frame_bury 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/InjectedRewardsPoolConsensus.algo.ts:619
	// assert(staker.account !== globals.zeroAddress, 'Invalid staker')
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 0 32
	global ZeroAddress
	!=

	// Invalid staker
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:620
	// assert(staker.stake > 0, 'No staked assets')
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	int 0
	>

	// No staked assets
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:621
	// assert(staker.stake < staker.lstMinted, 'Already minted max LST')
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 88 8
	btoi
	<

	// Already minted max LST
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:622
	// assert(quantity > 0, 'Invalid quantity')
	frame_dig -1 // quantity: uint64
	int 0
	>

	// Invalid quantity
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:624
	// lstMintRemaining = staker.stake - staker.lstMinted
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 88 8
	btoi
	-
	frame_bury 1 // lstMintRemaining: uint64

	// contracts/InjectedRewardsPoolConsensus.algo.ts:625
	// assert(quantity <= lstMintRemaining, 'Invalid quantity')
	frame_dig -1 // quantity: uint64
	frame_dig 1 // lstMintRemaining: uint64
	<=

	// Invalid quantity
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:627
	// sendAssetTransfer({
	//       xferAsset: AssetID.fromUint64(this.lstTokenId.value),
	//       assetReceiver: this.txn.sender,
	//       sender: this.app.address,
	//       assetAmount: quantity,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/InjectedRewardsPoolConsensus.algo.ts:628
	// xferAsset: AssetID.fromUint64(this.lstTokenId.value)
	byte 0x6c7374546f6b656e4964 // "lstTokenId"
	app_global_get
	itxn_field XferAsset

	// contracts/InjectedRewardsPoolConsensus.algo.ts:629
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/InjectedRewardsPoolConsensus.algo.ts:630
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/InjectedRewardsPoolConsensus.algo.ts:631
	// assetAmount: quantity
	frame_dig -1 // quantity: uint64
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/InjectedRewardsPoolConsensus.algo.ts:633
	// staker.lstMinted = staker.lstMinted + quantity
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 88 // headOffset
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 88 8
	btoi
	frame_dig -1 // quantity: uint64
	+
	itob
	replace3
	frame_bury 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/InjectedRewardsPoolConsensus.algo.ts:634
	// this.setStaker(staker.account, staker)
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 0 32
	callsub setStaker
	retsub

// burnLST(axfer,uint64)void
*abi_route_burnLST:
	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// axferTxn: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==

	// argument 1 (axferTxn) for burnLST must be a axfer transaction
	assert

	// execute burnLST(axfer,uint64)void
	callsub burnLST
	int 1
	return

// burnLST(axferTxn: AssetTransferTxn, quantity: uint64): void
burnLST:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/InjectedRewardsPoolConsensus.algo.ts:641
	// verifyAssetTransferTxn(axferTxn, {
	//       assetAmount: quantity,
	//       assetReceiver: this.app.address,
	//       assetSender: this.txn.sender,
	//       xferAsset: AssetID.fromUint64(this.lstTokenId.value)
	//     })
	// verify assetAmount
	frame_dig -1 // axferTxn: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -2 // quantity: uint64
	==

	// transaction verification failed: {"txn":"axferTxn","field":"assetAmount","expected":"quantity"}
	assert

	// verify assetReceiver
	frame_dig -1 // axferTxn: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"axferTxn","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify assetSender
	frame_dig -1 // axferTxn: AssetTransferTxn
	gtxns AssetSender
	txn Sender
	==

	// transaction verification failed: {"txn":"axferTxn","field":"assetSender","expected":"this.txn.sender"}
	assert

	// verify xferAsset
	frame_dig -1 // axferTxn: AssetTransferTxn
	gtxns XferAsset
	byte 0x6c7374546f6b656e4964 // "lstTokenId"
	app_global_get
	==

	// transaction verification failed: {"txn":"axferTxn","field":"xferAsset","expected":"AssetID.fromUint64(this.lstTokenId.value)"}
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:648
	// lstAmount = axferTxn.assetAmount
	frame_dig -1 // axferTxn: AssetTransferTxn
	gtxns AssetAmount
	frame_bury 0 // lstAmount: uint64

	// contracts/InjectedRewardsPoolConsensus.algo.ts:649
	// stakeTokenDue = wideRatio([lstAmount, this.lstPrice.value], [this.stakeTokenPrice.value])
	frame_dig 0 // lstAmount: uint64
	byte 0x6c73745072696365 // "lstPrice"
	app_global_get
	mulw
	int 0
	byte 0x7374616b65546f6b656e5072696365 // "stakeTokenPrice"
	app_global_get
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 1 // stakeTokenDue: uint64

	// contracts/InjectedRewardsPoolConsensus.algo.ts:650
	// assert(stakeTokenDue > 0, 'Invalid quantity')
	frame_dig 1 // stakeTokenDue: uint64
	int 0
	>

	// Invalid quantity
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:651
	// assert(stakeTokenDue <= this.totalStaked.value, 'Invalid quantity')
	frame_dig 1 // stakeTokenDue: uint64
	byte 0x746f74616c5374616b6564 // "totalStaked"
	app_global_get
	<=

	// Invalid quantity
	assert

	// *if45_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:653
	// this.stakedAssetId.value === 0
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	app_global_get
	int 0
	==
	bz *if45_else

	// *if45_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:654
	// sendPayment({
	//         amount: stakeTokenDue,
	//         receiver: this.txn.sender,
	//         sender: this.app.address,
	//         fee: 1_000,
	//       })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/InjectedRewardsPoolConsensus.algo.ts:655
	// amount: stakeTokenDue
	frame_dig 1 // stakeTokenDue: uint64
	itxn_field Amount

	// contracts/InjectedRewardsPoolConsensus.algo.ts:656
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/InjectedRewardsPoolConsensus.algo.ts:657
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/InjectedRewardsPoolConsensus.algo.ts:658
	// fee: 1_000
	int 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if45_end

*if45_else:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:661
	// sendAssetTransfer({
	//         xferAsset: AssetID.fromUint64(this.stakedAssetId.value),
	//         assetReceiver: this.txn.sender,
	//         sender: this.app.address,
	//         assetAmount: stakeTokenDue,
	//         fee: 1_000,
	//       })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/InjectedRewardsPoolConsensus.algo.ts:662
	// xferAsset: AssetID.fromUint64(this.stakedAssetId.value)
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/InjectedRewardsPoolConsensus.algo.ts:663
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/InjectedRewardsPoolConsensus.algo.ts:664
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/InjectedRewardsPoolConsensus.algo.ts:665
	// assetAmount: stakeTokenDue
	frame_dig 1 // stakeTokenDue: uint64
	itxn_field AssetAmount

	// contracts/InjectedRewardsPoolConsensus.algo.ts:666
	// fee: 1_000
	int 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if45_end:
	retsub

// gas()void
*abi_route_gas:
	// execute gas()void
	callsub gas
	int 1
	return

// gas(): void
gas:
	proto 0 0
	retsub

*create_NoOp:
	method "createApplication(address,address)void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	method "initApplication(uint64,uint64,uint64,uint64,uint64)void"
	method "updateMinStakePeriod(uint64)void"
	method "updateAdminAddress(address)void"
	method "updateOracleAdminAddress(address)void"
	method "updateCommision(uint64)void"
	method "setPrices(uint64,uint64)void"
	method "getMBRForPoolCreation()(uint64)"
	method "initStorage(pay)void"
	method "injectRewards(axfer,uint64,uint64)void"
	method "injectAlgoRewards(pay,uint64)void"
	method "pickupAlgoRewards()void"
	method "stake(pay,uint64)void"
	method "accrueRewards()void"
	method "claimRewards()void"
	method "unstake(axfer,uint64)void"
	method "setFreeze(bool)void"
	method "goOnline(pay,byte[],byte[],byte[],uint64,uint64,uint64)void"
	method "goOffline()void"
	method "linkToNFD(uint64,string,uint64)void"
	method "addLST(axfer,uint64)void"
	method "mintLST(uint64)void"
	method "burnLST(axfer,uint64)void"
	method "gas()void"
	txna ApplicationArgs 0
	match *abi_route_initApplication *abi_route_updateMinStakePeriod *abi_route_updateAdminAddress *abi_route_updateOracleAdminAddress *abi_route_updateCommision *abi_route_setPrices *abi_route_getMBRForPoolCreation *abi_route_initStorage *abi_route_injectRewards *abi_route_injectAlgoRewards *abi_route_pickupAlgoRewards *abi_route_stake *abi_route_accrueRewards *abi_route_claimRewards *abi_route_unstake *abi_route_setFreeze *abi_route_goOnline *abi_route_goOffline *abi_route_linkToNFD *abi_route_addLST *abi_route_mintLST *abi_route_burnLST *abi_route_gas

	// this contract does not implement the given ABI method for call NoOp
	err

*call_DeleteApplication:
	method "deleteApplication()void"
	txna ApplicationArgs 0
	match *abi_route_deleteApplication

	// this contract does not implement the given ABI method for call DeleteApplication
	err