#pragma version 11
intcblock 1 0 4 1_000 32 6 300 10000 2 5 1000
bytecblock 0x61646d696e41646472657373 0x6c737442616c616e6365 0x746f74616c436f6e73656e73757352657761726473 0x746f74616c5374616b6564 0x636f6d6d6973696f6e416d6f756e74 0x63697263756c6174696e674c5354 0x 0x6c7374546f6b656e4964 0x6d6967726174696f6e41646d696e 0x0a8101 0x70616964436f6d6d6973696f6e 0x636f6d6d6973696f6e50657263656e74616765 0x747265617375727941646472657373 0x6d696e696d756d42616c616e6365 0x7374616b656441737365744964 0x6d61785374616b65

// This TEAL was generated by TEALScript v0.106.3
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 5 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *call_DeleteApplication *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication(address,address,address)void
*abi_route_createApplication:
	// migrationAdmin: address
	txna ApplicationArgs 3
	dup
	len
	intc 4 // 32
	==

	// argument 0 (migrationAdmin) for createApplication must be a address
	assert

	// treasuryAddress: address
	txna ApplicationArgs 2
	dup
	len
	intc 4 // 32
	==

	// argument 1 (treasuryAddress) for createApplication must be a address
	assert

	// adminAddress: address
	txna ApplicationArgs 1
	dup
	len
	intc 4 // 32
	==

	// argument 2 (adminAddress) for createApplication must be a address
	assert

	// execute createApplication(address,address,address)void
	callsub createApplication
	intc 0 // 1
	return

// createApplication(adminAddress: Address, treasuryAddress: Address, migrationAdmin: Address): void
createApplication:
	proto 3 0

	// contracts/InjectedRewardsPoolConsensus.algo.ts:65
	// this.adminAddress.value = adminAddress
	bytec 0 //  "adminAddress"
	frame_dig -1 // adminAddress: Address
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:66
	// this.treasuryAddress.value = treasuryAddress
	bytec 12 //  "treasuryAddress"
	frame_dig -2 // treasuryAddress: Address
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:67
	// this.migrationAdmin.value = migrationAdmin
	bytec 8 //  "migrationAdmin"
	frame_dig -3 // migrationAdmin: Address
	app_global_put
	retsub

// initApplication(uint64,uint64,pay)void
*abi_route_initApplication:
	// payTxn: pay
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 0 //  pay
	==

	// argument 0 (payTxn) for initApplication must be a pay transaction
	assert

	// commision: uint64
	txna ApplicationArgs 2
	btoi

	// lstTokenId: uint64
	txna ApplicationArgs 1
	btoi

	// execute initApplication(uint64,uint64,pay)void
	callsub initApplication
	intc 0 // 1
	return

// initApplication(lstTokenId: uint64, commision: uint64, payTxn: PayTxn): void
initApplication:
	proto 3 0

	// contracts/InjectedRewardsPoolConsensus.algo.ts:80
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can init application')
	txn Sender
	bytec 0 //  "adminAddress"
	app_global_get
	==

	// Only admin can init application
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:81
	// this.totalStaked.value = 0
	bytec 3 //  "totalStaked"
	intc 1 // 0
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:82
	// this.lstTokenId.value = lstTokenId
	bytec 7 //  "lstTokenId"
	frame_dig -1 // lstTokenId: uint64
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:83
	// this.lstBalance.value = 0
	bytec 1 //  "lstBalance"
	intc 1 // 0
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:84
	// this.circulatingLST.value = 0
	bytec 5 //  "circulatingLST"
	intc 1 // 0
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:85
	// this.minimumBalance.value = payTxn.amount
	bytec 13 //  "minimumBalance"
	frame_dig -3 // payTxn: PayTxn
	gtxns Amount
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:86
	// this.commisionPercentage.value = commision
	bytec 11 //  "commisionPercentage"
	frame_dig -2 // commision: uint64
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:87
	// this.totalConsensusRewards.value = 0
	bytec 2 //  "totalConsensusRewards"
	intc 1 // 0
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:88
	// this.commisionAmount.value = 0
	bytec 4 //  "commisionAmount"
	intc 1 // 0
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:89
	// this.maxStake.value = 69999999000000
	bytec 15 //  "maxStake"
	pushint 69999999000000
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:90
	// this.stakedAssetId.value = 0
	bytec 14 //  "stakedAssetId"
	intc 1 // 0
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:91
	// this.paidCommision.value = 0
	bytec 10 //  "paidCommision"
	intc 1 // 0
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:92
	// this.contractVersion.value = CONTRACT_VERSION
	pushbytes 0x636f6e747261637456657273696f6e // "contractVersion"
	pushint 1101
	app_global_put

	// *if0_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:94
	// this.lstTokenId.value !== 0
	bytec 7 //  "lstTokenId"
	app_global_get
	intc 1 // 0
	!=
	bz *if0_end

	// *if0_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:95
	// sendAssetTransfer({
	//         xferAsset: AssetID.fromUint64(this.lstTokenId.value),
	//         assetReceiver: this.app.address,
	//         assetAmount: 0,
	//       })
	itxn_begin
	intc 2 //  axfer
	itxn_field TypeEnum

	// contracts/InjectedRewardsPoolConsensus.algo.ts:96
	// xferAsset: AssetID.fromUint64(this.lstTokenId.value)
	bytec 7 //  "lstTokenId"
	app_global_get
	itxn_field XferAsset

	// contracts/InjectedRewardsPoolConsensus.algo.ts:97
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/InjectedRewardsPoolConsensus.algo.ts:98
	// assetAmount: 0
	intc 1 // 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if0_end:
	retsub

// updateAdminAddress(address)void
*abi_route_updateAdminAddress:
	// adminAddress: address
	txna ApplicationArgs 1
	dup
	len
	intc 4 // 32
	==

	// argument 0 (adminAddress) for updateAdminAddress must be a address
	assert

	// execute updateAdminAddress(address)void
	callsub updateAdminAddress
	intc 0 // 1
	return

// updateAdminAddress(adminAddress: Address): void
updateAdminAddress:
	proto 1 0

	// contracts/InjectedRewardsPoolConsensus.algo.ts:107
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can update admin address')
	txn Sender
	bytec 0 //  "adminAddress"
	app_global_get
	==

	// Only admin can update admin address
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:108
	// this.adminAddress.value = adminAddress
	bytec 0 //  "adminAddress"
	frame_dig -1 // adminAddress: Address
	app_global_put
	retsub

// updateMigrationAdmin(address)void
*abi_route_updateMigrationAdmin:
	// migrationAdmin: address
	txna ApplicationArgs 1
	dup
	len
	intc 4 // 32
	==

	// argument 0 (migrationAdmin) for updateMigrationAdmin must be a address
	assert

	// execute updateMigrationAdmin(address)void
	callsub updateMigrationAdmin
	intc 0 // 1
	return

// updateMigrationAdmin(migrationAdmin: Address): void
updateMigrationAdmin:
	proto 1 0

	// contracts/InjectedRewardsPoolConsensus.algo.ts:112
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can update migration admin address')
	txn Sender
	bytec 0 //  "adminAddress"
	app_global_get
	==

	// Only admin can update migration admin address
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:113
	// this.migrationAdmin.value = migrationAdmin
	bytec 8 //  "migrationAdmin"
	frame_dig -1 // migrationAdmin: Address
	app_global_put
	retsub

// updateMaxStake(uint64)void
*abi_route_updateMaxStake:
	// maxStake: uint64
	txna ApplicationArgs 1
	btoi

	// execute updateMaxStake(uint64)void
	callsub updateMaxStake
	intc 0 // 1
	return

// updateMaxStake(maxStake: uint64): void
updateMaxStake:
	proto 1 0

	// contracts/InjectedRewardsPoolConsensus.algo.ts:117
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can update max stake')
	txn Sender
	bytec 0 //  "adminAddress"
	app_global_get
	==

	// Only admin can update max stake
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:118
	// this.maxStake.value = maxStake
	bytec 15 //  "maxStake"
	frame_dig -1 // maxStake: uint64
	app_global_put
	retsub

// updateTreasuryAddress(address)void
*abi_route_updateTreasuryAddress:
	// treasuryAddress: address
	txna ApplicationArgs 1
	dup
	len
	intc 4 // 32
	==

	// argument 0 (treasuryAddress) for updateTreasuryAddress must be a address
	assert

	// execute updateTreasuryAddress(address)void
	callsub updateTreasuryAddress
	intc 0 // 1
	return

// updateTreasuryAddress(treasuryAddress: Address): void
updateTreasuryAddress:
	proto 1 0

	// contracts/InjectedRewardsPoolConsensus.algo.ts:122
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can update treasury address')
	txn Sender
	bytec 0 //  "adminAddress"
	app_global_get
	==

	// Only admin can update treasury address
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:123
	// this.treasuryAddress.value = treasuryAddress
	bytec 12 //  "treasuryAddress"
	frame_dig -1 // treasuryAddress: Address
	app_global_put
	retsub

// updateCommision(uint64)void
*abi_route_updateCommision:
	// commision: uint64
	txna ApplicationArgs 1
	btoi

	// execute updateCommision(uint64)void
	callsub updateCommision
	intc 0 // 1
	return

// updateCommision(commision: uint64): void
updateCommision:
	proto 1 0

	// contracts/InjectedRewardsPoolConsensus.algo.ts:127
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can update commision')
	txn Sender
	bytec 0 //  "adminAddress"
	app_global_get
	==

	// Only admin can update commision
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:128
	// this.commisionPercentage.value = commision
	bytec 11 //  "commisionPercentage"
	frame_dig -1 // commision: uint64
	app_global_put
	retsub

// updateCommisionAmount(uint64)void
*abi_route_updateCommisionAmount:
	// commisionAmount: uint64
	txna ApplicationArgs 1
	btoi

	// execute updateCommisionAmount(uint64)void
	callsub updateCommisionAmount
	intc 0 // 1
	return

// updateCommisionAmount(commisionAmount: uint64): void
updateCommisionAmount:
	proto 1 0

	// contracts/InjectedRewardsPoolConsensus.algo.ts:132
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can update commision amount')
	txn Sender
	bytec 0 //  "adminAddress"
	app_global_get
	==

	// Only admin can update commision amount
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:133
	// this.commisionAmount.value = commisionAmount
	bytec 4 //  "commisionAmount"
	frame_dig -1 // commisionAmount: uint64
	app_global_put
	retsub

// updateConsenusRewards(uint64)void
*abi_route_updateConsenusRewards:
	// totalConsensusRewards: uint64
	txna ApplicationArgs 1
	btoi

	// execute updateConsenusRewards(uint64)void
	callsub updateConsenusRewards
	intc 0 // 1
	return

// updateConsenusRewards(totalConsensusRewards: uint64): void
updateConsenusRewards:
	proto 1 0

	// contracts/InjectedRewardsPoolConsensus.algo.ts:137
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can update rewards')
	txn Sender
	bytec 0 //  "adminAddress"
	app_global_get
	==

	// Only admin can update rewards
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:138
	// this.totalConsensusRewards.value = totalConsensusRewards
	bytec 2 //  "totalConsensusRewards"
	frame_dig -1 // totalConsensusRewards: uint64
	app_global_put
	retsub

// updateMinimumBalance(uint64)void
*abi_route_updateMinimumBalance:
	// minimumBalance: uint64
	txna ApplicationArgs 1
	btoi

	// execute updateMinimumBalance(uint64)void
	callsub updateMinimumBalance
	intc 0 // 1
	return

// updateMinimumBalance(minimumBalance: uint64): void
updateMinimumBalance:
	proto 1 0

	// contracts/InjectedRewardsPoolConsensus.algo.ts:142
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can update minimum balance')
	txn Sender
	bytec 0 //  "adminAddress"
	app_global_get
	==

	// Only admin can update minimum balance
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:143
	// this.minimumBalance.value = minimumBalance
	bytec 13 //  "minimumBalance"
	frame_dig -1 // minimumBalance: uint64
	app_global_put
	retsub

// updatePaidCommision(uint64)void
*abi_route_updatePaidCommision:
	// paidCommision: uint64
	txna ApplicationArgs 1
	btoi

	// execute updatePaidCommision(uint64)void
	callsub updatePaidCommision
	intc 0 // 1
	return

// updatePaidCommision(paidCommision: uint64): void
updatePaidCommision:
	proto 1 0

	// contracts/InjectedRewardsPoolConsensus.algo.ts:147
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can update paid commision')
	txn Sender
	bytec 0 //  "adminAddress"
	app_global_get
	==

	// Only admin can update paid commision
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:148
	// this.paidCommision.value = paidCommision
	bytec 10 //  "paidCommision"
	frame_dig -1 // paidCommision: uint64
	app_global_put
	retsub

// optInToToken(pay,uint64)void
*abi_route_optInToToken:
	// tokenId: uint64
	txna ApplicationArgs 1
	btoi

	// payTxn: pay
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 0 //  pay
	==

	// argument 1 (payTxn) for optInToToken must be a pay transaction
	assert

	// execute optInToToken(pay,uint64)void
	callsub optInToToken
	intc 0 // 1
	return

// optInToToken(payTxn: PayTxn, tokenId: uint64): void
optInToToken:
	proto 2 0

	// contracts/InjectedRewardsPoolConsensus.algo.ts:152
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can opt in to token')
	txn Sender
	bytec 0 //  "adminAddress"
	app_global_get
	==

	// Only admin can opt in to token
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:154
	// verifyPayTxn(payTxn, {
	//       receiver: this.app.address,
	//       amount: 110000,
	//     })
	// verify receiver
	frame_dig -1 // payTxn: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payTxn","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // payTxn: PayTxn
	gtxns Amount
	pushint 110000
	==

	// transaction verification failed: {"txn":"payTxn","field":"amount","expected":"110000"}
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:159
	// sendAssetTransfer({
	//       xferAsset: AssetID.fromUint64(tokenId),
	//       assetReceiver: this.app.address,
	//       assetAmount: 0,
	//     })
	itxn_begin
	intc 2 //  axfer
	itxn_field TypeEnum

	// contracts/InjectedRewardsPoolConsensus.algo.ts:160
	// xferAsset: AssetID.fromUint64(tokenId)
	frame_dig -2 // tokenId: uint64
	itxn_field XferAsset

	// contracts/InjectedRewardsPoolConsensus.algo.ts:161
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/InjectedRewardsPoolConsensus.algo.ts:162
	// assetAmount: 0
	intc 1 // 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// payCommision(pay)void
*abi_route_payCommision:
	// payTxn: pay
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 0 //  pay
	==

	// argument 0 (payTxn) for payCommision must be a pay transaction
	assert

	// execute payCommision(pay)void
	callsub payCommision
	intc 0 // 1
	return

// payCommision(payTxn: PayTxn): void
payCommision:
	proto 1 0

	// contracts/InjectedRewardsPoolConsensus.algo.ts:167
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can pay commision')
	txn Sender
	bytec 0 //  "adminAddress"
	app_global_get
	==

	// Only admin can pay commision
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:168
	// verifyPayTxn(payTxn, {
	//       receiver: this.app.address,
	//       amount: 1000,
	//     })
	// verify receiver
	frame_dig -1 // payTxn: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payTxn","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // payTxn: PayTxn
	gtxns Amount
	intc 10 // 1000
	==

	// transaction verification failed: {"txn":"payTxn","field":"amount","expected":"1000"}
	assert

	// *if1_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:172
	// this.commisionAmount.value > 0
	bytec 4 //  "commisionAmount"
	app_global_get
	intc 1 // 0
	>
	bz *if1_end

	// *if1_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:173
	// sendPayment({
	//         amount: this.commisionAmount.value,
	//         receiver: this.treasuryAddress.value,
	//         sender: this.app.address,
	//         fee: 1_000,
	//       })
	itxn_begin
	intc 0 //  pay
	itxn_field TypeEnum

	// contracts/InjectedRewardsPoolConsensus.algo.ts:174
	// amount: this.commisionAmount.value
	bytec 4 //  "commisionAmount"
	app_global_get
	itxn_field Amount

	// contracts/InjectedRewardsPoolConsensus.algo.ts:175
	// receiver: this.treasuryAddress.value
	bytec 12 //  "treasuryAddress"
	app_global_get
	itxn_field Receiver

	// contracts/InjectedRewardsPoolConsensus.algo.ts:176
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/InjectedRewardsPoolConsensus.algo.ts:177
	// fee: 1_000
	intc 3 // 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/InjectedRewardsPoolConsensus.algo.ts:179
	// this.paidCommision.value = this.paidCommision.value + this.commisionAmount.value
	bytec 10 //  "paidCommision"
	dup
	app_global_get
	bytec 4 //  "commisionAmount"
	app_global_get
	+
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:180
	// this.commisionAmount.value = 0
	bytec 4 //  "commisionAmount"
	intc 1 // 0
	app_global_put

*if1_end:
	retsub

// getGoOnlineFee(): uint64
getGoOnlineFee:
	proto 0 1

	// contracts/InjectedRewardsPoolConsensus.algo.ts:186
	// return globals.payoutsGoOnlineFee;
	global PayoutsGoOnlineFee
	retsub

// goOnline(pay,byte[],byte[],byte[],uint64,uint64,uint64)void
*abi_route_goOnline:
	// voteKeyDilution: uint64
	txna ApplicationArgs 6
	btoi

	// voteLast: uint64
	txna ApplicationArgs 5
	btoi

	// voteFirst: uint64
	txna ApplicationArgs 4
	btoi

	// stateProofPK: byte[]
	txna ApplicationArgs 3
	extract 2 0

	// selectionPK: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// votePK: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// feePayment: pay
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 0 //  pay
	==

	// argument 6 (feePayment) for goOnline must be a pay transaction
	assert

	// execute goOnline(pay,byte[],byte[],byte[],uint64,uint64,uint64)void
	callsub goOnline
	intc 0 // 1
	return

// goOnline(feePayment: PayTxn, votePK: bytes, selectionPK: bytes, stateProofPK: bytes, voteFirst: uint64, voteLast: uint64, voteKeyDilution: uint64): void
goOnline:
	proto 7 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 6 // 0x

	// contracts/InjectedRewardsPoolConsensus.algo.ts:198
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can go online')
	txn Sender
	bytec 0 //  "adminAddress"
	app_global_get
	==

	// Only admin can go online
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:200
	// extraFee = this.getGoOnlineFee()
	callsub getGoOnlineFee
	frame_bury 0 // extraFee: uint64

	// contracts/InjectedRewardsPoolConsensus.algo.ts:201
	// verifyPayTxn(feePayment, {
	//       receiver: this.app.address,
	//       amount: extraFee,
	//     })
	// verify receiver
	frame_dig -1 // feePayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"feePayment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // feePayment: PayTxn
	gtxns Amount
	frame_dig 0 // extraFee: uint64
	==

	// transaction verification failed: {"txn":"feePayment","field":"amount","expected":"extraFee"}
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:205
	// sendOnlineKeyRegistration({
	//       votePK: votePK,
	//       selectionPK: selectionPK,
	//       stateProofPK: stateProofPK,
	//       voteFirst: voteFirst,
	//       voteLast: voteLast,
	//       voteKeyDilution: voteKeyDilution,
	//       fee: extraFee,
	//     })
	itxn_begin
	intc 8 //  keyreg
	itxn_field TypeEnum

	// contracts/InjectedRewardsPoolConsensus.algo.ts:206
	// votePK: votePK
	frame_dig -2 // votePK: bytes
	itxn_field VotePK

	// contracts/InjectedRewardsPoolConsensus.algo.ts:207
	// selectionPK: selectionPK
	frame_dig -3 // selectionPK: bytes
	itxn_field SelectionPK

	// contracts/InjectedRewardsPoolConsensus.algo.ts:208
	// stateProofPK: stateProofPK
	frame_dig -4 // stateProofPK: bytes
	itxn_field StateProofPK

	// contracts/InjectedRewardsPoolConsensus.algo.ts:209
	// voteFirst: voteFirst
	frame_dig -5 // voteFirst: uint64
	itxn_field VoteFirst

	// contracts/InjectedRewardsPoolConsensus.algo.ts:210
	// voteLast: voteLast
	frame_dig -6 // voteLast: uint64
	itxn_field VoteLast

	// contracts/InjectedRewardsPoolConsensus.algo.ts:211
	// voteKeyDilution: voteKeyDilution
	frame_dig -7 // voteKeyDilution: uint64
	itxn_field VoteKeyDilution

	// contracts/InjectedRewardsPoolConsensus.algo.ts:212
	// fee: extraFee
	frame_dig 0 // extraFee: uint64
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// goOffline()void
*abi_route_goOffline:
	// execute goOffline()void
	callsub goOffline
	intc 0 // 1
	return

// goOffline(): void
goOffline:
	proto 0 0

	// contracts/InjectedRewardsPoolConsensus.algo.ts:217
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can go offline')
	txn Sender
	bytec 0 //  "adminAddress"
	app_global_get
	==

	// Only admin can go offline
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:218
	// sendOfflineKeyRegistration({})
	itxn_begin
	intc 8 //  keyreg
	itxn_field TypeEnum

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// linkToNFD(uint64,string,uint64)void
*abi_route_linkToNFD:
	// nfdRegistryAppId: uint64
	txna ApplicationArgs 3
	btoi

	// nfdName: string
	txna ApplicationArgs 2
	extract 2 0

	// nfdAppId: uint64
	txna ApplicationArgs 1
	btoi

	// execute linkToNFD(uint64,string,uint64)void
	callsub linkToNFD
	intc 0 // 1
	return

// linkToNFD(nfdAppId: uint64, nfdName: string, nfdRegistryAppId: uint64): void
linkToNFD:
	proto 3 0

	// contracts/InjectedRewardsPoolConsensus.algo.ts:222
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can link to NFD')
	txn Sender
	bytec 0 //  "adminAddress"
	app_global_get
	==

	// Only admin can link to NFD
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:224
	// sendAppCall({
	//       applicationID: AppID.fromUint64(nfdRegistryAppId),
	//       applicationArgs: ['verify_nfd_addr', nfdName, itob(nfdAppId), rawBytes(this.app.address)],
	//       applications: [AppID.fromUint64(nfdAppId)],
	//     })
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum

	// contracts/InjectedRewardsPoolConsensus.algo.ts:225
	// applicationID: AppID.fromUint64(nfdRegistryAppId)
	frame_dig -3 // nfdRegistryAppId: uint64
	itxn_field ApplicationID

	// contracts/InjectedRewardsPoolConsensus.algo.ts:226
	// applicationArgs: ['verify_nfd_addr', nfdName, itob(nfdAppId), rawBytes(this.app.address)]
	pushbytes 0x7665726966795f6e66645f61646472 // "verify_nfd_addr"
	itxn_field ApplicationArgs
	frame_dig -2 // nfdName: string
	itxn_field ApplicationArgs
	frame_dig -1 // nfdAppId: uint64
	itob
	itxn_field ApplicationArgs
	global CurrentApplicationAddress
	itxn_field ApplicationArgs

	// contracts/InjectedRewardsPoolConsensus.algo.ts:227
	// applications: [AppID.fromUint64(nfdAppId)]
	frame_dig -1 // nfdAppId: uint64
	itxn_field Applications

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// addLST(axfer,uint64)void
*abi_route_addLST:
	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// axferTxn: axfer
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 2 //  axfer
	==

	// argument 1 (axferTxn) for addLST must be a axfer transaction
	assert

	// execute addLST(axfer,uint64)void
	callsub addLST
	intc 0 // 1
	return

// addLST(axferTxn: AssetTransferTxn, quantity: uint64): void
addLST:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 6 // 0x

	// contracts/InjectedRewardsPoolConsensus.algo.ts:232
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can send LST')
	txn Sender
	bytec 0 //  "adminAddress"
	app_global_get
	==

	// Only admin can send LST
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:233
	// lstTokenId = this.lstTokenId.value
	bytec 7 //  "lstTokenId"
	app_global_get
	frame_bury 0 // lstTokenId: uint64

	// contracts/InjectedRewardsPoolConsensus.algo.ts:235
	// verifyAssetTransferTxn(axferTxn, {
	//       assetAmount: quantity,
	//       assetReceiver: this.app.address,
	//       sender: this.txn.sender,
	//       xferAsset: AssetID.fromUint64(lstTokenId),
	//     })
	// verify assetAmount
	frame_dig -1 // axferTxn: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -2 // quantity: uint64
	==

	// transaction verification failed: {"txn":"axferTxn","field":"assetAmount","expected":"quantity"}
	assert

	// verify assetReceiver
	frame_dig -1 // axferTxn: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"axferTxn","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify sender
	frame_dig -1 // axferTxn: AssetTransferTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"axferTxn","field":"sender","expected":"this.txn.sender"}
	assert

	// verify xferAsset
	frame_dig -1 // axferTxn: AssetTransferTxn
	gtxns XferAsset
	frame_dig 0 // lstTokenId: uint64
	==

	// transaction verification failed: {"txn":"axferTxn","field":"xferAsset","expected":"AssetID.fromUint64(lstTokenId)"}
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:241
	// this.lstBalance.value = this.lstBalance.value + quantity
	bytec 1 //  "lstBalance"
	dup
	app_global_get
	frame_dig -2 // quantity: uint64
	+
	app_global_put
	retsub

// removeLST(uint64)void
*abi_route_removeLST:
	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// execute removeLST(uint64)void
	callsub removeLST
	intc 0 // 1
	return

// removeLST(quantity: uint64): void
removeLST:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 6 // 0x

	// contracts/InjectedRewardsPoolConsensus.algo.ts:245
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can remove LST')
	txn Sender
	bytec 0 //  "adminAddress"
	app_global_get
	==

	// Only admin can remove LST
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:246
	// assert(this.lstBalance.value >= quantity, 'Invalid quantity')
	bytec 1 //  "lstBalance"
	app_global_get
	frame_dig -1 // quantity: uint64
	>=

	// Invalid quantity
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:247
	// amountToRemove = quantity
	frame_dig -1 // quantity: uint64
	frame_bury 0 // amountToRemove: uint64

	// *if2_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:248
	// amountToRemove === 0
	frame_dig 0 // amountToRemove: uint64
	intc 1 // 0
	==
	bz *if2_end

	// *if2_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:249
	// amountToRemove = this.lstBalance.value
	bytec 1 //  "lstBalance"
	app_global_get
	frame_bury 0 // amountToRemove: uint64

*if2_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:251
	// sendAssetTransfer({
	//       assetAmount: amountToRemove,
	//       assetReceiver: this.adminAddress.value,
	//       sender: this.app.address,
	//       xferAsset: AssetID.fromUint64(this.lstTokenId.value),
	//     })
	itxn_begin
	intc 2 //  axfer
	itxn_field TypeEnum

	// contracts/InjectedRewardsPoolConsensus.algo.ts:252
	// assetAmount: amountToRemove
	frame_dig 0 // amountToRemove: uint64
	itxn_field AssetAmount

	// contracts/InjectedRewardsPoolConsensus.algo.ts:253
	// assetReceiver: this.adminAddress.value
	bytec 0 //  "adminAddress"
	app_global_get
	itxn_field AssetReceiver

	// contracts/InjectedRewardsPoolConsensus.algo.ts:254
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/InjectedRewardsPoolConsensus.algo.ts:255
	// xferAsset: AssetID.fromUint64(this.lstTokenId.value)
	bytec 7 //  "lstTokenId"
	app_global_get
	itxn_field XferAsset

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/InjectedRewardsPoolConsensus.algo.ts:257
	// this.lstBalance.value = this.lstBalance.value - amountToRemove
	bytec 1 //  "lstBalance"
	dup
	app_global_get
	frame_dig 0 // amountToRemove: uint64
	-
	app_global_put
	retsub

// pickupAlgoRewards()void
*abi_route_pickupAlgoRewards:
	// execute pickupAlgoRewards()void
	callsub pickupAlgoRewards
	intc 0 // 1
	return

// pickupAlgoRewards(): void
pickupAlgoRewards:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 6 // 0x
	dup

	// contracts/InjectedRewardsPoolConsensus.algo.ts:261
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can pickup rewards')
	txn Sender
	bytec 0 //  "adminAddress"
	app_global_get
	==

	// Only admin can pickup rewards
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:264
	// amount =
	//       this.app.address.balance -
	//       this.minimumBalance.value -
	//       this.totalConsensusRewards.value -
	//       this.totalStaked.value -
	//       this.commisionAmount.value
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	bytec 13 //  "minimumBalance"
	app_global_get
	-
	bytec 2 //  "totalConsensusRewards"
	app_global_get
	-
	bytec 3 //  "totalStaked"
	app_global_get
	-
	bytec 4 //  "commisionAmount"
	app_global_get
	-
	frame_bury 0 // amount: uint64

	// *if3_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:271
	// amount > MINIMUM_ALGO_REWARD
	frame_dig 0 // amount: uint64
	pushint 1000000
	>
	bz *if3_end

	// *if3_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:272
	// newCommisionPayment = (amount / 100) * this.commisionPercentage.value
	frame_dig 0 // amount: uint64
	pushint 100
	/
	bytec 11 //  "commisionPercentage"
	app_global_get
	*
	frame_bury 1 // newCommisionPayment: uint64

	// contracts/InjectedRewardsPoolConsensus.algo.ts:273
	// this.commisionAmount.value = this.commisionAmount.value + newCommisionPayment
	bytec 4 //  "commisionAmount"
	dup
	app_global_get
	frame_dig 1 // newCommisionPayment: uint64
	+
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:274
	// amount = amount - newCommisionPayment
	frame_dig 0 // amount: uint64
	frame_dig 1 // newCommisionPayment: uint64
	-
	frame_bury 0 // amount: uint64

	// contracts/InjectedRewardsPoolConsensus.algo.ts:275
	// this.totalConsensusRewards.value = this.totalConsensusRewards.value + amount
	bytec 2 //  "totalConsensusRewards"
	dup
	app_global_get
	frame_dig 0 // amount: uint64
	+
	app_global_put

*if3_end:
	retsub

// mintLST(stake: uint64, mintQuantity: uint64, payTxn: PayTxn, userAddress: Address): void
mintLST:
	proto 4 0

	// *if4_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:280
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 6 // 300
	<
	bz *if4_end

	// *if4_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:281
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 1 // 0
	itxn_field Fee
	bytec 9 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 9 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if4_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:284
	// verifyPayTxn(payTxn, {
	//       receiver: this.app.address,
	//       amount: minPayment + stake,
	//     })
	// verify receiver
	frame_dig -3 // payTxn: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payTxn","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -3 // payTxn: PayTxn
	gtxns Amount
	intc 10 // 1000
	frame_dig -1 // stake: uint64
	+
	==

	// transaction verification failed: {"txn":"payTxn","field":"amount","expected":"minPayment + stake"}
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:289
	// sendAssetTransfer({
	//       xferAsset: AssetID.fromUint64(this.lstTokenId.value),
	//       assetReceiver: userAddress,
	//       sender: this.app.address,
	//       assetAmount: mintQuantity,
	//       fee: 1_000,
	//     })
	itxn_begin
	intc 2 //  axfer
	itxn_field TypeEnum

	// contracts/InjectedRewardsPoolConsensus.algo.ts:290
	// xferAsset: AssetID.fromUint64(this.lstTokenId.value)
	bytec 7 //  "lstTokenId"
	app_global_get
	itxn_field XferAsset

	// contracts/InjectedRewardsPoolConsensus.algo.ts:291
	// assetReceiver: userAddress
	frame_dig -4 // userAddress: Address
	itxn_field AssetReceiver

	// contracts/InjectedRewardsPoolConsensus.algo.ts:292
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/InjectedRewardsPoolConsensus.algo.ts:293
	// assetAmount: mintQuantity
	frame_dig -2 // mintQuantity: uint64
	itxn_field AssetAmount

	// contracts/InjectedRewardsPoolConsensus.algo.ts:294
	// fee: 1_000
	intc 3 // 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// *if5_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:296
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 6 // 300
	<
	bz *if5_end

	// *if5_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:297
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 1 // 0
	itxn_field Fee
	bytec 9 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 9 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if5_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:300
	// this.lstBalance.value = this.lstBalance.value - mintQuantity
	bytec 1 //  "lstBalance"
	dup
	app_global_get
	frame_dig -2 // mintQuantity: uint64
	-
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:301
	// this.circulatingLST.value = this.circulatingLST.value + mintQuantity
	bytec 5 //  "circulatingLST"
	dup
	app_global_get
	frame_dig -2 // mintQuantity: uint64
	+
	app_global_put

	// *if6_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:302
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 6 // 300
	<
	bz *if6_end

	// *if6_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:303
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 1 // 0
	itxn_field Fee
	bytec 9 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 9 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if6_end:
	retsub

// deleteApplication()void
*abi_route_deleteApplication:
	// execute deleteApplication()void
	callsub deleteApplication
	intc 0 // 1
	return

// deleteApplication(): void
deleteApplication:
	proto 0 0

	// contracts/InjectedRewardsPoolConsensus.algo.ts:308
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can delete application')
	txn Sender
	bytec 0 //  "adminAddress"
	app_global_get
	==

	// Only admin can delete application
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:309
	// sendAssetTransfer({
	//       assetCloseTo: this.adminAddress.value,
	//       assetReceiver: this.adminAddress.value,
	//       sender: this.app.address,
	//       xferAsset: AssetID.fromUint64(this.lstTokenId.value),
	//       assetAmount: this.lstBalance.value,
	//     })
	itxn_begin
	intc 2 //  axfer
	itxn_field TypeEnum

	// contracts/InjectedRewardsPoolConsensus.algo.ts:310
	// assetCloseTo: this.adminAddress.value
	bytec 0 //  "adminAddress"
	app_global_get
	itxn_field AssetCloseTo

	// contracts/InjectedRewardsPoolConsensus.algo.ts:311
	// assetReceiver: this.adminAddress.value
	bytec 0 //  "adminAddress"
	app_global_get
	itxn_field AssetReceiver

	// contracts/InjectedRewardsPoolConsensus.algo.ts:312
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/InjectedRewardsPoolConsensus.algo.ts:313
	// xferAsset: AssetID.fromUint64(this.lstTokenId.value)
	bytec 7 //  "lstTokenId"
	app_global_get
	itxn_field XferAsset

	// contracts/InjectedRewardsPoolConsensus.algo.ts:314
	// assetAmount: this.lstBalance.value
	bytec 1 //  "lstBalance"
	app_global_get
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// stake(pay,uint64)void
*abi_route_stake:
	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// payTxn: pay
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 0 //  pay
	==

	// argument 1 (payTxn) for stake must be a pay transaction
	assert

	// execute stake(pay,uint64)void
	callsub stake
	intc 0 // 1
	return

// stake(payTxn: PayTxn, quantity: uint64): void
stake:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 6 // 0x
	dupn 2

	// contracts/InjectedRewardsPoolConsensus.algo.ts:324
	// assert(quantity > 0, 'Invalid quantity')
	frame_dig -2 // quantity: uint64
	intc 1 // 0
	>

	// Invalid quantity
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:325
	// assert(this.totalStaked.value + quantity <= this.maxStake.value, 'Max stake reached')
	bytec 3 //  "totalStaked"
	app_global_get
	frame_dig -2 // quantity: uint64
	+
	bytec 15 //  "maxStake"
	app_global_get
	<=

	// Max stake reached
	assert

	// *if7_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:326
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 6 // 300
	<
	bz *if7_end

	// *if7_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:327
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 1 // 0
	itxn_field Fee
	bytec 9 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 9 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if7_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:330
	// verifyPayTxn(payTxn, {
	//       sender: this.txn.sender,
	//       amount: quantity + 1000,
	//       receiver: this.app.address,
	//     })
	// verify sender
	frame_dig -1 // payTxn: PayTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"payTxn","field":"sender","expected":"this.txn.sender"}
	assert

	// verify amount
	frame_dig -1 // payTxn: PayTxn
	gtxns Amount
	frame_dig -2 // quantity: uint64
	intc 10 // 1000
	+
	==

	// transaction verification failed: {"txn":"payTxn","field":"amount","expected":"quantity + 1000"}
	assert

	// verify receiver
	frame_dig -1 // payTxn: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payTxn","field":"receiver","expected":"this.app.address"}
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:336
	// lstRatio = 0
	intc 1 // 0
	frame_bury 0 // lstRatio: uint64

	// contracts/InjectedRewardsPoolConsensus.algo.ts:337
	// lstDue = 0
	intc 1 // 0
	frame_bury 1 // lstDue: uint64

	// contracts/InjectedRewardsPoolConsensus.algo.ts:338
	// nodeAlgo = this.totalStaked.value + this.totalConsensusRewards.value
	bytec 3 //  "totalStaked"
	app_global_get
	bytec 2 //  "totalConsensusRewards"
	app_global_get
	+
	frame_bury 2 // nodeAlgo: uint64

	// *if8_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:339
	// nodeAlgo === 0
	frame_dig 2 // nodeAlgo: uint64
	intc 1 // 0
	==
	bz *if8_else

	// *if8_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:340
	// lstDue = quantity
	frame_dig -2 // quantity: uint64
	frame_bury 1 // lstDue: uint64
	b *if8_end

*if8_else:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:342
	// lstRatio = wideRatio([this.circulatingLST.value, 10000], [nodeAlgo])
	bytec 5 //  "circulatingLST"
	app_global_get
	intc 7 // 10000
	mulw
	intc 1 // 0
	frame_dig 2 // nodeAlgo: uint64
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 0 // lstRatio: uint64

	// contracts/InjectedRewardsPoolConsensus.algo.ts:343
	// lstDue = wideRatio([lstRatio, quantity], [10000])
	frame_dig 0 // lstRatio: uint64
	frame_dig -2 // quantity: uint64
	mulw
	intc 1 // 0
	intc 7 // 10000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 1 // lstDue: uint64

*if8_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:345
	// this.mintLST(quantity, lstDue, payTxn, this.txn.sender)
	txn Sender
	frame_dig -1 // payTxn: PayTxn
	frame_dig 1 // lstDue: uint64
	frame_dig -2 // quantity: uint64
	callsub mintLST

	// contracts/InjectedRewardsPoolConsensus.algo.ts:347
	// this.totalStaked.value = this.totalStaked.value + quantity
	bytec 3 //  "totalStaked"
	dup
	app_global_get
	frame_dig -2 // quantity: uint64
	+
	app_global_put
	retsub

// burnLST(axfer,pay,uint64,address)void
*abi_route_burnLST:
	// userAddress: address
	txna ApplicationArgs 2
	dup
	len
	intc 4 // 32
	==

	// argument 0 (userAddress) for burnLST must be a address
	assert

	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// payTxn: pay
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 0 //  pay
	==

	// argument 2 (payTxn) for burnLST must be a pay transaction
	assert

	// axferTxn: axfer
	txn GroupIndex
	intc 8 // 2
	-
	dup
	gtxns TypeEnum
	intc 2 //  axfer
	==

	// argument 3 (axferTxn) for burnLST must be a axfer transaction
	assert

	// execute burnLST(axfer,pay,uint64,address)void
	callsub burnLST
	intc 0 // 1
	return

// burnLST(axferTxn: AssetTransferTxn, payTxn: PayTxn, quantity: uint64, userAddress: Address): void
burnLST:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 6 // 0x
	dupn 2

	// contracts/InjectedRewardsPoolConsensus.algo.ts:354
	// verifyAssetTransferTxn(axferTxn, {
	//       assetAmount: quantity,
	//       assetReceiver: this.app.address,
	//       sender: userAddress,
	//       xferAsset: AssetID.fromUint64(this.lstTokenId.value),
	//     })
	// verify assetAmount
	frame_dig -1 // axferTxn: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -3 // quantity: uint64
	==

	// transaction verification failed: {"txn":"axferTxn","field":"assetAmount","expected":"quantity"}
	assert

	// verify assetReceiver
	frame_dig -1 // axferTxn: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"axferTxn","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify sender
	frame_dig -1 // axferTxn: AssetTransferTxn
	gtxns Sender
	frame_dig -4 // userAddress: Address
	==

	// transaction verification failed: {"txn":"axferTxn","field":"sender","expected":"userAddress"}
	assert

	// verify xferAsset
	frame_dig -1 // axferTxn: AssetTransferTxn
	gtxns XferAsset
	bytec 7 //  "lstTokenId"
	app_global_get
	==

	// transaction verification failed: {"txn":"axferTxn","field":"xferAsset","expected":"AssetID.fromUint64(this.lstTokenId.value)"}
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:360
	// verifyPayTxn(payTxn, {
	//       receiver: this.app.address,
	//       amount: 1_000,
	//     })
	// verify receiver
	frame_dig -2 // payTxn: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payTxn","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -2 // payTxn: PayTxn
	gtxns Amount
	intc 3 // 1_000
	==

	// transaction verification failed: {"txn":"payTxn","field":"amount","expected":"1_000"}
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:365
	// assert(this.circulatingLST.value >= quantity, 'Invalid quantity')
	bytec 5 //  "circulatingLST"
	app_global_get
	frame_dig -3 // quantity: uint64
	>=

	// Invalid quantity
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:367
	// nodeAlgo = this.totalStaked.value + this.totalConsensusRewards.value
	bytec 3 //  "totalStaked"
	app_global_get
	bytec 2 //  "totalConsensusRewards"
	app_global_get
	+
	frame_bury 0 // nodeAlgo: uint64

	// contracts/InjectedRewardsPoolConsensus.algo.ts:368
	// lstRatio = wideRatio([nodeAlgo, 10000], [this.circulatingLST.value])
	frame_dig 0 // nodeAlgo: uint64
	intc 7 // 10000
	mulw
	intc 1 // 0
	bytec 5 //  "circulatingLST"
	app_global_get
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 1 // lstRatio: uint64

	// contracts/InjectedRewardsPoolConsensus.algo.ts:369
	// stakeTokenDue = wideRatio([lstRatio, quantity], [10000])
	frame_dig 1 // lstRatio: uint64
	frame_dig -3 // quantity: uint64
	mulw
	intc 1 // 0
	intc 7 // 10000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 2 // stakeTokenDue: uint64

	// *if9_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:371
	// stakeTokenDue < this.app.address.balance
	frame_dig 2 // stakeTokenDue: uint64
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	<
	bz *if9_end

	// *if9_consequent
	// *if10_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:372
	// this.stakedAssetId.value === 0
	bytec 14 //  "stakedAssetId"
	app_global_get
	intc 1 // 0
	==
	bz *if10_else

	// *if10_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:373
	// sendPayment({
	//           amount: stakeTokenDue,
	//           receiver: userAddress,
	//           sender: this.app.address,
	//           fee: 1_000,
	//         })
	itxn_begin
	intc 0 //  pay
	itxn_field TypeEnum

	// contracts/InjectedRewardsPoolConsensus.algo.ts:374
	// amount: stakeTokenDue
	frame_dig 2 // stakeTokenDue: uint64
	itxn_field Amount

	// contracts/InjectedRewardsPoolConsensus.algo.ts:375
	// receiver: userAddress
	frame_dig -4 // userAddress: Address
	itxn_field Receiver

	// contracts/InjectedRewardsPoolConsensus.algo.ts:376
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/InjectedRewardsPoolConsensus.algo.ts:377
	// fee: 1_000
	intc 3 // 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if10_end

*if10_else:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:380
	// sendAssetTransfer({
	//           xferAsset: AssetID.fromUint64(this.stakedAssetId.value),
	//           assetReceiver: userAddress,
	//           sender: this.app.address,
	//           assetAmount: stakeTokenDue,
	//           fee: 1_000,
	//         })
	itxn_begin
	intc 2 //  axfer
	itxn_field TypeEnum

	// contracts/InjectedRewardsPoolConsensus.algo.ts:381
	// xferAsset: AssetID.fromUint64(this.stakedAssetId.value)
	bytec 14 //  "stakedAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/InjectedRewardsPoolConsensus.algo.ts:382
	// assetReceiver: userAddress
	frame_dig -4 // userAddress: Address
	itxn_field AssetReceiver

	// contracts/InjectedRewardsPoolConsensus.algo.ts:383
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/InjectedRewardsPoolConsensus.algo.ts:384
	// assetAmount: stakeTokenDue
	frame_dig 2 // stakeTokenDue: uint64
	itxn_field AssetAmount

	// contracts/InjectedRewardsPoolConsensus.algo.ts:385
	// fee: 1_000
	intc 3 // 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if10_end:

*if9_end:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:390
	// this.lstBalance.value = this.lstBalance.value + quantity
	bytec 1 //  "lstBalance"
	dup
	app_global_get
	frame_dig -3 // quantity: uint64
	+
	app_global_put

	// *if11_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:392
	// this.circulatingLST.value < quantity
	bytec 5 //  "circulatingLST"
	app_global_get
	frame_dig -3 // quantity: uint64
	<
	bz *if11_else

	// *if11_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:393
	// this.circulatingLST.value = 0
	bytec 5 //  "circulatingLST"
	intc 1 // 0
	app_global_put
	b *if11_end

*if11_else:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:395
	// this.circulatingLST.value = this.circulatingLST.value - quantity
	bytec 5 //  "circulatingLST"
	dup
	app_global_get
	frame_dig -3 // quantity: uint64
	-
	app_global_put

*if11_end:
	// *if12_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:398
	// this.totalStaked.value < stakeTokenDue
	bytec 3 //  "totalStaked"
	app_global_get
	frame_dig 2 // stakeTokenDue: uint64
	<
	bz *if12_else

	// *if12_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:399
	// this.totalStaked.value = 0
	bytec 3 //  "totalStaked"
	intc 1 // 0
	app_global_put
	b *if12_end

*if12_else:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:401
	// this.totalStaked.value = this.totalStaked.value - stakeTokenDue
	bytec 3 //  "totalStaked"
	dup
	app_global_get
	frame_dig 2 // stakeTokenDue: uint64
	-
	app_global_put

*if12_end:
	// *if13_condition
	// contracts/InjectedRewardsPoolConsensus.algo.ts:403
	// this.totalConsensusRewards.value < stakeTokenDue - quantity
	bytec 2 //  "totalConsensusRewards"
	app_global_get
	frame_dig 2 // stakeTokenDue: uint64
	frame_dig -3 // quantity: uint64
	-
	<
	bz *if13_else

	// *if13_consequent
	// contracts/InjectedRewardsPoolConsensus.algo.ts:404
	// this.totalConsensusRewards.value = 0
	bytec 2 //  "totalConsensusRewards"
	intc 1 // 0
	app_global_put
	b *if13_end

*if13_else:
	// contracts/InjectedRewardsPoolConsensus.algo.ts:406
	// this.totalConsensusRewards.value = this.totalConsensusRewards.value - (stakeTokenDue - quantity)
	bytec 2 //  "totalConsensusRewards"
	dup
	app_global_get
	frame_dig 2 // stakeTokenDue: uint64
	frame_dig -3 // quantity: uint64
	-
	-
	app_global_put

*if13_end:
	retsub

// acceptMigration(pay,axfer,uint64,uint64,uint64,uint64,uint64)void
*abi_route_acceptMigration:
	// commisionAmount: uint64
	txna ApplicationArgs 5
	btoi

	// totalConsensusRewards: uint64
	txna ApplicationArgs 4
	btoi

	// circulatingLST: uint64
	txna ApplicationArgs 3
	btoi

	// totalStaked: uint64
	txna ApplicationArgs 2
	btoi

	// lstBalance: uint64
	txna ApplicationArgs 1
	btoi

	// lstTransfer: axfer
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 2 //  axfer
	==

	// argument 5 (lstTransfer) for acceptMigration must be a axfer transaction
	assert

	// algoTransfer: pay
	txn GroupIndex
	intc 8 // 2
	-
	dup
	gtxns TypeEnum
	intc 0 //  pay
	==

	// argument 6 (algoTransfer) for acceptMigration must be a pay transaction
	assert

	// execute acceptMigration(pay,axfer,uint64,uint64,uint64,uint64,uint64)void
	callsub acceptMigration
	intc 0 // 1
	return

// acceptMigration(algoTransfer: PayTxn, lstTransfer: AssetTransferTxn, lstBalance: uint64, totalStaked: uint64, circulatingLST: uint64, totalConsensusRewards: uint64, commisionAmount: uint64): void
acceptMigration:
	proto 7 0

	// contracts/InjectedRewardsPoolConsensus.algo.ts:421
	// verifyPayTxn(algoTransfer, {
	//       receiver: this.app.address,
	//       sender: this.migrationAdmin.value,
	//     })
	// verify receiver
	frame_dig -1 // algoTransfer: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"algoTransfer","field":"receiver","expected":"this.app.address"}
	assert

	// verify sender
	frame_dig -1 // algoTransfer: PayTxn
	gtxns Sender
	bytec 8 //  "migrationAdmin"
	app_global_get
	==

	// transaction verification failed: {"txn":"algoTransfer","field":"sender","expected":"this.migrationAdmin.value"}
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:425
	// verifyAssetTransferTxn(lstTransfer, {
	//       assetReceiver: this.app.address,
	//       sender: this.migrationAdmin.value,
	//     })
	// verify assetReceiver
	frame_dig -2 // lstTransfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"lstTransfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify sender
	frame_dig -2 // lstTransfer: AssetTransferTxn
	gtxns Sender
	bytec 8 //  "migrationAdmin"
	app_global_get
	==

	// transaction verification failed: {"txn":"lstTransfer","field":"sender","expected":"this.migrationAdmin.value"}
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:429
	// this.lstBalance.value = lstBalance
	bytec 1 //  "lstBalance"
	frame_dig -3 // lstBalance: uint64
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:430
	// this.totalStaked.value = totalStaked
	bytec 3 //  "totalStaked"
	frame_dig -4 // totalStaked: uint64
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:431
	// this.circulatingLST.value = circulatingLST
	bytec 5 //  "circulatingLST"
	frame_dig -5 // circulatingLST: uint64
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:432
	// this.totalConsensusRewards.value = totalConsensusRewards
	bytec 2 //  "totalConsensusRewards"
	frame_dig -6 // totalConsensusRewards: uint64
	app_global_put

	// contracts/InjectedRewardsPoolConsensus.algo.ts:433
	// this.commisionAmount.value = commisionAmount
	bytec 4 //  "commisionAmount"
	frame_dig -7 // commisionAmount: uint64
	app_global_put
	retsub

// migrateContract(pay)(uint64,uint64,uint64,uint64,uint64)
*abi_route_migrateContract:
	// The ABI return prefix
	pushbytes 0x151f7c75

	// mbrTxn: pay
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 0 //  pay
	==

	// argument 0 (mbrTxn) for migrateContract must be a pay transaction
	assert

	// execute migrateContract(pay)(uint64,uint64,uint64,uint64,uint64)
	callsub migrateContract
	concat
	log
	intc 0 // 1
	return

// migrateContract(mbrTxn: PayTxn): MigrationParams
migrateContract:
	proto 1 1

	// contracts/InjectedRewardsPoolConsensus.algo.ts:438
	// assert(this.txn.sender === this.migrationAdmin.value, 'Only admin can migrate contract')
	txn Sender
	bytec 8 //  "migrationAdmin"
	app_global_get
	==

	// Only admin can migrate contract
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:440
	// this.goOffline()
	callsub goOffline

	// contracts/InjectedRewardsPoolConsensus.algo.ts:442
	// verifyPayTxn(mbrTxn, {
	//       sender: this.migrationAdmin.value,
	//       amount: 1_000_000,
	//     })
	// verify sender
	frame_dig -1 // mbrTxn: PayTxn
	gtxns Sender
	bytec 8 //  "migrationAdmin"
	app_global_get
	==

	// transaction verification failed: {"txn":"mbrTxn","field":"sender","expected":"this.migrationAdmin.value"}
	assert

	// verify amount
	frame_dig -1 // mbrTxn: PayTxn
	gtxns Amount
	pushint 1_000_000
	==

	// transaction verification failed: {"txn":"mbrTxn","field":"amount","expected":"1_000_000"}
	assert

	// contracts/InjectedRewardsPoolConsensus.algo.ts:447
	// sendPayment({
	//       amount: this.totalStaked.value + this.totalConsensusRewards.value + this.commisionAmount.value,
	//       receiver: this.migrationAdmin.value,
	//       sender: this.app.address,
	//       fee: 1_000,
	//     })
	itxn_begin
	intc 0 //  pay
	itxn_field TypeEnum

	// contracts/InjectedRewardsPoolConsensus.algo.ts:448
	// amount: this.totalStaked.value + this.totalConsensusRewards.value + this.commisionAmount.value
	bytec 3 //  "totalStaked"
	app_global_get
	bytec 2 //  "totalConsensusRewards"
	app_global_get
	+
	bytec 4 //  "commisionAmount"
	app_global_get
	+
	itxn_field Amount

	// contracts/InjectedRewardsPoolConsensus.algo.ts:449
	// receiver: this.migrationAdmin.value
	bytec 8 //  "migrationAdmin"
	app_global_get
	itxn_field Receiver

	// contracts/InjectedRewardsPoolConsensus.algo.ts:450
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/InjectedRewardsPoolConsensus.algo.ts:451
	// fee: 1_000
	intc 3 // 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/InjectedRewardsPoolConsensus.algo.ts:453
	// sendAssetTransfer({
	//       xferAsset: AssetID.fromUint64(this.lstTokenId.value),
	//       assetReceiver: this.migrationAdmin.value,
	//       sender: this.app.address,
	//       assetAmount: this.lstBalance.value,
	//       fee: 1_000,
	//     })
	itxn_begin
	intc 2 //  axfer
	itxn_field TypeEnum

	// contracts/InjectedRewardsPoolConsensus.algo.ts:454
	// xferAsset: AssetID.fromUint64(this.lstTokenId.value)
	bytec 7 //  "lstTokenId"
	app_global_get
	itxn_field XferAsset

	// contracts/InjectedRewardsPoolConsensus.algo.ts:455
	// assetReceiver: this.migrationAdmin.value
	bytec 8 //  "migrationAdmin"
	app_global_get
	itxn_field AssetReceiver

	// contracts/InjectedRewardsPoolConsensus.algo.ts:456
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/InjectedRewardsPoolConsensus.algo.ts:457
	// assetAmount: this.lstBalance.value
	bytec 1 //  "lstBalance"
	app_global_get
	itxn_field AssetAmount

	// contracts/InjectedRewardsPoolConsensus.algo.ts:458
	// fee: 1_000
	intc 3 // 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/InjectedRewardsPoolConsensus.algo.ts:461
	// return {
	//       lstBalance: this.lstBalance.value,
	//       totalStaked: this.totalStaked.value,
	//       circulatingLST: this.circulatingLST.value,
	//       totalConsensusRewards: this.totalConsensusRewards.value,
	//       commisionAmount: this.commisionAmount.value,
	//     };
	bytec 1 //  "lstBalance"
	app_global_get
	itob
	bytec 3 //  "totalStaked"
	app_global_get
	itob
	concat
	bytec 5 //  "circulatingLST"
	app_global_get
	itob
	concat
	bytec 2 //  "totalConsensusRewards"
	app_global_get
	itob
	concat
	bytec 4 //  "commisionAmount"
	app_global_get
	itob
	concat
	retsub

// gas()void
*abi_route_gas:
	// execute gas()void
	callsub gas
	intc 0 // 1
	return

// gas(): void
gas:
	proto 0 0
	retsub

*create_NoOp:
	pushbytes 0x35e44c1f // method "createApplication(address,address,address)void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x13c3f503 // method "initApplication(uint64,uint64,pay)void"
	pushbytes 0xa3fea40f // method "updateAdminAddress(address)void"
	pushbytes 0xb2107f25 // method "updateMigrationAdmin(address)void"
	pushbytes 0xe3e6cc4a // method "updateMaxStake(uint64)void"
	pushbytes 0x1b924159 // method "updateTreasuryAddress(address)void"
	pushbytes 0xc26f6953 // method "updateCommision(uint64)void"
	pushbytes 0xe1cde334 // method "updateCommisionAmount(uint64)void"
	pushbytes 0x8123575c // method "updateConsenusRewards(uint64)void"
	pushbytes 0x736aa924 // method "updateMinimumBalance(uint64)void"
	pushbytes 0x70d85534 // method "updatePaidCommision(uint64)void"
	pushbytes 0xe394695d // method "optInToToken(pay,uint64)void"
	pushbytes 0xcfcb2973 // method "payCommision(pay)void"
	pushbytes 0x400e14fb // method "goOnline(pay,byte[],byte[],byte[],uint64,uint64,uint64)void"
	pushbytes 0x51ef3b21 // method "goOffline()void"
	pushbytes 0x2dc0735d // method "linkToNFD(uint64,string,uint64)void"
	pushbytes 0x20b15970 // method "addLST(axfer,uint64)void"
	pushbytes 0xf8eb9ade // method "removeLST(uint64)void"
	pushbytes 0x71757509 // method "pickupAlgoRewards()void"
	pushbytes 0x53853085 // method "stake(pay,uint64)void"
	pushbytes 0x1b3aeb20 // method "burnLST(axfer,pay,uint64,address)void"
	pushbytes 0x2938c363 // method "acceptMigration(pay,axfer,uint64,uint64,uint64,uint64,uint64)void"
	pushbytes 0x428e5461 // method "migrateContract(pay)(uint64,uint64,uint64,uint64,uint64)"
	pushbytes 0x3172ca9d // method "gas()void"
	txna ApplicationArgs 0
	match *abi_route_initApplication *abi_route_updateAdminAddress *abi_route_updateMigrationAdmin *abi_route_updateMaxStake *abi_route_updateTreasuryAddress *abi_route_updateCommision *abi_route_updateCommisionAmount *abi_route_updateConsenusRewards *abi_route_updateMinimumBalance *abi_route_updatePaidCommision *abi_route_optInToToken *abi_route_payCommision *abi_route_goOnline *abi_route_goOffline *abi_route_linkToNFD *abi_route_addLST *abi_route_removeLST *abi_route_pickupAlgoRewards *abi_route_stake *abi_route_burnLST *abi_route_acceptMigration *abi_route_migrateContract *abi_route_gas

	// this contract does not implement the given ABI method for call NoOp
	err

*call_DeleteApplication:
	pushbytes 0x2487c32c // method "deleteApplication()void"
	txna ApplicationArgs 0
	match *abi_route_deleteApplication

	// this contract does not implement the given ABI method for call DeleteApplication
	err