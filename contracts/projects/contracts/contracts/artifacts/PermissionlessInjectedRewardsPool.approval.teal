#pragma version 10

// This TEAL was generated by TEALScript v0.103.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *call_DeleteApplication *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication(address,address,address)void
*abi_route_createApplication:
	// treasuryAddress: address
	txna ApplicationArgs 3
	dup
	len
	int 32
	==

	// argument 0 (treasuryAddress) for createApplication must be a address
	assert

	// injectorAddress: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 1 (injectorAddress) for createApplication must be a address
	assert

	// adminAddress: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 2 (adminAddress) for createApplication must be a address
	assert

	// execute createApplication(address,address,address)void
	callsub createApplication
	int 1
	return

// createApplication(adminAddress: Address, injectorAddress: Address, treasuryAddress: Address): void
createApplication:
	proto 3 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:74
	// this.adminAddress.value = adminAddress
	byte 0x61646d696e41646472657373 // "adminAddress"
	frame_dig -1 // adminAddress: Address
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:75
	// this.injectorAddress.value = injectorAddress
	byte 0x696e6a6563746f7241646472657373 // "injectorAddress"
	frame_dig -2 // injectorAddress: Address
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:76
	// this.treasuryAddress.value = treasuryAddress
	byte 0x747265617375727941646472657373 // "treasuryAddress"
	frame_dig -3 // treasuryAddress: Address
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:77
	// this.contractVersion.value = VERSION
	byte 0x636f6e747261637456657273696f6e // "contractVersion"
	int 1000
	app_global_put
	retsub

// initApplication(uint64,uint64,uint64,uint64)void
*abi_route_initApplication:
	// xUSDAssetID: uint64
	txna ApplicationArgs 4
	btoi

	// xUSDFee: uint64
	txna ApplicationArgs 3
	btoi

	// rewardAssetId: uint64
	txna ApplicationArgs 2
	btoi

	// stakedAsset: uint64
	txna ApplicationArgs 1
	btoi

	// execute initApplication(uint64,uint64,uint64,uint64)void
	callsub initApplication
	int 1
	return

// initApplication(stakedAsset: uint64, rewardAssetId: uint64, xUSDFee: uint64, xUSDAssetID: uint64): void
initApplication:
	proto 4 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:81
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can init application')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can init application
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:83
	// this.stakedAssetId.value = stakedAsset
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	frame_dig -1 // stakedAsset: uint64
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:84
	// this.rewardAssetId.value = rewardAssetId
	byte 0x72657761726441737365744964 // "rewardAssetId"
	frame_dig -2 // rewardAssetId: uint64
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:85
	// this.totalStaked.value = 0
	byte 0x746f74616c5374616b6564 // "totalStaked"
	int 0
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:86
	// this.freeze.value = false
	byte 0x667265657a65 // "freeze"
	int 0
	byte 0x00
	int 0
	uncover 2
	setbit
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:87
	// this.injectedASARewards.value = 0
	byte 0x696e6a656374656441534152657761726473 // "injectedASARewards"
	int 0
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:88
	// this.injectedxUSDRewards.value = 0
	byte 0x696e6a65637465647855534452657761726473 // "injectedxUSDRewards"
	int 0
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:89
	// this.numStakers.value = 0
	byte 0x6e756d5374616b657273 // "numStakers"
	int 0
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:90
	// this.xUSDFee.value = xUSDFee
	byte 0x78555344466565 // "xUSDFee"
	frame_dig -3 // xUSDFee: uint64
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:91
	// this.feeWaived.value = false
	byte 0x666565576169766564 // "feeWaived"
	int 0
	byte 0x00
	int 0
	uncover 2
	setbit
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:92
	// this.poolActive.value = false
	byte 0x706f6f6c416374697665 // "poolActive"
	int 0
	byte 0x00
	int 0
	uncover 2
	setbit
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:93
	// this.xUSDAssetId.value = xUSDAssetID
	byte 0x7855534441737365744964 // "xUSDAssetId"
	frame_dig -4 // xUSDAssetID: uint64
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:94
	// this.totalRewards.value = 0
	byte 0x746f74616c52657761726473 // "totalRewards"
	int 0
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:95
	// this.rewardFrequency.value = 0
	byte 0x7265776172644672657175656e6379 // "rewardFrequency"
	int 0
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:96
	// this.rewardPerInjection.value = 0
	byte 0x726577617264506572496e6a656374696f6e // "rewardPerInjection"
	int 0
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:97
	// this.injectionType.value = 0
	byte 0x696e6a656374696f6e54797065 // "injectionType"
	int 0
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:98
	// this.lastInjectionTime.value = globals.latestTimestamp
	byte 0x6c617374496e6a656374696f6e54696d65 // "lastInjectionTime"
	global LatestTimestamp
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:100
	// sendAssetTransfer({
	//       xferAsset: AssetID.fromUint64(stakedAsset),
	//       assetReceiver: this.app.address,
	//       assetAmount: 0,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:101
	// xferAsset: AssetID.fromUint64(stakedAsset)
	frame_dig -1 // stakedAsset: uint64
	itxn_field XferAsset

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:102
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:103
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:105
	// sendAssetTransfer({
	//       xferAsset: AssetID.fromUint64(this.xUSDAssetId.value),
	//       assetReceiver: this.app.address,
	//       assetAmount: 0,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:106
	// xferAsset: AssetID.fromUint64(this.xUSDAssetId.value)
	byte 0x7855534441737365744964 // "xUSDAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:107
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:108
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// updateAdminAddress(address)void
*abi_route_updateAdminAddress:
	// adminAddress: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (adminAddress) for updateAdminAddress must be a address
	assert

	// execute updateAdminAddress(address)void
	callsub updateAdminAddress
	int 1
	return

// updateAdminAddress(adminAddress: Address): void
updateAdminAddress:
	proto 1 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:114
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can update admin address')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can update admin address
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:115
	// this.adminAddress.value = adminAddress
	byte 0x61646d696e41646472657373 // "adminAddress"
	frame_dig -1 // adminAddress: Address
	app_global_put
	retsub

// setPoolActive()void
*abi_route_setPoolActive:
	// execute setPoolActive()void
	callsub setPoolActive
	int 1
	return

// setPoolActive(): void
setPoolActive:
	proto 0 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:119
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can set pool active')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can set pool active
	assert

	// *if0_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:120
	// !this.feeWaived.value
	byte 0x666565576169766564 // "feeWaived"
	app_global_get
	int 0
	getbit
	!
	bz *if0_end

	// *if0_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:121
	// assert(this.app.address.assetBalance(this.xUSDAssetId.value) >= this.xUSDFee.value, 'Insufficient balance')
	global CurrentApplicationAddress
	byte 0x7855534441737365744964 // "xUSDAssetId"
	app_global_get
	asset_holding_get AssetBalance
	pop
	byte 0x78555344466565 // "xUSDFee"
	app_global_get
	>=

	// Insufficient balance
	assert

*if0_end:
	// *if1_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:125
	// this.injectionType.value === 0
	byte 0x696e6a656374696f6e54797065 // "injectionType"
	app_global_get
	int 0
	==
	bz *if1_end

	// *if1_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:126
	// assert(this.totalRewards.value > 0, 'Total rewards not set')
	byte 0x746f74616c52657761726473 // "totalRewards"
	app_global_get
	int 0
	>

	// Total rewards not set
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:127
	// assert(this.rewardPerInjection.value > 0, 'Reward per injection not set')
	byte 0x726577617264506572496e6a656374696f6e // "rewardPerInjection"
	app_global_get
	int 0
	>

	// Reward per injection not set
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:128
	// assert(
	//         this.injectorAddress.value.assetBalance(this.rewardAssetId.value) >= this.totalRewards.value,
	//         'Insufficient rewards'
	//       )
	byte 0x696e6a6563746f7241646472657373 // "injectorAddress"
	app_global_get
	byte 0x72657761726441737365744964 // "rewardAssetId"
	app_global_get
	asset_holding_get AssetBalance
	pop
	byte 0x746f74616c52657761726473 // "totalRewards"
	app_global_get
	>=

	// Insufficient rewards
	assert

*if1_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:134
	// assert(this.rewardFrequency.value > 0, 'Reward frequency not set')
	byte 0x7265776172644672657175656e6379 // "rewardFrequency"
	app_global_get
	int 0
	>

	// Reward frequency not set
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:136
	// this.poolActive.value = true
	byte 0x706f6f6c416374697665 // "poolActive"
	int 1
	byte 0x00
	int 0
	uncover 2
	setbit
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:137
	// sendAssetTransfer({
	//       xferAsset: AssetID.fromUint64(this.xUSDAssetId.value),
	//       assetReceiver: this.treasuryAddress.value,
	//       assetAmount: this.xUSDFee.value,
	//       sender: this.app.address,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:138
	// xferAsset: AssetID.fromUint64(this.xUSDAssetId.value)
	byte 0x7855534441737365744964 // "xUSDAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:139
	// assetReceiver: this.treasuryAddress.value
	byte 0x747265617375727941646472657373 // "treasuryAddress"
	app_global_get
	itxn_field AssetReceiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:140
	// assetAmount: this.xUSDFee.value
	byte 0x78555344466565 // "xUSDFee"
	app_global_get
	itxn_field AssetAmount

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:141
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// setRewardParams(uint64,uint64,uint64,uint64)void
*abi_route_setRewardParams:
	// injectionType: uint64
	txna ApplicationArgs 4
	btoi

	// rewardPerInjection: uint64
	txna ApplicationArgs 3
	btoi

	// rewardFrequency: uint64
	txna ApplicationArgs 2
	btoi

	// totalRewards: uint64
	txna ApplicationArgs 1
	btoi

	// execute setRewardParams(uint64,uint64,uint64,uint64)void
	callsub setRewardParams
	int 1
	return

// setRewardParams(totalRewards: uint64, rewardFrequency: uint64, rewardPerInjection: uint64, injectionType: uint64): void
setRewardParams:
	proto 4 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:151
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can set reward params')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can set reward params
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:152
	// this.injectionType.value = injectionType
	byte 0x696e6a656374696f6e54797065 // "injectionType"
	frame_dig -4 // injectionType: uint64
	app_global_put

	// *if2_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:153
	// injectionType === 0
	frame_dig -4 // injectionType: uint64
	int 0
	==
	bz *if2_else

	// *if2_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:154
	// this.totalRewards.value = totalRewards
	byte 0x746f74616c52657761726473 // "totalRewards"
	frame_dig -1 // totalRewards: uint64
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:155
	// this.rewardFrequency.value = rewardFrequency
	byte 0x7265776172644672657175656e6379 // "rewardFrequency"
	frame_dig -2 // rewardFrequency: uint64
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:156
	// this.rewardPerInjection.value = rewardPerInjection
	byte 0x726577617264506572496e6a656374696f6e // "rewardPerInjection"
	frame_dig -3 // rewardPerInjection: uint64
	app_global_put
	b *if2_end

*if2_else:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:158
	// this.totalRewards.value = 0
	byte 0x746f74616c52657761726473 // "totalRewards"
	int 0
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:159
	// this.rewardFrequency.value = rewardFrequency
	byte 0x7265776172644672657175656e6379 // "rewardFrequency"
	frame_dig -2 // rewardFrequency: uint64
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:160
	// this.rewardPerInjection.value = 0
	byte 0x726577617264506572496e6a656374696f6e // "rewardPerInjection"
	int 0
	app_global_put

*if2_end:
	retsub

// updateInjectedASARewards(uint64)void
*abi_route_updateInjectedASARewards:
	// injectedASARewards: uint64
	txna ApplicationArgs 1
	btoi

	// execute updateInjectedASARewards(uint64)void
	callsub updateInjectedASARewards
	int 1
	return

// updateInjectedASARewards(injectedASARewards: uint64): void
updateInjectedASARewards:
	proto 1 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:167
	// assert(this.txn.sender === this.injectorAddress.value, 'Only injector can update injected rewards')
	txn Sender
	byte 0x696e6a6563746f7241646472657373 // "injectorAddress"
	app_global_get
	==

	// Only injector can update injected rewards
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:168
	// this.injectedASARewards.value = injectedASARewards
	byte 0x696e6a656374656441534152657761726473 // "injectedASARewards"
	frame_dig -1 // injectedASARewards: uint64
	app_global_put
	retsub

// updateInjectedxUSDRewards(uint64)void
*abi_route_updateInjectedxUSDRewards:
	// injectedxUSDRewards: uint64
	txna ApplicationArgs 1
	btoi

	// execute updateInjectedxUSDRewards(uint64)void
	callsub updateInjectedxUSDRewards
	int 1
	return

// updateInjectedxUSDRewards(injectedxUSDRewards: uint64): void
updateInjectedxUSDRewards:
	proto 1 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:172
	// assert(this.txn.sender === this.injectorAddress.value, 'Only injector can update injected rewards')
	txn Sender
	byte 0x696e6a6563746f7241646472657373 // "injectorAddress"
	app_global_get
	==

	// Only injector can update injected rewards
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:173
	// this.injectedxUSDRewards.value = injectedxUSDRewards
	byte 0x696e6a65637465647855534452657761726473 // "injectedxUSDRewards"
	frame_dig -1 // injectedxUSDRewards: uint64
	app_global_put
	retsub

// updateTreasuryAddress(address)void
*abi_route_updateTreasuryAddress:
	// treasuryAddress: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (treasuryAddress) for updateTreasuryAddress must be a address
	assert

	// execute updateTreasuryAddress(address)void
	callsub updateTreasuryAddress
	int 1
	return

// updateTreasuryAddress(treasuryAddress: Address): void
updateTreasuryAddress:
	proto 1 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:177
	// assert(this.txn.sender === this.injectorAddress.value, 'Only injector can update treasury address')
	txn Sender
	byte 0x696e6a6563746f7241646472657373 // "injectorAddress"
	app_global_get
	==

	// Only injector can update treasury address
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:178
	// this.treasuryAddress.value = treasuryAddress
	byte 0x747265617375727941646472657373 // "treasuryAddress"
	frame_dig -1 // treasuryAddress: Address
	app_global_put
	retsub

// updatexUSDFee(uint64)void
*abi_route_updatexUSDFee:
	// xUSDFee: uint64
	txna ApplicationArgs 1
	btoi

	// execute updatexUSDFee(uint64)void
	callsub updatexUSDFee
	int 1
	return

// updatexUSDFee(xUSDFee: uint64): void
updatexUSDFee:
	proto 1 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:182
	// assert(this.txn.sender === this.injectorAddress.value, 'Only injector can update xUSD fee')
	txn Sender
	byte 0x696e6a6563746f7241646472657373 // "injectorAddress"
	app_global_get
	==

	// Only injector can update xUSD fee
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:183
	// this.xUSDFee.value = xUSDFee
	byte 0x78555344466565 // "xUSDFee"
	frame_dig -1 // xUSDFee: uint64
	app_global_put
	retsub

// updateInjectorAddress(address)void
*abi_route_updateInjectorAddress:
	// injectorAddress: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (injectorAddress) for updateInjectorAddress must be a address
	assert

	// execute updateInjectorAddress(address)void
	callsub updateInjectorAddress
	int 1
	return

// updateInjectorAddress(injectorAddress: Address): void
updateInjectorAddress:
	proto 1 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:187
	// assert(this.txn.sender === this.injectorAddress.value, 'Only injector can update injector address')
	txn Sender
	byte 0x696e6a6563746f7241646472657373 // "injectorAddress"
	app_global_get
	==

	// Only injector can update injector address
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:188
	// this.injectorAddress.value = injectorAddress
	byte 0x696e6a6563746f7241646472657373 // "injectorAddress"
	frame_dig -1 // injectorAddress: Address
	app_global_put
	retsub

// updateNumStakers(uint64)void
*abi_route_updateNumStakers:
	// numStakers: uint64
	txna ApplicationArgs 1
	btoi

	// execute updateNumStakers(uint64)void
	callsub updateNumStakers
	int 1
	return

// updateNumStakers(numStakers: uint64): void
updateNumStakers:
	proto 1 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:192
	// assert(this.txn.sender === this.injectorAddress.value, 'Only injector can update num stakers')
	txn Sender
	byte 0x696e6a6563746f7241646472657373 // "injectorAddress"
	app_global_get
	==

	// Only injector can update num stakers
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:193
	// this.numStakers.value = numStakers
	byte 0x6e756d5374616b657273 // "numStakers"
	frame_dig -1 // numStakers: uint64
	app_global_put
	retsub

// setFeeWaived()void
*abi_route_setFeeWaived:
	// execute setFeeWaived()void
	callsub setFeeWaived
	int 1
	return

// setFeeWaived(): void
setFeeWaived:
	proto 0 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:197
	// assert(this.txn.sender === this.injectorAddress.value, 'Only injector can update fee waived')
	txn Sender
	byte 0x696e6a6563746f7241646472657373 // "injectorAddress"
	app_global_get
	==

	// Only injector can update fee waived
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:198
	// this.feeWaived.value = true
	byte 0x666565576169766564 // "feeWaived"
	int 1
	byte 0x00
	int 0
	uncover 2
	setbit
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:199
	// this.xUSDFee.value = 0
	byte 0x78555344466565 // "xUSDFee"
	int 0
	app_global_put
	retsub

// costForBoxStorage(totalNumBytes: uint64): uint64
costForBoxStorage:
	proto 1 1

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:206
	// return SCBOX_PERBOX + totalNumBytes * SCBOX_PERBYTE;
	int 2500
	frame_dig -1 // totalNumBytes: uint64
	int 400
	*
	+
	retsub

// getMBRForPoolCreation()(uint64)
*abi_route_getMBRForPoolCreation:
	// The ABI return prefix
	byte 0x151f7c75

	// execute getMBRForPoolCreation()(uint64)
	callsub getMBRForPoolCreation
	concat
	log
	int 1
	return

// getMBRForPoolCreation(): mbrReturn
getMBRForPoolCreation:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:210
	// nonAlgoRewardMBR = ASSET_HOLDING_FEE
	int 100000
	frame_bury 0 // nonAlgoRewardMBR: uint64

	// *if3_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:211
	// this.rewardAssetId.value !== 0
	byte 0x72657761726441737365744964 // "rewardAssetId"
	app_global_get
	int 0
	!=
	bz *if3_end

	// *if3_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:212
	// nonAlgoRewardMBR += ASSET_HOLDING_FEE
	frame_dig 0 // nonAlgoRewardMBR: uint64
	int 100000
	+
	frame_bury 0 // nonAlgoRewardMBR: uint64

*if3_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:214
	// mbr =
	//       ALGORAND_ACCOUNT_MIN_BALANCE +
	//       nonAlgoRewardMBR +
	//       this.costForBoxStorage(7 + len<StakeInfo>() * MAX_STAKERS_PER_POOL) +
	//       this.costForBoxStorage(7 + len<uint64>() * 15)
	int 100000
	frame_dig 0 // nonAlgoRewardMBR: uint64
	+
	int 28007
	callsub costForBoxStorage
	+
	int 127
	callsub costForBoxStorage
	+
	frame_bury 1 // mbr: uint64

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:220
	// return {
	//       mbrPayment: mbr,
	//     };
	frame_dig 1 // mbr: uint64
	itob

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// initStorage(pay)void
*abi_route_initStorage:
	// mbrPayment: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==

	// argument 0 (mbrPayment) for initStorage must be a pay transaction
	assert

	// execute initStorage(pay)void
	callsub initStorage
	int 1
	return

// initStorage(mbrPayment: PayTxn): void
initStorage:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:226
	// assert(!this.stakers.exists, 'staking pool already initialized')
	byte 0x7374616b657273 // "stakers"
	box_len
	swap
	pop
	!

	// staking pool already initialized
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:227
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can init storage')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can init storage
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:229
	// nonAlgoRewardMBR = ASSET_HOLDING_FEE
	int 100000
	frame_bury 0 // nonAlgoRewardMBR: uint64

	// *if4_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:230
	// this.rewardAssetId.value !== 0
	byte 0x72657761726441737365744964 // "rewardAssetId"
	app_global_get
	int 0
	!=
	bz *if4_end

	// *if4_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:231
	// nonAlgoRewardMBR += ASSET_HOLDING_FEE
	frame_dig 0 // nonAlgoRewardMBR: uint64
	int 100000
	+
	frame_bury 0 // nonAlgoRewardMBR: uint64

*if4_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:233
	// poolMBR =
	//       ALGORAND_ACCOUNT_MIN_BALANCE +
	//       nonAlgoRewardMBR +
	//       this.costForBoxStorage(7 + len<StakeInfo>() * MAX_STAKERS_PER_POOL) +
	//       this.costForBoxStorage(7 + len<uint64>() * 15)
	int 100000
	frame_dig 0 // nonAlgoRewardMBR: uint64
	+
	int 28007
	callsub costForBoxStorage
	+
	int 127
	callsub costForBoxStorage
	+
	frame_bury 1 // poolMBR: uint64

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:240
	// verifyPayTxn(mbrPayment, { receiver: this.app.address, amount: poolMBR })
	// verify receiver
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Amount
	frame_dig 1 // poolMBR: uint64
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"amount","expected":"poolMBR"}
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:241
	// this.stakers.create()
	byte 0x7374616b657273 // "stakers"
	int 28000
	box_create
	pop

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:242
	// this.minimumBalance.value = poolMBR
	byte 0x6d696e696d756d42616c616e6365 // "minimumBalance"
	frame_dig 1 // poolMBR: uint64
	app_global_put

	// *if5_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:244
	// this.rewardAssetId.value !== 0
	byte 0x72657761726441737365744964 // "rewardAssetId"
	app_global_get
	int 0
	!=
	bz *if5_end

	// *if5_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:246
	// sendAssetTransfer({
	//         xferAsset: AssetID.fromUint64(this.rewardAssetId.value),
	//         assetReceiver: this.app.address,
	//         assetAmount: 0,
	//       })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:247
	// xferAsset: AssetID.fromUint64(this.rewardAssetId.value)
	byte 0x72657761726441737365744964 // "rewardAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:248
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:249
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if5_end:
	retsub

// injectRewards(axfer,uint64,uint64)void
*abi_route_injectRewards:
	// rewardAssetId: uint64
	txna ApplicationArgs 2
	btoi

	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// rewardTxn: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==

	// argument 2 (rewardTxn) for injectRewards must be a axfer transaction
	assert

	// execute injectRewards(axfer,uint64,uint64)void
	callsub injectRewards
	int 1
	return

// injectRewards(rewardTxn: AssetTransferTxn, quantity: uint64, rewardAssetId: uint64): void
injectRewards:
	proto 3 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:258
	// assert(this.txn.sender === this.injectorAddress.value, 'Only injector can inject rewards')
	txn Sender
	byte 0x696e6a6563746f7241646472657373 // "injectorAddress"
	app_global_get
	==

	// Only injector can inject rewards
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:260
	// verifyAssetTransferTxn(rewardTxn, {
	//       sender: this.injectorAddress.value,
	//       assetReceiver: this.app.address,
	//       xferAsset: AssetID.fromUint64(rewardAssetId),
	//       assetAmount: this.rewardPerInjection.value,
	//     })
	// verify sender
	frame_dig -1 // rewardTxn: AssetTransferTxn
	gtxns Sender
	byte 0x696e6a6563746f7241646472657373 // "injectorAddress"
	app_global_get
	==

	// transaction verification failed: {"txn":"rewardTxn","field":"sender","expected":"this.injectorAddress.value"}
	assert

	// verify assetReceiver
	frame_dig -1 // rewardTxn: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"rewardTxn","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig -1 // rewardTxn: AssetTransferTxn
	gtxns XferAsset
	frame_dig -3 // rewardAssetId: uint64
	==

	// transaction verification failed: {"txn":"rewardTxn","field":"xferAsset","expected":"AssetID.fromUint64(rewardAssetId)"}
	assert

	// verify assetAmount
	frame_dig -1 // rewardTxn: AssetTransferTxn
	gtxns AssetAmount
	byte 0x726577617264506572496e6a656374696f6e // "rewardPerInjection"
	app_global_get
	==

	// transaction verification failed: {"txn":"rewardTxn","field":"assetAmount","expected":"this.rewardPerInjection.value"}
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:266
	// this.injectedASARewards.value += quantity
	byte 0x696e6a656374656441534152657761726473 // "injectedASARewards"
	app_global_get
	frame_dig -2 // quantity: uint64
	+
	byte 0x696e6a656374656441534152657761726473 // "injectedASARewards"
	swap
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:267
	// this.lastInjectionTime.value = globals.latestTimestamp
	byte 0x6c617374496e6a656374696f6e54696d65 // "lastInjectionTime"
	global LatestTimestamp
	app_global_put
	retsub

// injectxUSD(axfer,uint64)void
*abi_route_injectxUSD:
	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// xUSDTxn: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==

	// argument 1 (xUSDTxn) for injectxUSD must be a axfer transaction
	assert

	// execute injectxUSD(axfer,uint64)void
	callsub injectxUSD
	int 1
	return

// injectxUSD(xUSDTxn: AssetTransferTxn, quantity: uint64): void
injectxUSD:
	proto 2 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:271
	// assert(this.txn.sender === this.injectorAddress.value, 'Only injector can inject xUSD')
	txn Sender
	byte 0x696e6a6563746f7241646472657373 // "injectorAddress"
	app_global_get
	==

	// Only injector can inject xUSD
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:272
	// verifyAssetTransferTxn(xUSDTxn, {
	//       sender: this.injectorAddress.value,
	//       assetReceiver: this.app.address,
	//       xferAsset: AssetID.fromUint64(this.xUSDAssetId.value),
	//       assetAmount: quantity,
	//     })
	// verify sender
	frame_dig -1 // xUSDTxn: AssetTransferTxn
	gtxns Sender
	byte 0x696e6a6563746f7241646472657373 // "injectorAddress"
	app_global_get
	==

	// transaction verification failed: {"txn":"xUSDTxn","field":"sender","expected":"this.injectorAddress.value"}
	assert

	// verify assetReceiver
	frame_dig -1 // xUSDTxn: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"xUSDTxn","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig -1 // xUSDTxn: AssetTransferTxn
	gtxns XferAsset
	byte 0x7855534441737365744964 // "xUSDAssetId"
	app_global_get
	==

	// transaction verification failed: {"txn":"xUSDTxn","field":"xferAsset","expected":"AssetID.fromUint64(this.xUSDAssetId.value)"}
	assert

	// verify assetAmount
	frame_dig -1 // xUSDTxn: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -2 // quantity: uint64
	==

	// transaction verification failed: {"txn":"xUSDTxn","field":"assetAmount","expected":"quantity"}
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:278
	// this.injectedxUSDRewards.value += quantity
	byte 0x696e6a65637465647855534452657761726473 // "injectedxUSDRewards"
	app_global_get
	frame_dig -2 // quantity: uint64
	+
	byte 0x696e6a65637465647855534452657761726473 // "injectedxUSDRewards"
	swap
	app_global_put
	retsub

// deleteApplication()void
*abi_route_deleteApplication:
	// execute deleteApplication()void
	callsub deleteApplication
	int 1
	return

// deleteApplication(): void
deleteApplication:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:282
	// assert(this.txn.sender === this.injectorAddress.value, 'Only admin can delete application')
	txn Sender
	byte 0x696e6a6563746f7241646472657373 // "injectorAddress"
	app_global_get
	==

	// Only admin can delete application
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:283
	// assert(this.totalStaked.value === 0, 'Staked assets still exist')
	byte 0x746f74616c5374616b6564 // "totalStaked"
	app_global_get
	int 0
	==

	// Staked assets still exist
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:285
	// this.stakers.delete()
	byte 0x7374616b657273 // "stakers"
	box_del

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:286
	// paymentAmount = this.app.address.balance - this.app.address.minBalance - 2_000
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	pop
	-
	int 2_000
	-
	frame_bury 0 // paymentAmount: uint64

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:288
	// sendPayment({
	//       amount: paymentAmount,
	//       receiver: this.adminAddress.value,
	//       sender: this.app.address,
	//       fee: 1_000,
	//     })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:289
	// amount: paymentAmount
	frame_dig 0 // paymentAmount: uint64
	itxn_field Amount

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:290
	// receiver: this.adminAddress.value
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	itxn_field Receiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:291
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:292
	// fee: 1_000
	int 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// stake(axfer,uint64)void
*abi_route_stake:
	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// stakeTxn: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==

	// argument 1 (stakeTxn) for stake must be a axfer transaction
	assert

	// execute stake(axfer,uint64)void
	callsub stake
	int 1
	return

// stake(stakeTxn: AssetTransferTxn, quantity: uint64): void
stake:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:297
	// assert(quantity > 0, 'Invalid quantity')
	frame_dig -2 // quantity: uint64
	int 0
	>

	// Invalid quantity
	assert

	// *if6_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:298
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if6_end

	// *if6_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:299
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if6_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:301
	// verifyAssetTransferTxn(stakeTxn, {
	//       sender: this.txn.sender,
	//       assetReceiver: this.app.address,
	//       xferAsset: AssetID.fromUint64(this.stakedAssetId.value),
	//       assetAmount: quantity,
	//     })
	// verify sender
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"stakeTxn","field":"sender","expected":"this.txn.sender"}
	assert

	// verify assetReceiver
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"stakeTxn","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns XferAsset
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	app_global_get
	==

	// transaction verification failed: {"txn":"stakeTxn","field":"xferAsset","expected":"AssetID.fromUint64(this.stakedAssetId.value)"}
	assert

	// verify assetAmount
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -2 // quantity: uint64
	==

	// transaction verification failed: {"txn":"stakeTxn","field":"assetAmount","expected":"quantity"}
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:307
	// actionComplete: boolean = false
	int 0
	frame_bury 0 // actionComplete: boolean

	// *if7_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:308
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if7_end

	// *if7_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:309
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if7_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:311
	// for (let i = 0; i < this.stakers.value.length; i += 1)
	int 0
	frame_bury 1 // i: uint64

*for_0:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:311
	// i < this.stakers.value.length
	frame_dig 1 // i: uint64
	int 500
	<
	bz *for_0_end

	// *if8_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:312
	// actionComplete
	frame_dig 0 // actionComplete: boolean
	bz *if8_end

	// *if8_consequent
	b *for_0_end

*if8_end:
	// *if9_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:314
	// this.stakers.value[i].account === this.txn.sender
	frame_dig 1 // i: uint64
	int 56
	* // acc * typeLength
	int 0
	+
	int 32
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	txn Sender
	==
	bz *if9_elseif1_condition

	// *if9_consequent
	// *if10_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:317
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if10_end

	// *if10_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:318
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if10_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:321
	// staker = clone(this.stakers.value[i])
	frame_dig 1 // i: uint64
	int 56
	* // acc * typeLength
	int 56
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	frame_bury 2 // staker: (address,uint64,uint64,uint64)

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:322
	// staker.stake += stakeTxn.assetAmount
	frame_dig 2 // staker: (address,uint64,uint64,uint64)
	int 32 // headOffset
	frame_dig 2 // staker: (address,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns AssetAmount
	+
	itob
	replace3
	frame_bury 2 // staker: (address,uint64,uint64,uint64)

	// *if11_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:324
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if11_end

	// *if11_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:325
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if11_end:
	// *if12_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:327
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if12_end

	// *if12_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:328
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if12_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:330
	// this.stakers.value[i] = staker
	frame_dig 1 // i: uint64
	int 56
	* // acc * typeLength
	frame_dig 2 // staker: (address,uint64,uint64,uint64)
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace

	// *if13_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:331
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if13_end

	// *if13_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:332
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if13_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:334
	// this.totalStaked.value += stakeTxn.assetAmount
	byte 0x746f74616c5374616b6564 // "totalStaked"
	app_global_get
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns AssetAmount
	+
	byte 0x746f74616c5374616b6564 // "totalStaked"
	swap
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:335
	// actionComplete = true
	int 1
	frame_bury 0 // actionComplete: boolean
	b *if9_end

*if9_elseif1_condition:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:336
	// this.stakers.value[i].account === globals.zeroAddress
	frame_dig 1 // i: uint64
	int 56
	* // acc * typeLength
	int 0
	+
	int 32
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	global ZeroAddress
	==
	bz *if9_end

	// *if9_elseif1_consequent
	// *if14_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:337
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if14_end

	// *if14_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:338
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if14_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:340
	// this.totalStaked.value = this.totalStaked.value + stakeTxn.assetAmount
	byte 0x746f74616c5374616b6564 // "totalStaked"
	dup
	app_global_get
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns AssetAmount
	+
	app_global_put

	// *if15_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:341
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if15_end

	// *if15_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:342
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if15_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:344
	// this.stakers.value[i] = {
	//           account: this.txn.sender,
	//           stake: stakeTxn.assetAmount,
	//           accruedASARewards: 0,
	//           accruedxUSDRewards: 0,
	//         }
	frame_dig 1 // i: uint64
	int 56
	* // acc * typeLength
	txn Sender
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns AssetAmount
	itob
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace

	// *if16_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:350
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if16_end

	// *if16_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:351
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if16_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:353
	// this.numStakers.value = this.numStakers.value + 1
	byte 0x6e756d5374616b657273 // "numStakers"
	dup
	app_global_get
	int 1
	+
	app_global_put

	// *if17_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:354
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if17_end

	// *if17_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:355
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if17_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:357
	// actionComplete = true
	int 1
	frame_bury 0 // actionComplete: boolean

*if9_end:
	// *if18_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:360
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if18_end

	// *if18_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:361
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if18_end:

*for_0_continue:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:311
	// i += 1
	frame_dig 1 // i: uint64
	int 1
	+
	frame_bury 1 // i: uint64
	b *for_0

*for_0_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:364
	// assert(actionComplete, 'Stake  failed')
	frame_dig 0 // actionComplete: boolean

	// Stake  failed
	assert
	retsub

// accrueRewards()void
*abi_route_accrueRewards:
	// execute accrueRewards()void
	callsub accrueRewards
	int 1
	return

// accrueRewards(): void
accrueRewards:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 7

	// *if19_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:368
	// !this.freeze.value
	byte 0x667265657a65 // "freeze"
	app_global_get
	int 0
	getbit
	!
	bz *if19_end

	// *if19_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:369
	// additionalASARewards = this.injectedASARewards.value
	byte 0x696e6a656374656441534152657761726473 // "injectedASARewards"
	app_global_get
	frame_bury 0 // additionalASARewards: uint64

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:370
	// xUSDRewards = this.injectedxUSDRewards.value
	byte 0x696e6a65637465647855534452657761726473 // "injectedxUSDRewards"
	app_global_get
	frame_bury 1 // xUSDRewards: uint64

	// *if20_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:372
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if20_end

	// *if20_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:373
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if20_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:376
	// for (let i = 0; i < this.numStakers.value; i += 1)
	int 0
	frame_bury 2 // i: uint64

*for_1:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:376
	// i < this.numStakers.value
	frame_dig 2 // i: uint64
	byte 0x6e756d5374616b657273 // "numStakers"
	app_global_get
	<
	bz *for_1_end

	// *if21_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:377
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if21_end

	// *if21_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:378
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if21_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:380
	// stake = this.stakers.value[i].stake
	frame_dig 2 // i: uint64
	int 56
	* // acc * typeLength
	int 32 // headOffset
	+
	int 8
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	btoi
	frame_bury 3 // stake: uint64

	// *if22_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:382
	// stake > 0
	frame_dig 3 // stake: uint64
	int 0
	>
	bz *if22_end

	// *if22_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:383
	// staker = clone(this.stakers.value[i])
	frame_dig 2 // i: uint64
	int 56
	* // acc * typeLength
	int 56
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	frame_bury 4 // staker: (address,uint64,uint64,uint64)

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:385
	// stakerShare = wideRatio([stake, PRECISION], [this.totalStaked.value])
	frame_dig 3 // stake: uint64
	int 1000000000000000
	mulw
	int 0
	byte 0x746f74616c5374616b6564 // "totalStaked"
	app_global_get
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 5 // stakerShare: uint64

	// *if23_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:387
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if23_end

	// *if23_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:388
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if23_end:
	// *if24_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:391
	// additionalASARewards > 0
	frame_dig 0 // additionalASARewards: uint64
	int 0
	>
	bz *if24_end

	// *if24_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:392
	// rewardRate = wideRatio([additionalASARewards, stakerShare], [PRECISION])
	frame_dig 0 // additionalASARewards: uint64
	frame_dig 5 // stakerShare: uint64
	mulw
	int 0
	int 1000000000000000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 6 // rewardRate: uint64

	// *if25_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:393
	// rewardRate === 0
	frame_dig 6 // rewardRate: uint64
	int 0
	==
	bz *if25_end

	// *if25_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:394
	// rewardRate = 1
	int 1
	frame_bury 6 // rewardRate: uint64

*if25_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:397
	// this.injectedASARewards.value = this.injectedASARewards.value - rewardRate
	byte 0x696e6a656374656441534152657761726473 // "injectedASARewards"
	dup
	app_global_get
	frame_dig 6 // rewardRate: uint64
	-
	app_global_put

	// *if26_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:398
	// this.rewardAssetId.value === this.stakedAssetId.value
	byte 0x72657761726441737365744964 // "rewardAssetId"
	app_global_get
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	app_global_get
	==
	bz *if26_else

	// *if26_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:401
	// staker.stake = staker.stake + rewardRate
	frame_dig 4 // staker: (address,uint64,uint64,uint64)
	int 32 // headOffset
	frame_dig 4 // staker: (address,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig 6 // rewardRate: uint64
	+
	itob
	replace3
	frame_bury 4 // staker: (address,uint64,uint64,uint64)

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:402
	// this.totalStaked.value = this.totalStaked.value + rewardRate
	byte 0x746f74616c5374616b6564 // "totalStaked"
	dup
	app_global_get
	frame_dig 6 // rewardRate: uint64
	+
	app_global_put
	b *if26_end

*if26_else:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:404
	// staker.accruedASARewards = staker.accruedASARewards + rewardRate
	frame_dig 4 // staker: (address,uint64,uint64,uint64)
	int 40 // headOffset
	frame_dig 4 // staker: (address,uint64,uint64,uint64)
	extract 40 8
	btoi
	frame_dig 6 // rewardRate: uint64
	+
	itob
	replace3
	frame_bury 4 // staker: (address,uint64,uint64,uint64)

*if26_end:

*if24_end:
	// *if27_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:407
	// xUSDRewards > 0
	frame_dig 1 // xUSDRewards: uint64
	int 0
	>
	bz *if27_end

	// *if27_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:408
	// rewardRate = wideRatio([xUSDRewards, stakerShare], [PRECISION])
	frame_dig 1 // xUSDRewards: uint64
	frame_dig 5 // stakerShare: uint64
	mulw
	int 0
	int 1000000000000000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 7 // rewardRate: uint64

	// *if28_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:409
	// rewardRate === 0
	frame_dig 7 // rewardRate: uint64
	int 0
	==
	bz *if28_end

	// *if28_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:410
	// rewardRate = 1
	int 1
	frame_bury 7 // rewardRate: uint64

*if28_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:413
	// this.injectedxUSDRewards.value = this.injectedxUSDRewards.value - rewardRate
	byte 0x696e6a65637465647855534452657761726473 // "injectedxUSDRewards"
	dup
	app_global_get
	frame_dig 7 // rewardRate: uint64
	-
	app_global_put

	// *if29_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:414
	// this.xUSDAssetId.value === this.stakedAssetId.value
	byte 0x7855534441737365744964 // "xUSDAssetId"
	app_global_get
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	app_global_get
	==
	bz *if29_else

	// *if29_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:417
	// staker.stake = staker.stake + rewardRate
	frame_dig 4 // staker: (address,uint64,uint64,uint64)
	int 32 // headOffset
	frame_dig 4 // staker: (address,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig 7 // rewardRate: uint64
	+
	itob
	replace3
	frame_bury 4 // staker: (address,uint64,uint64,uint64)

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:418
	// this.totalStaked.value = this.totalStaked.value + rewardRate
	byte 0x746f74616c5374616b6564 // "totalStaked"
	dup
	app_global_get
	frame_dig 7 // rewardRate: uint64
	+
	app_global_put
	b *if29_end

*if29_else:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:420
	// staker.accruedxUSDRewards = staker.accruedxUSDRewards + rewardRate
	frame_dig 4 // staker: (address,uint64,uint64,uint64)
	int 48 // headOffset
	frame_dig 4 // staker: (address,uint64,uint64,uint64)
	extract 48 8
	btoi
	frame_dig 7 // rewardRate: uint64
	+
	itob
	replace3
	frame_bury 4 // staker: (address,uint64,uint64,uint64)

*if29_end:

*if27_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:423
	// this.stakers.value[i] = staker
	frame_dig 2 // i: uint64
	int 56
	* // acc * typeLength
	frame_dig 4 // staker: (address,uint64,uint64,uint64)
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace

*if22_end:

*for_1_continue:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:376
	// i += 1
	frame_dig 2 // i: uint64
	int 1
	+
	frame_bury 2 // i: uint64
	b *for_1

*for_1_end:
	// *if30_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:426
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if30_end

	// *if30_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:427
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if30_end:
	// *if31_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:431
	// this.injectedASARewards.value > 0
	byte 0x696e6a656374656441534152657761726473 // "injectedASARewards"
	app_global_get
	int 0
	>
	bz *if31_end

	// *if31_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:432
	// sendAssetTransfer({
	//           xferAsset: AssetID.fromUint64(this.rewardAssetId.value),
	//           assetReceiver: this.injectorAddress.value,
	//           sender: this.app.address,
	//           assetAmount: this.injectedASARewards.value,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:433
	// xferAsset: AssetID.fromUint64(this.rewardAssetId.value)
	byte 0x72657761726441737365744964 // "rewardAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:434
	// assetReceiver: this.injectorAddress.value
	byte 0x696e6a6563746f7241646472657373 // "injectorAddress"
	app_global_get
	itxn_field AssetReceiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:435
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:436
	// assetAmount: this.injectedASARewards.value
	byte 0x696e6a656374656441534152657761726473 // "injectedASARewards"
	app_global_get
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if31_end:
	// *if32_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:439
	// this.injectedxUSDRewards.value > 0
	byte 0x696e6a65637465647855534452657761726473 // "injectedxUSDRewards"
	app_global_get
	int 0
	>
	bz *if32_end

	// *if32_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:440
	// sendAssetTransfer({
	//           xferAsset: AssetID.fromUint64(this.xUSDAssetId.value),
	//           assetReceiver: this.injectorAddress.value,
	//           sender: this.app.address,
	//           assetAmount: this.injectedxUSDRewards.value,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:441
	// xferAsset: AssetID.fromUint64(this.xUSDAssetId.value)
	byte 0x7855534441737365744964 // "xUSDAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:442
	// assetReceiver: this.injectorAddress.value
	byte 0x696e6a6563746f7241646472657373 // "injectorAddress"
	app_global_get
	itxn_field AssetReceiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:443
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:444
	// assetAmount: this.injectedxUSDRewards.value
	byte 0x696e6a65637465647855534452657761726473 // "injectedxUSDRewards"
	app_global_get
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if32_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:447
	// this.injectedASARewards.value = 0
	byte 0x696e6a656374656441534152657761726473 // "injectedASARewards"
	int 0
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:448
	// this.injectedxUSDRewards.value = 0
	byte 0x696e6a65637465647855534452657761726473 // "injectedxUSDRewards"
	int 0
	app_global_put

*if19_end:
	retsub

// getStaker(address: Address): StakeInfo
getStaker:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:453
	// for (let i = 0; i < this.numStakers.value; i += 1)
	int 0
	frame_bury 0 // i: uint64

*for_2:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:453
	// i < this.numStakers.value
	frame_dig 0 // i: uint64
	byte 0x6e756d5374616b657273 // "numStakers"
	app_global_get
	<
	bz *for_2_end

	// *if33_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:454
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if33_end

	// *if33_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:455
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if33_end:
	// *if34_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:457
	// this.stakers.value[i].account === address
	frame_dig 0 // i: uint64
	int 56
	* // acc * typeLength
	int 0
	+
	int 32
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	frame_dig -1 // address: Address
	==
	bz *if34_end

	// *if34_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:458
	// return clone(this.stakers.value[i]);
	frame_dig 0 // i: uint64
	int 56
	* // acc * typeLength
	int 56
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	b *getStaker*return

*if34_end:

*for_2_continue:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:453
	// i += 1
	frame_dig 0 // i: uint64
	int 1
	+
	frame_bury 0 // i: uint64
	b *for_2

*for_2_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:461
	// return {
	//       account: globals.zeroAddress,
	//       stake: 0,
	//       accruedASARewards: 0,
	//       accruedxUSDRewards: 0,
	//     };
	global ZeroAddress
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat

*getStaker*return:
	// set the subroutine return value
	frame_bury 0
	retsub

// claimRewards()void
*abi_route_claimRewards:
	// execute claimRewards()void
	callsub claimRewards
	int 1
	return

// claimRewards(): void
claimRewards:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// *if35_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:470
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if35_end

	// *if35_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:471
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if35_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:473
	// staker = this.getStaker(this.txn.sender)
	txn Sender
	callsub getStaker
	frame_bury 0 // staker: (address,uint64,uint64,uint64)

	// *if36_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:475
	// staker.accruedASARewards > 0
	frame_dig 0 // staker: (address,uint64,uint64,uint64)
	extract 40 8
	btoi
	int 0
	>
	bz *if36_end

	// *if36_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:476
	// sendAssetTransfer({
	//         xferAsset: AssetID.fromUint64(this.rewardAssetId.value),
	//         assetReceiver: this.txn.sender,
	//         sender: this.app.address,
	//         assetAmount: staker.accruedASARewards,
	//       })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:477
	// xferAsset: AssetID.fromUint64(this.rewardAssetId.value)
	byte 0x72657761726441737365744964 // "rewardAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:478
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:479
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:480
	// assetAmount: staker.accruedASARewards
	frame_dig 0 // staker: (address,uint64,uint64,uint64)
	extract 40 8
	btoi
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:482
	// staker.accruedASARewards = 0
	frame_dig 0 // staker: (address,uint64,uint64,uint64)
	byte 0x0000000000000000
	replace2 40
	frame_bury 0 // staker: (address,uint64,uint64,uint64)

*if36_end:
	// *if37_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:484
	// staker.accruedxUSDRewards > 0
	frame_dig 0 // staker: (address,uint64,uint64,uint64)
	extract 48 8
	btoi
	int 0
	>
	bz *if37_end

	// *if37_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:485
	// sendAssetTransfer({
	//         xferAsset: AssetID.fromUint64(this.xUSDAssetId.value),
	//         assetReceiver: this.txn.sender,
	//         sender: this.app.address,
	//         assetAmount: staker.accruedxUSDRewards,
	//       })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:486
	// xferAsset: AssetID.fromUint64(this.xUSDAssetId.value)
	byte 0x7855534441737365744964 // "xUSDAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:487
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:488
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:489
	// assetAmount: staker.accruedxUSDRewards
	frame_dig 0 // staker: (address,uint64,uint64,uint64)
	extract 48 8
	btoi
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:491
	// staker.accruedxUSDRewards = 0
	frame_dig 0 // staker: (address,uint64,uint64,uint64)
	byte 0x0000000000000000
	replace2 48
	frame_bury 0 // staker: (address,uint64,uint64,uint64)

*if37_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:494
	// this.setStaker(staker.account, staker)
	frame_dig 0 // staker: (address,uint64,uint64,uint64)
	frame_dig 0 // staker: (address,uint64,uint64,uint64)
	extract 0 32
	callsub setStaker

	// *if38_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:495
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if38_end

	// *if38_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:496
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if38_end:
	retsub

// unstake(uint64)void
*abi_route_unstake:
	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// execute unstake(uint64)void
	callsub unstake
	int 1
	return

// unstake(quantity: uint64): void
unstake:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 4

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:501
	// for (let i = 0; i < this.numStakers.value; i += 1)
	int 0
	frame_bury 0 // i: uint64

*for_3:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:501
	// i < this.numStakers.value
	frame_dig 0 // i: uint64
	byte 0x6e756d5374616b657273 // "numStakers"
	app_global_get
	<
	bz *for_3_end

	// *if39_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:502
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if39_end

	// *if39_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:503
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if39_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:505
	// staker = clone(this.stakers.value[i])
	frame_dig 0 // i: uint64
	int 56
	* // acc * typeLength
	int 56
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	frame_bury 1 // staker: (address,uint64,uint64,uint64)

	// *if40_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:506
	// staker.account === this.txn.sender
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	extract 0 32
	txn Sender
	==
	bz *if40_end

	// *if40_consequent
	// *if41_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:507
	// staker.stake > 0
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	extract 32 8
	btoi
	int 0
	>
	bz *if41_end

	// *if41_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:508
	// sendAssetTransfer({
	//             xferAsset: AssetID.fromUint64(this.stakedAssetId.value),
	//             assetReceiver: this.txn.sender,
	//             sender: this.app.address,
	//             assetAmount: quantity === 0 ? staker.stake : quantity,
	//           })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:509
	// xferAsset: AssetID.fromUint64(this.stakedAssetId.value)
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:510
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:511
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:512
	// assetAmount: quantity === 0 ? staker.stake : quantity
	frame_dig -1 // quantity: uint64
	int 0
	==
	bz *ternary0_false
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	extract 32 8
	btoi
	b *ternary0_end

*ternary0_false:
	frame_dig -1 // quantity: uint64

*ternary0_end:
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if41_end:
	// *if42_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:517
	// staker.accruedASARewards > 0
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	extract 40 8
	btoi
	int 0
	>
	bz *if42_end

	// *if42_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:518
	// sendAssetTransfer({
	//             xferAsset: AssetID.fromUint64(this.rewardAssetId.value),
	//             assetReceiver: this.txn.sender,
	//             sender: this.app.address,
	//             assetAmount: staker.accruedASARewards,
	//           })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:519
	// xferAsset: AssetID.fromUint64(this.rewardAssetId.value)
	byte 0x72657761726441737365744964 // "rewardAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:520
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:521
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:522
	// assetAmount: staker.accruedASARewards
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	extract 40 8
	btoi
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:524
	// staker.accruedASARewards = 0
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	byte 0x0000000000000000
	replace2 40
	frame_bury 1 // staker: (address,uint64,uint64,uint64)

*if42_end:
	// *if43_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:528
	// staker.accruedxUSDRewards > 0
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	extract 48 8
	btoi
	int 0
	>
	bz *if43_end

	// *if43_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:529
	// sendAssetTransfer({
	//             xferAsset: AssetID.fromUint64(this.xUSDAssetId.value),
	//             assetReceiver: this.txn.sender,
	//             sender: this.app.address,
	//             assetAmount: staker.accruedxUSDRewards,
	//           })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:530
	// xferAsset: AssetID.fromUint64(this.xUSDAssetId.value)
	byte 0x7855534441737365744964 // "xUSDAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:531
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:532
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:533
	// assetAmount: staker.accruedxUSDRewards
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	extract 48 8
	btoi
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:535
	// staker.accruedxUSDRewards = 0
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	byte 0x0000000000000000
	replace2 48
	frame_bury 1 // staker: (address,uint64,uint64,uint64)

*if43_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:539
	// this.totalStaked.value = this.totalStaked.value - (quantity === 0 ? staker.stake : quantity)
	byte 0x746f74616c5374616b6564 // "totalStaked"
	dup
	app_global_get
	frame_dig -1 // quantity: uint64
	int 0
	==
	bz *ternary2_false
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	extract 32 8
	btoi
	b *ternary2_end

*ternary2_false:
	frame_dig -1 // quantity: uint64

*ternary2_end:
	-
	app_global_put

	// *if44_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:541
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if44_end

	// *if44_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:542
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if44_end:
	// *if45_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:545
	// quantity === 0
	frame_dig -1 // quantity: uint64
	int 0
	==
	bz *if45_else

	// *if45_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:546
	// removedStaker: StakeInfo = {
	//             account: globals.zeroAddress,
	//             stake: 0,
	//             accruedxUSDRewards: 0,
	//             accruedASARewards: 0,
	//           }
	global ZeroAddress
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	frame_bury 2 // removedStaker: StakeInfo

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:552
	// this.setStaker(staker.account, removedStaker)
	frame_dig 2 // removedStaker: StakeInfo
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	extract 0 32
	callsub setStaker

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:556
	// lastStaker = this.getStaker(this.stakers.value[this.numStakers.value - 1].account)
	byte 0x6e756d5374616b657273 // "numStakers"
	app_global_get
	int 1
	-
	int 56
	* // acc * typeLength
	int 0
	+
	int 32
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	callsub getStaker
	frame_bury 3 // lastStaker: (address,uint64,uint64,uint64)

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:557
	// lastStakerIndex = this.getStakerIndex(this.stakers.value[this.numStakers.value - 1].account)
	byte 0x6e756d5374616b657273 // "numStakers"
	app_global_get
	int 1
	-
	int 56
	* // acc * typeLength
	int 0
	+
	int 32
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	callsub getStakerIndex
	frame_bury 4 // lastStakerIndex: uint64

	// *if46_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:558
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if46_end

	// *if46_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:559
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if46_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:561
	// this.setStakerAtIndex(lastStaker, i)
	frame_dig 0 // i: uint64
	frame_dig 3 // lastStaker: (address,uint64,uint64,uint64)
	callsub setStakerAtIndex

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:564
	// this.setStakerAtIndex(removedStaker, lastStakerIndex)
	frame_dig 4 // lastStakerIndex: uint64
	frame_dig 2 // removedStaker: StakeInfo
	callsub setStakerAtIndex

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:565
	// this.numStakers.value = this.numStakers.value - 1
	byte 0x6e756d5374616b657273 // "numStakers"
	dup
	app_global_get
	int 1
	-
	app_global_put
	b *if45_end

*if45_else:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:567
	// staker.stake = staker.stake - quantity
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	int 32 // headOffset
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig -1 // quantity: uint64
	-
	itob
	replace3
	frame_bury 1 // staker: (address,uint64,uint64,uint64)

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:568
	// staker.accruedASARewards = 0
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	byte 0x0000000000000000
	replace2 40
	frame_bury 1 // staker: (address,uint64,uint64,uint64)

*if45_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:570
	// this.setStaker(staker.account, staker)
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	extract 0 32
	callsub setStaker

*if40_end:

*for_3_continue:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:501
	// i += 1
	frame_dig 0 // i: uint64
	int 1
	+
	frame_bury 0 // i: uint64
	b *for_3

*for_3_end:
	retsub

// getStakerIndex(address: Address): uint64
getStakerIndex:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:576
	// for (let i = 0; i < this.numStakers.value; i += 1)
	int 0
	frame_bury 0 // i: uint64

*for_4:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:576
	// i < this.numStakers.value
	frame_dig 0 // i: uint64
	byte 0x6e756d5374616b657273 // "numStakers"
	app_global_get
	<
	bz *for_4_end

	// *if47_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:577
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if47_end

	// *if47_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:578
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if47_end:
	// *if48_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:580
	// this.stakers.value[i].account === address
	frame_dig 0 // i: uint64
	int 56
	* // acc * typeLength
	int 0
	+
	int 32
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	frame_dig -1 // address: Address
	==
	bz *if48_end

	// *if48_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:581
	// return i;
	frame_dig 0 // i: uint64
	b *getStakerIndex*return

*if48_end:

*for_4_continue:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:576
	// i += 1
	frame_dig 0 // i: uint64
	int 1
	+
	frame_bury 0 // i: uint64
	b *for_4

*for_4_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:584
	// return 0;
	int 0

*getStakerIndex*return:
	// set the subroutine return value
	frame_bury 0
	retsub

// setStaker(stakerAccount: Address, staker: StakeInfo): void
setStaker:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:588
	// for (let i = 0; i < this.numStakers.value; i += 1)
	int 0
	frame_bury 0 // i: uint64

*for_5:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:588
	// i < this.numStakers.value
	frame_dig 0 // i: uint64
	byte 0x6e756d5374616b657273 // "numStakers"
	app_global_get
	<
	bz *for_5_end

	// *if49_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:589
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if49_end

	// *if49_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:590
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if49_end:
	// *if50_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:592
	// this.stakers.value[i].account === stakerAccount
	frame_dig 0 // i: uint64
	int 56
	* // acc * typeLength
	int 0
	+
	int 32
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	frame_dig -1 // stakerAccount: Address
	==
	bz *if50_elseif1_condition

	// *if50_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:593
	// this.stakers.value[i] = staker
	frame_dig 0 // i: uint64
	int 56
	* // acc * typeLength
	frame_dig -2 // staker: StakeInfo
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:594
	// return;
	retsub
	b *if50_end

*if50_elseif1_condition:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:596
	// this.stakers.value[i].account === globals.zeroAddress
	frame_dig 0 // i: uint64
	int 56
	* // acc * typeLength
	int 0
	+
	int 32
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	global ZeroAddress
	==
	bz *if50_end

	// *if50_elseif1_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:597
	// this.stakers.value[i] = staker
	frame_dig 0 // i: uint64
	int 56
	* // acc * typeLength
	frame_dig -2 // staker: StakeInfo
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:598
	// return;
	retsub

*if50_end:

*for_5_continue:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:588
	// i += 1
	frame_dig 0 // i: uint64
	int 1
	+
	frame_bury 0 // i: uint64
	b *for_5

*for_5_end:
	retsub

// setStakerAtIndex(staker: StakeInfo, index: uint64): void
setStakerAtIndex:
	proto 2 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:604
	// this.stakers.value[index] = staker
	frame_dig -2 // index: uint64
	int 56
	* // acc * typeLength
	frame_dig -1 // staker: StakeInfo
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace
	retsub

// setFreeze(bool)void
*abi_route_setFreeze:
	// enabled: bool
	txna ApplicationArgs 1
	dup
	len
	int 1
	==

	// argument 0 (enabled) for setFreeze must be a bool
	assert
	int 0
	getbit

	// execute setFreeze(bool)void
	callsub setFreeze
	int 1
	return

// setFreeze(enabled: boolean): void
setFreeze:
	proto 1 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:608
	// assert(this.txn.sender === this.injectorAddress.value, 'Only injector can freeze payouts')
	txn Sender
	byte 0x696e6a6563746f7241646472657373 // "injectorAddress"
	app_global_get
	==

	// Only injector can freeze payouts
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:609
	// this.freeze.value = enabled
	byte 0x667265657a65 // "freeze"
	frame_dig -1 // enabled: boolean
	byte 0x00
	int 0
	uncover 2
	setbit
	app_global_put
	retsub

// gas()void
*abi_route_gas:
	// execute gas()void
	callsub gas
	int 1
	return

// gas(): void
gas:
	proto 0 0
	retsub

*create_NoOp:
	method "createApplication(address,address,address)void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	method "initApplication(uint64,uint64,uint64,uint64)void"
	method "updateAdminAddress(address)void"
	method "setPoolActive()void"
	method "setRewardParams(uint64,uint64,uint64,uint64)void"
	method "updateInjectedASARewards(uint64)void"
	method "updateInjectedxUSDRewards(uint64)void"
	method "updateTreasuryAddress(address)void"
	method "updatexUSDFee(uint64)void"
	method "updateInjectorAddress(address)void"
	method "updateNumStakers(uint64)void"
	method "setFeeWaived()void"
	method "getMBRForPoolCreation()(uint64)"
	method "initStorage(pay)void"
	method "injectRewards(axfer,uint64,uint64)void"
	method "injectxUSD(axfer,uint64)void"
	method "stake(axfer,uint64)void"
	method "accrueRewards()void"
	method "claimRewards()void"
	method "unstake(uint64)void"
	method "setFreeze(bool)void"
	method "gas()void"
	txna ApplicationArgs 0
	match *abi_route_initApplication *abi_route_updateAdminAddress *abi_route_setPoolActive *abi_route_setRewardParams *abi_route_updateInjectedASARewards *abi_route_updateInjectedxUSDRewards *abi_route_updateTreasuryAddress *abi_route_updatexUSDFee *abi_route_updateInjectorAddress *abi_route_updateNumStakers *abi_route_setFeeWaived *abi_route_getMBRForPoolCreation *abi_route_initStorage *abi_route_injectRewards *abi_route_injectxUSD *abi_route_stake *abi_route_accrueRewards *abi_route_claimRewards *abi_route_unstake *abi_route_setFreeze *abi_route_gas

	// this contract does not implement the given ABI method for call NoOp
	err

*call_DeleteApplication:
	method "deleteApplication()void"
	txna ApplicationArgs 0
	match *abi_route_deleteApplication

	// this contract does not implement the given ABI method for call DeleteApplication
	err