#pragma version 11
intcblock 0 1 6 300 5 56 32 4 100000 1000000000000000 2000 10000 28007 127
bytecblock 0x0a8101 0x 0x7374616b657273 0x6e756d5374616b657273 0x72657761726441737365744964 0x746f74616c5374616b6564 0x0000000000000000 0x61646d696e41646472657373 0x696e6a656374656441534152657761726473 0x696e6a65637465647855534452657761726473 0x696e6a6563746f7241646472657373 0x00 0x7061696441534152657761726473 0x7855534441737365744964 0x7374616b656441737365744964 0x706f6f6c416374697665 0x706f6f6c456e64696e67 0x667265657a65 0x6c617374496e6a656374696f6e54696d65 0x747265617375727941646472657373 0x706c6174666f726d466565427073 0x70616964506c6174666f726d46656573

// This TEAL was generated by TEALScript v0.107.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 2 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *call_DeleteApplication *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication(address,address,address)void
*abi_route_createApplication:
	// injectorAddress: address
	txna ApplicationArgs 3
	dup
	len
	intc 6 // 32
	==

	// argument 0 (injectorAddress) for createApplication must be a address
	assert

	// treasuryAddress: address
	txna ApplicationArgs 2
	dup
	len
	intc 6 // 32
	==

	// argument 1 (treasuryAddress) for createApplication must be a address
	assert

	// adminAddress: address
	txna ApplicationArgs 1
	dup
	len
	intc 6 // 32
	==

	// argument 2 (adminAddress) for createApplication must be a address
	assert

	// execute createApplication(address,address,address)void
	callsub createApplication
	intc 1 // 1
	return

// createApplication(adminAddress: Address, treasuryAddress: Address, injectorAddress: Address): void
createApplication:
	proto 3 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:67
	// this.adminAddress.value = adminAddress
	bytec 7 //  "adminAddress"
	frame_dig -1 // adminAddress: Address
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:68
	// this.treasuryAddress.value = treasuryAddress
	bytec 19 //  "treasuryAddress"
	frame_dig -2 // treasuryAddress: Address
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:69
	// this.injectorAddress.value = injectorAddress
	bytec 10 //  "injectorAddress"
	frame_dig -3 // injectorAddress: Address
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:70
	// this.contractVersion.value = VERSION
	pushbytes 0x636f6e747261637456657273696f6e // "contractVersion"
	intc 10 // 2000
	app_global_put
	retsub

// initApplication(uint64,uint64,uint64,uint64)void
*abi_route_initApplication:
	// platformFeeBps: uint64
	txna ApplicationArgs 4
	btoi

	// xUSDAssetID: uint64
	txna ApplicationArgs 3
	btoi

	// rewardAssetId: uint64
	txna ApplicationArgs 2
	btoi

	// stakedAsset: uint64
	txna ApplicationArgs 1
	btoi

	// execute initApplication(uint64,uint64,uint64,uint64)void
	callsub initApplication
	intc 1 // 1
	return

// initApplication(stakedAsset: uint64, rewardAssetId: uint64, xUSDAssetID: uint64, platformFeeBps: uint64): void
initApplication:
	proto 4 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:74
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can init application')
	txn Sender
	bytec 7 //  "adminAddress"
	app_global_get
	==

	// Only admin can init application
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:76
	// this.stakedAssetId.value = stakedAsset
	bytec 14 //  "stakedAssetId"
	frame_dig -1 // stakedAsset: uint64
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:77
	// this.rewardAssetId.value = rewardAssetId
	bytec 4 //  "rewardAssetId"
	frame_dig -2 // rewardAssetId: uint64
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:78
	// this.totalStaked.value = 0
	bytec 5 //  "totalStaked"
	intc 0 // 0
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:79
	// this.freeze.value = false
	bytec 17 //  "freeze"
	intc 0 // 0
	bytec 11 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:80
	// this.injectedASARewards.value = 0
	bytec 8 //  "injectedASARewards"
	intc 0 // 0
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:81
	// this.injectedxUSDRewards.value = 0
	bytec 9 //  "injectedxUSDRewards"
	intc 0 // 0
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:82
	// this.numStakers.value = 0
	bytec 3 //  "numStakers"
	intc 0 // 0
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:83
	// this.poolActive.value = false
	bytec 15 //  "poolActive"
	intc 0 // 0
	bytec 11 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:84
	// this.poolEnding.value = false
	bytec 16 //  "poolEnding"
	intc 0 // 0
	bytec 11 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:85
	// this.xUSDAssetId.value = xUSDAssetID
	bytec 13 //  "xUSDAssetId"
	frame_dig -3 // xUSDAssetID: uint64
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:86
	// this.lastInjectionTime.value = globals.latestTimestamp
	bytec 18 //  "lastInjectionTime"
	global LatestTimestamp
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:87
	// this.paidASARewards.value = 0
	bytec 12 //  "paidASARewards"
	intc 0 // 0
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:88
	// this.platformFeeBps.value = platformFeeBps
	bytec 20 //  "platformFeeBps"
	frame_dig -4 // platformFeeBps: uint64
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:90
	// sendAssetTransfer({
	//       xferAsset: AssetID.fromUint64(stakedAsset),
	//       assetReceiver: this.app.address,
	//       assetAmount: 0,
	//     })
	itxn_begin
	intc 7 //  axfer
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:91
	// xferAsset: AssetID.fromUint64(stakedAsset)
	frame_dig -1 // stakedAsset: uint64
	itxn_field XferAsset

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:92
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:93
	// assetAmount: 0
	intc 0 // 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:95
	// sendAssetTransfer({
	//       xferAsset: AssetID.fromUint64(this.xUSDAssetId.value),
	//       assetReceiver: this.app.address,
	//       assetAmount: 0,
	//     })
	itxn_begin
	intc 7 //  axfer
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:96
	// xferAsset: AssetID.fromUint64(this.xUSDAssetId.value)
	bytec 13 //  "xUSDAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:97
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:98
	// assetAmount: 0
	intc 0 // 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:100
	// sendAssetTransfer({
	//       xferAsset: AssetID.fromUint64(rewardAssetId),
	//       assetReceiver: this.app.address,
	//       assetAmount: 0,
	//     })
	itxn_begin
	intc 7 //  axfer
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:101
	// xferAsset: AssetID.fromUint64(rewardAssetId)
	frame_dig -2 // rewardAssetId: uint64
	itxn_field XferAsset

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:102
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:103
	// assetAmount: 0
	intc 0 // 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// updateAdminAddress(address)void
*abi_route_updateAdminAddress:
	// adminAddress: address
	txna ApplicationArgs 1
	dup
	len
	intc 6 // 32
	==

	// argument 0 (adminAddress) for updateAdminAddress must be a address
	assert

	// execute updateAdminAddress(address)void
	callsub updateAdminAddress
	intc 1 // 1
	return

// updateAdminAddress(adminAddress: Address): void
updateAdminAddress:
	proto 1 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:109
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can update admin address')
	txn Sender
	bytec 7 //  "adminAddress"
	app_global_get
	==

	// Only admin can update admin address
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:110
	// this.adminAddress.value = adminAddress
	bytec 7 //  "adminAddress"
	frame_dig -1 // adminAddress: Address
	app_global_put
	retsub

// setPoolActive()void
*abi_route_setPoolActive:
	// execute setPoolActive()void
	callsub setPoolActive
	intc 1 // 1
	return

// setPoolActive(): void
setPoolActive:
	proto 0 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:114
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can set pool active')
	txn Sender
	bytec 7 //  "adminAddress"
	app_global_get
	==

	// Only admin can set pool active
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:116
	// this.poolActive.value = true
	bytec 15 //  "poolActive"
	intc 1 // 1
	bytec 11 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put
	retsub

// setPoolEnding()void
*abi_route_setPoolEnding:
	// execute setPoolEnding()void
	callsub setPoolEnding
	intc 1 // 1
	return

// setPoolEnding(): void
setPoolEnding:
	proto 0 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:120
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can set pool ending')
	txn Sender
	bytec 7 //  "adminAddress"
	app_global_get
	==

	// Only admin can set pool ending
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:121
	// this.poolEnding.value = true
	bytec 16 //  "poolEnding"
	intc 1 // 1
	bytec 11 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:122
	// this.poolActive.value = false
	bytec 15 //  "poolActive"
	intc 0 // 0
	bytec 11 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put
	retsub

// updateInjectedASARewards(uint64)void
*abi_route_updateInjectedASARewards:
	// injectedASARewards: uint64
	txna ApplicationArgs 1
	btoi

	// execute updateInjectedASARewards(uint64)void
	callsub updateInjectedASARewards
	intc 1 // 1
	return

// updateInjectedASARewards(injectedASARewards: uint64): void
updateInjectedASARewards:
	proto 1 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:128
	// assert(this.txn.sender === this.injectorAddress.value, 'Only injector can update injected rewards')
	txn Sender
	bytec 10 //  "injectorAddress"
	app_global_get
	==

	// Only injector can update injected rewards
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:129
	// this.injectedASARewards.value = injectedASARewards
	bytec 8 //  "injectedASARewards"
	frame_dig -1 // injectedASARewards: uint64
	app_global_put
	retsub

// updatePaidASARewards(uint64)void
*abi_route_updatePaidASARewards:
	// paidASARewards: uint64
	txna ApplicationArgs 1
	btoi

	// execute updatePaidASARewards(uint64)void
	callsub updatePaidASARewards
	intc 1 // 1
	return

// updatePaidASARewards(paidASARewards: uint64): void
updatePaidASARewards:
	proto 1 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:133
	// assert(this.txn.sender === this.injectorAddress.value, 'Only injector can update paid rewards')
	txn Sender
	bytec 10 //  "injectorAddress"
	app_global_get
	==

	// Only injector can update paid rewards
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:134
	// this.paidASARewards.value = paidASARewards
	bytec 12 //  "paidASARewards"
	frame_dig -1 // paidASARewards: uint64
	app_global_put
	retsub

// updateInjectedxUSDRewards(uint64)void
*abi_route_updateInjectedxUSDRewards:
	// injectedxUSDRewards: uint64
	txna ApplicationArgs 1
	btoi

	// execute updateInjectedxUSDRewards(uint64)void
	callsub updateInjectedxUSDRewards
	intc 1 // 1
	return

// updateInjectedxUSDRewards(injectedxUSDRewards: uint64): void
updateInjectedxUSDRewards:
	proto 1 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:138
	// assert(this.txn.sender === this.injectorAddress.value, 'Only injector can update injected rewards')
	txn Sender
	bytec 10 //  "injectorAddress"
	app_global_get
	==

	// Only injector can update injected rewards
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:139
	// this.injectedxUSDRewards.value = injectedxUSDRewards
	bytec 9 //  "injectedxUSDRewards"
	frame_dig -1 // injectedxUSDRewards: uint64
	app_global_put
	retsub

// updateTreasuryAddress(address)void
*abi_route_updateTreasuryAddress:
	// treasuryAddress: address
	txna ApplicationArgs 1
	dup
	len
	intc 6 // 32
	==

	// argument 0 (treasuryAddress) for updateTreasuryAddress must be a address
	assert

	// execute updateTreasuryAddress(address)void
	callsub updateTreasuryAddress
	intc 1 // 1
	return

// updateTreasuryAddress(treasuryAddress: Address): void
updateTreasuryAddress:
	proto 1 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:143
	// assert(this.txn.sender === this.injectorAddress.value, 'Only injector can update treasury address')
	txn Sender
	bytec 10 //  "injectorAddress"
	app_global_get
	==

	// Only injector can update treasury address
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:144
	// this.treasuryAddress.value = treasuryAddress
	bytec 19 //  "treasuryAddress"
	frame_dig -1 // treasuryAddress: Address
	app_global_put
	retsub

// updateInjectorAddress(address)void
*abi_route_updateInjectorAddress:
	// injectorAddress: address
	txna ApplicationArgs 1
	dup
	len
	intc 6 // 32
	==

	// argument 0 (injectorAddress) for updateInjectorAddress must be a address
	assert

	// execute updateInjectorAddress(address)void
	callsub updateInjectorAddress
	intc 1 // 1
	return

// updateInjectorAddress(injectorAddress: Address): void
updateInjectorAddress:
	proto 1 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:148
	// assert(this.txn.sender === this.injectorAddress.value, 'Only injector can update injector address')
	txn Sender
	bytec 10 //  "injectorAddress"
	app_global_get
	==

	// Only injector can update injector address
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:149
	// this.injectorAddress.value = injectorAddress
	bytec 10 //  "injectorAddress"
	frame_dig -1 // injectorAddress: Address
	app_global_put
	retsub

// updateNumStakers(uint64)void
*abi_route_updateNumStakers:
	// numStakers: uint64
	txna ApplicationArgs 1
	btoi

	// execute updateNumStakers(uint64)void
	callsub updateNumStakers
	intc 1 // 1
	return

// updateNumStakers(numStakers: uint64): void
updateNumStakers:
	proto 1 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:153
	// assert(this.txn.sender === this.injectorAddress.value, 'Only injector can update num stakers')
	txn Sender
	bytec 10 //  "injectorAddress"
	app_global_get
	==

	// Only injector can update num stakers
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:154
	// this.numStakers.value = numStakers
	bytec 3 //  "numStakers"
	frame_dig -1 // numStakers: uint64
	app_global_put
	retsub

// updateFreeze(bool)void
*abi_route_updateFreeze:
	// freeze: bool
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 1
	==

	// argument 0 (freeze) for updateFreeze must be a bool
	assert
	intc 0 // 0
	getbit

	// execute updateFreeze(bool)void
	callsub updateFreeze
	intc 1 // 1
	return

// updateFreeze(freeze: boolean): void
updateFreeze:
	proto 1 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:158
	// assert(this.txn.sender === this.injectorAddress.value, 'Only injector can update freeze')
	txn Sender
	bytec 10 //  "injectorAddress"
	app_global_get
	==

	// Only injector can update freeze
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:159
	// this.freeze.value = freeze
	bytec 17 //  "freeze"
	frame_dig -1 // freeze: boolean
	bytec 11 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put
	retsub

// updatePoolEnding(bool)void
*abi_route_updatePoolEnding:
	// poolEnding: bool
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 1
	==

	// argument 0 (poolEnding) for updatePoolEnding must be a bool
	assert
	intc 0 // 0
	getbit

	// execute updatePoolEnding(bool)void
	callsub updatePoolEnding
	intc 1 // 1
	return

// updatePoolEnding(poolEnding: boolean): void
updatePoolEnding:
	proto 1 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:163
	// assert(this.txn.sender === this.adminAddress.value, 'Only admins can update pool ending')
	txn Sender
	bytec 7 //  "adminAddress"
	app_global_get
	==

	// Only admins can update pool ending
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:164
	// this.poolEnding.value = poolEnding
	bytec 16 //  "poolEnding"
	frame_dig -1 // poolEnding: boolean
	bytec 11 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put
	retsub

// costForBoxStorage(totalNumBytes: uint64): uint64
costForBoxStorage:
	proto 1 1

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:171
	// return SCBOX_PERBOX + totalNumBytes * SCBOX_PERBYTE;
	pushint 2500
	frame_dig -1 // totalNumBytes: uint64
	pushint 400
	*
	+
	retsub

// getMBRForPoolCreation()(uint64)
*abi_route_getMBRForPoolCreation:
	// The ABI return prefix
	pushbytes 0x151f7c75

	// execute getMBRForPoolCreation()(uint64)
	callsub getMBRForPoolCreation
	concat
	log
	intc 1 // 1
	return

// getMBRForPoolCreation(): mbrReturn
getMBRForPoolCreation:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dup

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:175
	// nonAlgoRewardMBR = ASSET_HOLDING_FEE
	intc 8 // 100000
	frame_bury 0 // nonAlgoRewardMBR: uint64

	// *if0_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:176
	// this.rewardAssetId.value !== 0
	bytec 4 //  "rewardAssetId"
	app_global_get
	intc 0 // 0
	!=
	bz *if0_end

	// *if0_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:177
	// nonAlgoRewardMBR += ASSET_HOLDING_FEE
	frame_dig 0 // nonAlgoRewardMBR: uint64
	intc 8 // 100000
	+
	frame_bury 0 // nonAlgoRewardMBR: uint64

*if0_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:179
	// mbr =
	//       ALGORAND_ACCOUNT_MIN_BALANCE +
	//       nonAlgoRewardMBR +
	//       this.costForBoxStorage(7 + len<StakeInfo>() * MAX_STAKERS_PER_POOL) +
	//       this.costForBoxStorage(7 + len<uint64>() * 15)
	intc 8 // 100000
	frame_dig 0 // nonAlgoRewardMBR: uint64
	+
	intc 12 // 28007
	callsub costForBoxStorage
	+
	intc 13 // 127
	callsub costForBoxStorage
	+
	frame_bury 1 // mbr: uint64

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:185
	// return {
	//       mbrPayment: mbr,
	//     };
	frame_dig 1 // mbr: uint64
	itob

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// initStorage(pay)void
*abi_route_initStorage:
	// mbrPayment: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 0 (mbrPayment) for initStorage must be a pay transaction
	assert

	// execute initStorage(pay)void
	callsub initStorage
	intc 1 // 1
	return

// initStorage(mbrPayment: PayTxn): void
initStorage:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dup

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:191
	// assert(!this.stakers.exists, 'staking pool already initialized')
	bytec 2 //  "stakers"
	box_len
	swap
	pop
	!

	// staking pool already initialized
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:192
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can init storage')
	txn Sender
	bytec 7 //  "adminAddress"
	app_global_get
	==

	// Only admin can init storage
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:194
	// nonAlgoRewardMBR = ASSET_HOLDING_FEE
	intc 8 // 100000
	frame_bury 0 // nonAlgoRewardMBR: uint64

	// *if1_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:195
	// this.rewardAssetId.value !== 0
	bytec 4 //  "rewardAssetId"
	app_global_get
	intc 0 // 0
	!=
	bz *if1_end

	// *if1_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:196
	// nonAlgoRewardMBR += ASSET_HOLDING_FEE
	frame_dig 0 // nonAlgoRewardMBR: uint64
	intc 8 // 100000
	+
	frame_bury 0 // nonAlgoRewardMBR: uint64

*if1_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:198
	// poolMBR =
	//       ALGORAND_ACCOUNT_MIN_BALANCE +
	//       nonAlgoRewardMBR +
	//       this.costForBoxStorage(7 + len<StakeInfo>() * MAX_STAKERS_PER_POOL) +
	//       this.costForBoxStorage(7 + len<uint64>() * 15)
	intc 8 // 100000
	frame_dig 0 // nonAlgoRewardMBR: uint64
	+
	intc 12 // 28007
	callsub costForBoxStorage
	+
	intc 13 // 127
	callsub costForBoxStorage
	+
	frame_bury 1 // poolMBR: uint64

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:205
	// verifyPayTxn(mbrPayment, { receiver: this.app.address, amount: poolMBR })
	// verify receiver
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Amount
	frame_dig 1 // poolMBR: uint64
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"amount","expected":"poolMBR"}
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:206
	// this.stakers.create()
	bytec 2 //  "stakers"
	pushint 28000
	box_create
	pop

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:207
	// this.minimumBalance.value = poolMBR
	pushbytes 0x6d696e696d756d42616c616e6365 // "minimumBalance"
	frame_dig 1 // poolMBR: uint64
	app_global_put

	// *if2_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:209
	// this.rewardAssetId.value !== 0
	bytec 4 //  "rewardAssetId"
	app_global_get
	intc 0 // 0
	!=
	bz *if2_end

	// *if2_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:211
	// sendAssetTransfer({
	//         xferAsset: AssetID.fromUint64(this.rewardAssetId.value),
	//         assetReceiver: this.app.address,
	//         assetAmount: 0,
	//         fee: 0,
	//       })
	itxn_begin
	intc 7 //  axfer
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:212
	// xferAsset: AssetID.fromUint64(this.rewardAssetId.value)
	bytec 4 //  "rewardAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:213
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:214
	// assetAmount: 0
	intc 0 // 0
	itxn_field AssetAmount

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:215
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if2_end:
	retsub

// injectRewards(axfer,uint64,uint64)void
*abi_route_injectRewards:
	// rewardAssetId: uint64
	txna ApplicationArgs 2
	btoi

	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// rewardTxn: axfer
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 7 //  axfer
	==

	// argument 2 (rewardTxn) for injectRewards must be a axfer transaction
	assert

	// execute injectRewards(axfer,uint64,uint64)void
	callsub injectRewards
	intc 1 // 1
	return

// injectRewards(rewardTxn: AssetTransferTxn, quantity: uint64, rewardAssetId: uint64): void
injectRewards:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:225
	// verifyAssetTransferTxn(rewardTxn, {
	//       assetReceiver: this.app.address,
	//       xferAsset: AssetID.fromUint64(this.rewardAssetId.value),
	//       assetAmount: quantity,
	//     })
	// verify assetReceiver
	frame_dig -1 // rewardTxn: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"rewardTxn","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig -1 // rewardTxn: AssetTransferTxn
	gtxns XferAsset
	bytec 4 //  "rewardAssetId"
	app_global_get
	==

	// transaction verification failed: {"txn":"rewardTxn","field":"xferAsset","expected":"AssetID.fromUint64(this.rewardAssetId.value)"}
	assert

	// verify assetAmount
	frame_dig -1 // rewardTxn: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -2 // quantity: uint64
	==

	// transaction verification failed: {"txn":"rewardTxn","field":"assetAmount","expected":"quantity"}
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:232
	// platformFee = wideRatio([quantity, this.platformFeeBps.value], [10000])
	frame_dig -2 // quantity: uint64
	bytec 20 //  "platformFeeBps"
	app_global_get
	mulw
	intc 0 // 0
	intc 11 // 10000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 0 // platformFee: uint64

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:234
	// this.injectedASARewards.value = this.injectedASARewards.value + quantity - platformFee
	bytec 8 //  "injectedASARewards"
	dup
	app_global_get
	frame_dig -2 // quantity: uint64
	+
	frame_dig 0 // platformFee: uint64
	-
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:235
	// this.lastInjectionTime.value = globals.latestTimestamp
	bytec 18 //  "lastInjectionTime"
	global LatestTimestamp
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:236
	// this.sendPlatformFees(platformFee)
	frame_dig 0 // platformFee: uint64
	callsub sendPlatformFees

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:237
	// this.accrueRewards()
	callsub accrueRewards
	retsub

// sendPlatformFees(platformFee: uint64): void
sendPlatformFees:
	proto 1 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:241
	// sendAssetTransfer({
	//       assetAmount: platformFee,
	//       assetReceiver: this.treasuryAddress.value,
	//       xferAsset: AssetID.fromUint64(this.rewardAssetId.value),
	//       sender: this.app.address,
	//       fee: 0,
	//     })
	itxn_begin
	intc 7 //  axfer
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:242
	// assetAmount: platformFee
	frame_dig -1 // platformFee: uint64
	itxn_field AssetAmount

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:243
	// assetReceiver: this.treasuryAddress.value
	bytec 19 //  "treasuryAddress"
	app_global_get
	itxn_field AssetReceiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:244
	// xferAsset: AssetID.fromUint64(this.rewardAssetId.value)
	bytec 4 //  "rewardAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:245
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:246
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:248
	// this.paidPlatformFees.value = this.paidPlatformFees.value + platformFee
	bytec 21 //  "paidPlatformFees"
	dup
	app_global_get
	frame_dig -1 // platformFee: uint64
	+
	app_global_put
	retsub

// pickupRewards(): void
pickupRewards:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 3

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:252
	// appAssetBalance = this.app.address.assetBalance(this.rewardAssetId.value)
	global CurrentApplicationAddress
	bytec 4 //  "rewardAssetId"
	app_global_get
	asset_holding_get AssetBalance
	pop
	frame_bury 0 // appAssetBalance: uint64

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:253
	// stakeTokenAmount = 0
	intc 0 // 0
	frame_bury 1 // stakeTokenAmount: uint64

	// *if3_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:254
	// this.rewardAssetId.value === this.stakedAssetId.value
	bytec 4 //  "rewardAssetId"
	app_global_get
	bytec 14 //  "stakedAssetId"
	app_global_get
	==
	bz *if3_end

	// *if3_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:255
	// stakeTokenAmount = this.totalStaked.value
	bytec 5 //  "totalStaked"
	app_global_get
	frame_bury 1 // stakeTokenAmount: uint64

*if3_end:
	// *if4_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:258
	// appAssetBalance > this.paidASARewards.value + this.injectedASARewards.value + stakeTokenAmount
	frame_dig 0 // appAssetBalance: uint64
	bytec 12 //  "paidASARewards"
	app_global_get
	bytec 8 //  "injectedASARewards"
	app_global_get
	+
	frame_dig 1 // stakeTokenAmount: uint64
	+
	>
	bz *if4_end

	// *if4_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:259
	// amount = appAssetBalance - this.paidASARewards.value - stakeTokenAmount - this.injectedASARewards.value
	frame_dig 0 // appAssetBalance: uint64
	bytec 12 //  "paidASARewards"
	app_global_get
	-
	frame_dig 1 // stakeTokenAmount: uint64
	-
	bytec 8 //  "injectedASARewards"
	app_global_get
	-
	frame_bury 2 // amount: uint64

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:261
	// platformFee = wideRatio([amount, this.platformFeeBps.value], [10000])
	frame_dig 2 // amount: uint64
	bytec 20 //  "platformFeeBps"
	app_global_get
	mulw
	intc 0 // 0
	intc 11 // 10000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 3 // platformFee: uint64

	// *if5_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:263
	// amount > this.numStakers.value
	frame_dig 2 // amount: uint64
	bytec 3 //  "numStakers"
	app_global_get
	>
	bz *if5_end

	// *if5_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:264
	// this.injectedASARewards.value = this.injectedASARewards.value + amount - platformFee
	bytec 8 //  "injectedASARewards"
	dup
	app_global_get
	frame_dig 2 // amount: uint64
	+
	frame_dig 3 // platformFee: uint64
	-
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:265
	// this.sendPlatformFees(platformFee)
	frame_dig 3 // platformFee: uint64
	callsub sendPlatformFees

*if5_end:

*if4_end:
	retsub

// injectxUSD(axfer,uint64)void
*abi_route_injectxUSD:
	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// xUSDTxn: axfer
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 7 //  axfer
	==

	// argument 1 (xUSDTxn) for injectxUSD must be a axfer transaction
	assert

	// execute injectxUSD(axfer,uint64)void
	callsub injectxUSD
	intc 1 // 1
	return

// injectxUSD(xUSDTxn: AssetTransferTxn, quantity: uint64): void
injectxUSD:
	proto 2 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:271
	// verifyAssetTransferTxn(xUSDTxn, {
	//       assetReceiver: this.app.address,
	//       xferAsset: AssetID.fromUint64(this.xUSDAssetId.value),
	//       assetAmount: quantity,
	//     })
	// verify assetReceiver
	frame_dig -1 // xUSDTxn: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"xUSDTxn","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig -1 // xUSDTxn: AssetTransferTxn
	gtxns XferAsset
	bytec 13 //  "xUSDAssetId"
	app_global_get
	==

	// transaction verification failed: {"txn":"xUSDTxn","field":"xferAsset","expected":"AssetID.fromUint64(this.xUSDAssetId.value)"}
	assert

	// verify assetAmount
	frame_dig -1 // xUSDTxn: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -2 // quantity: uint64
	==

	// transaction verification failed: {"txn":"xUSDTxn","field":"assetAmount","expected":"quantity"}
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:276
	// this.injectedxUSDRewards.value = this.injectedxUSDRewards.value + quantity
	bytec 9 //  "injectedxUSDRewards"
	dup
	app_global_get
	frame_dig -2 // quantity: uint64
	+
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:277
	// this.lastInjectionTime.value = globals.latestTimestamp
	bytec 18 //  "lastInjectionTime"
	global LatestTimestamp
	app_global_put

	// *if6_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:278
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 3 // 300
	<
	bz *if6_end

	// *if6_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:279
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 0 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 4 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if6_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:281
	// this.pickupRewards()
	callsub pickupRewards

	// *if7_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:282
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 3 // 300
	<
	bz *if7_end

	// *if7_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:283
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 0 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 4 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if7_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:285
	// this.accrueRewards()
	callsub accrueRewards
	retsub

// deleteApplication()void
*abi_route_deleteApplication:
	// execute deleteApplication()void
	callsub deleteApplication
	intc 1 // 1
	return

// deleteApplication(): void
deleteApplication:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dup

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:289
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can delete application')
	txn Sender
	bytec 7 //  "adminAddress"
	app_global_get
	==

	// Only admin can delete application
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:290
	// assert(this.totalStaked.value === 0, 'Staked assets still exist')
	bytec 5 //  "totalStaked"
	app_global_get
	intc 0 // 0
	==

	// Staked assets still exist
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:292
	// this.stakers.delete()
	bytec 2 //  "stakers"
	box_del

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:293
	// rewardBalance = this.app.address.assetBalance(this.rewardAssetId.value)
	global CurrentApplicationAddress
	bytec 4 //  "rewardAssetId"
	app_global_get
	asset_holding_get AssetBalance
	pop
	frame_bury 0 // rewardBalance: uint64

	// *if8_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:294
	// rewardBalance > 0
	frame_dig 0 // rewardBalance: uint64
	intc 0 // 0
	>
	bz *if8_end

	// *if8_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:295
	// sendAssetTransfer({
	//         xferAsset: AssetID.fromUint64(this.rewardAssetId.value),
	//         assetReceiver: this.adminAddress.value,
	//         assetAmount: rewardBalance,
	//         assetCloseTo: this.adminAddress.value,
	//         fee: 0,
	//       })
	itxn_begin
	intc 7 //  axfer
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:296
	// xferAsset: AssetID.fromUint64(this.rewardAssetId.value)
	bytec 4 //  "rewardAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:297
	// assetReceiver: this.adminAddress.value
	bytec 7 //  "adminAddress"
	app_global_get
	itxn_field AssetReceiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:298
	// assetAmount: rewardBalance
	frame_dig 0 // rewardBalance: uint64
	itxn_field AssetAmount

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:299
	// assetCloseTo: this.adminAddress.value
	bytec 7 //  "adminAddress"
	app_global_get
	itxn_field AssetCloseTo

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:300
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if8_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:303
	// paymentAmount = this.app.address.balance - this.app.address.minBalance - 2000
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	pop
	-
	intc 10 // 2000
	-
	frame_bury 1 // paymentAmount: uint64

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:305
	// sendPayment({
	//       amount: paymentAmount,
	//       receiver: this.adminAddress.value,
	//       sender: this.app.address,
	//       fee: 0,
	//     })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:306
	// amount: paymentAmount
	frame_dig 1 // paymentAmount: uint64
	itxn_field Amount

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:307
	// receiver: this.adminAddress.value
	bytec 7 //  "adminAddress"
	app_global_get
	itxn_field Receiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:308
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:309
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// stake(axfer,uint64)void
*abi_route_stake:
	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// stakeTxn: axfer
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 7 //  axfer
	==

	// argument 1 (stakeTxn) for stake must be a axfer transaction
	assert

	// execute stake(axfer,uint64)void
	callsub stake
	intc 1 // 1
	return

// stake(stakeTxn: AssetTransferTxn, quantity: uint64): void
stake:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 2

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:314
	// assert(quantity > 0, 'Invalid quantity')
	frame_dig -2 // quantity: uint64
	intc 0 // 0
	>

	// Invalid quantity
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:315
	// assert(this.poolActive.value, 'Pool not active')
	bytec 15 //  "poolActive"
	app_global_get
	intc 0 // 0
	getbit

	// Pool not active
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:316
	// assert(!this.poolEnding.value, 'Pool ending')
	bytec 16 //  "poolEnding"
	app_global_get
	intc 0 // 0
	getbit
	!

	// Pool ending
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:318
	// this.pickupRewards()
	callsub pickupRewards

	// *if9_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:319
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 3 // 300
	<
	bz *if9_end

	// *if9_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:320
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 0 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 4 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if9_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:322
	// this.accrueRewards()
	callsub accrueRewards

	// *if10_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:324
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 3 // 300
	<
	bz *if10_end

	// *if10_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:325
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 0 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 4 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if10_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:327
	// verifyAssetTransferTxn(stakeTxn, {
	//       sender: this.txn.sender,
	//       assetReceiver: this.app.address,
	//       xferAsset: AssetID.fromUint64(this.stakedAssetId.value),
	//       assetAmount: quantity,
	//     })
	// verify sender
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"stakeTxn","field":"sender","expected":"this.txn.sender"}
	assert

	// verify assetReceiver
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"stakeTxn","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns XferAsset
	bytec 14 //  "stakedAssetId"
	app_global_get
	==

	// transaction verification failed: {"txn":"stakeTxn","field":"xferAsset","expected":"AssetID.fromUint64(this.stakedAssetId.value)"}
	assert

	// verify assetAmount
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -2 // quantity: uint64
	==

	// transaction verification failed: {"txn":"stakeTxn","field":"assetAmount","expected":"quantity"}
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:333
	// actionComplete: boolean = false
	intc 0 // 0
	frame_bury 0 // actionComplete: boolean

	// *if11_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:334
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 3 // 300
	<
	bz *if11_end

	// *if11_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:335
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 0 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 4 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if11_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:337
	// for (let i = 0; i < this.stakers.value.length; i += 1)
	intc 0 // 0
	frame_bury 1 // i: uint64

*for_0:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:337
	// i < this.stakers.value.length
	frame_dig 1 // i: uint64
	pushint 500
	<
	bz *for_0_end

	// *if12_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:338
	// actionComplete
	frame_dig 0 // actionComplete: boolean
	bz *if12_end

	// *if12_consequent
	b *for_0_end

*if12_end:
	// *if13_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:340
	// this.stakers.value[i].account === this.txn.sender
	frame_dig 1 // i: uint64
	intc 5 // 56
	* // acc * typeLength
	intc 0 // 0
	+
	intc 6 // 32
	bytec 2 //  "stakers"
	cover 2
	box_extract
	txn Sender
	==
	bz *if13_elseif1_condition

	// *if13_consequent
	// *if14_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:343
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 3 // 300
	<
	bz *if14_end

	// *if14_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:344
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 0 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 4 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if14_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:347
	// staker = clone(this.stakers.value[i])
	frame_dig 1 // i: uint64
	intc 5 // 56
	* // acc * typeLength
	intc 5 // 56
	bytec 2 //  "stakers"
	cover 2
	box_extract
	frame_bury 2 // staker: (address,uint64,uint64,uint64)

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:348
	// staker.stake += stakeTxn.assetAmount
	frame_dig 2 // staker: (address,uint64,uint64,uint64)
	intc 6 //  headOffset
	frame_dig 2 // staker: (address,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns AssetAmount
	+
	itob
	replace3
	frame_bury 2 // staker: (address,uint64,uint64,uint64)

	// *if15_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:350
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 3 // 300
	<
	bz *if15_end

	// *if15_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:351
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 0 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 4 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if15_end:
	// *if16_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:353
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 3 // 300
	<
	bz *if16_end

	// *if16_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:354
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 0 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 4 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if16_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:356
	// this.stakers.value[i] = staker
	frame_dig 1 // i: uint64
	intc 5 // 56
	* // acc * typeLength
	frame_dig 2 // staker: (address,uint64,uint64,uint64)
	bytec 2 //  "stakers"
	cover 2
	box_replace

	// *if17_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:357
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 3 // 300
	<
	bz *if17_end

	// *if17_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:358
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 0 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 4 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if17_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:360
	// this.totalStaked.value += stakeTxn.assetAmount
	bytec 5 //  "totalStaked"
	app_global_get
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns AssetAmount
	+
	bytec 5 //  "totalStaked"
	swap
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:361
	// actionComplete = true
	intc 1 // 1
	frame_bury 0 // actionComplete: boolean
	b *if13_end

*if13_elseif1_condition:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:362
	// this.stakers.value[i].account === globals.zeroAddress
	frame_dig 1 // i: uint64
	intc 5 // 56
	* // acc * typeLength
	intc 0 // 0
	+
	intc 6 // 32
	bytec 2 //  "stakers"
	cover 2
	box_extract
	global ZeroAddress
	==
	bz *if13_end

	// *if13_elseif1_consequent
	// *if18_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:363
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 3 // 300
	<
	bz *if18_end

	// *if18_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:364
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 0 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 4 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if18_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:366
	// this.totalStaked.value = this.totalStaked.value + stakeTxn.assetAmount
	bytec 5 //  "totalStaked"
	dup
	app_global_get
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns AssetAmount
	+
	app_global_put

	// *if19_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:367
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 3 // 300
	<
	bz *if19_end

	// *if19_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:368
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 0 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 4 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if19_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:370
	// this.stakers.value[i] = {
	//           account: this.txn.sender,
	//           stake: stakeTxn.assetAmount,
	//           accruedASARewards: 0,
	//           accruedxUSDRewards: 0,
	//         }
	frame_dig 1 // i: uint64
	intc 5 // 56
	* // acc * typeLength
	txn Sender
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns AssetAmount
	itob
	concat
	bytec 6 // 0x0000000000000000
	concat
	bytec 6 // 0x0000000000000000
	concat
	bytec 2 //  "stakers"
	cover 2
	box_replace

	// *if20_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:376
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 3 // 300
	<
	bz *if20_end

	// *if20_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:377
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 0 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 4 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if20_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:379
	// this.numStakers.value = this.numStakers.value + 1
	bytec 3 //  "numStakers"
	dup
	app_global_get
	intc 1 // 1
	+
	app_global_put

	// *if21_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:380
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 3 // 300
	<
	bz *if21_end

	// *if21_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:381
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 0 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 4 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if21_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:383
	// actionComplete = true
	intc 1 // 1
	frame_bury 0 // actionComplete: boolean

*if13_end:
	// *if22_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:386
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 3 // 300
	<
	bz *if22_end

	// *if22_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:387
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 0 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 4 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if22_end:

*for_0_continue:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:337
	// i += 1
	frame_dig 1 // i: uint64
	intc 1 // 1
	+
	frame_bury 1 // i: uint64
	b *for_0

*for_0_end:
	retsub

// accrueRewards()void
*abi_route_accrueRewards:
	// execute accrueRewards()void
	callsub accrueRewards
	intc 1 // 1
	return

// accrueRewards(): void
accrueRewards:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 7

	// *if23_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:393
	// !this.freeze.value && !this.poolEnding.value && this.poolActive.value
	bytec 17 //  "freeze"
	app_global_get
	intc 0 // 0
	getbit
	!
	dup
	bz *skip_and0
	bytec 16 //  "poolEnding"
	app_global_get
	intc 0 // 0
	getbit
	!
	&&

*skip_and0:
	dup
	bz *skip_and1
	bytec 15 //  "poolActive"
	app_global_get
	intc 0 // 0
	getbit
	&&

*skip_and1:
	bz *if23_end

	// *if23_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:394
	// additionalASARewards = this.injectedASARewards.value
	bytec 8 //  "injectedASARewards"
	app_global_get
	frame_bury 0 // additionalASARewards: uint64

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:395
	// xUSDRewards = this.injectedxUSDRewards.value
	bytec 9 //  "injectedxUSDRewards"
	app_global_get
	frame_bury 1 // xUSDRewards: uint64

	// *if24_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:397
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 3 // 300
	<
	bz *if24_end

	// *if24_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:398
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 0 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 4 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if24_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:401
	// for (let i = 0; i < this.numStakers.value; i += 1)
	intc 0 // 0
	frame_bury 2 // i: uint64

*for_1:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:401
	// i < this.numStakers.value
	frame_dig 2 // i: uint64
	bytec 3 //  "numStakers"
	app_global_get
	<
	bz *for_1_end

	// *if25_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:402
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 3 // 300
	<
	bz *if25_end

	// *if25_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:403
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 0 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 4 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if25_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:405
	// stake = this.stakers.value[i].stake
	frame_dig 2 // i: uint64
	intc 5 // 56
	* // acc * typeLength
	intc 6 //  headOffset
	+
	pushint 8
	bytec 2 //  "stakers"
	cover 2
	box_extract
	btoi
	frame_bury 3 // stake: uint64

	// *if26_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:407
	// stake > 0
	frame_dig 3 // stake: uint64
	intc 0 // 0
	>
	bz *if26_end

	// *if26_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:408
	// staker = clone(this.stakers.value[i])
	frame_dig 2 // i: uint64
	intc 5 // 56
	* // acc * typeLength
	intc 5 // 56
	bytec 2 //  "stakers"
	cover 2
	box_extract
	frame_bury 4 // staker: (address,uint64,uint64,uint64)

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:410
	// stakerShare = wideRatio([stake, PRECISION], [this.totalStaked.value])
	frame_dig 3 // stake: uint64
	intc 9 // 1000000000000000
	mulw
	intc 0 // 0
	bytec 5 //  "totalStaked"
	app_global_get
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 5 // stakerShare: uint64

	// *if27_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:412
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 3 // 300
	<
	bz *if27_end

	// *if27_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:413
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 0 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 4 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if27_end:
	// *if28_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:416
	// additionalASARewards > this.numStakers.value
	frame_dig 0 // additionalASARewards: uint64
	bytec 3 //  "numStakers"
	app_global_get
	>
	bz *if28_end

	// *if28_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:417
	// rewardRate = wideRatio([additionalASARewards, stakerShare], [PRECISION])
	frame_dig 0 // additionalASARewards: uint64
	frame_dig 5 // stakerShare: uint64
	mulw
	intc 0 // 0
	intc 9 // 1000000000000000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 6 // rewardRate: uint64

	// *if29_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:418
	// rewardRate === 0
	frame_dig 6 // rewardRate: uint64
	intc 0 // 0
	==
	bz *if29_end

	// *if29_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:419
	// rewardRate = 1
	intc 1 // 1
	frame_bury 6 // rewardRate: uint64

*if29_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:422
	// this.injectedASARewards.value = this.injectedASARewards.value - rewardRate
	bytec 8 //  "injectedASARewards"
	dup
	app_global_get
	frame_dig 6 // rewardRate: uint64
	-
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:423
	// this.paidASARewards.value = this.paidASARewards.value + rewardRate
	bytec 12 //  "paidASARewards"
	dup
	app_global_get
	frame_dig 6 // rewardRate: uint64
	+
	app_global_put

	// *if30_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:424
	// this.rewardAssetId.value === this.stakedAssetId.value
	bytec 4 //  "rewardAssetId"
	app_global_get
	bytec 14 //  "stakedAssetId"
	app_global_get
	==
	bz *if30_else

	// *if30_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:427
	// staker.stake = staker.stake + rewardRate
	frame_dig 4 // staker: (address,uint64,uint64,uint64)
	intc 6 //  headOffset
	frame_dig 4 // staker: (address,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig 6 // rewardRate: uint64
	+
	itob
	replace3
	frame_bury 4 // staker: (address,uint64,uint64,uint64)

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:428
	// this.totalStaked.value = this.totalStaked.value + rewardRate
	bytec 5 //  "totalStaked"
	dup
	app_global_get
	frame_dig 6 // rewardRate: uint64
	+
	app_global_put
	b *if30_end

*if30_else:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:430
	// staker.accruedASARewards = staker.accruedASARewards + rewardRate
	frame_dig 4 // staker: (address,uint64,uint64,uint64)
	pushint 40 // headOffset
	frame_dig 4 // staker: (address,uint64,uint64,uint64)
	extract 40 8
	btoi
	frame_dig 6 // rewardRate: uint64
	+
	itob
	replace3
	frame_bury 4 // staker: (address,uint64,uint64,uint64)

*if30_end:

*if28_end:
	// *if31_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:433
	// xUSDRewards > 0
	frame_dig 1 // xUSDRewards: uint64
	intc 0 // 0
	>
	bz *if31_end

	// *if31_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:434
	// rewardRate = wideRatio([xUSDRewards, stakerShare], [PRECISION])
	frame_dig 1 // xUSDRewards: uint64
	frame_dig 5 // stakerShare: uint64
	mulw
	intc 0 // 0
	intc 9 // 1000000000000000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 7 // rewardRate: uint64

	// *if32_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:435
	// rewardRate === 0
	frame_dig 7 // rewardRate: uint64
	intc 0 // 0
	==
	bz *if32_end

	// *if32_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:436
	// rewardRate = 1
	intc 1 // 1
	frame_bury 7 // rewardRate: uint64

*if32_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:439
	// this.injectedxUSDRewards.value = this.injectedxUSDRewards.value - rewardRate
	bytec 9 //  "injectedxUSDRewards"
	dup
	app_global_get
	frame_dig 7 // rewardRate: uint64
	-
	app_global_put

	// *if33_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:440
	// this.xUSDAssetId.value === this.stakedAssetId.value
	bytec 13 //  "xUSDAssetId"
	app_global_get
	bytec 14 //  "stakedAssetId"
	app_global_get
	==
	bz *if33_else

	// *if33_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:443
	// staker.stake = staker.stake + rewardRate
	frame_dig 4 // staker: (address,uint64,uint64,uint64)
	intc 6 //  headOffset
	frame_dig 4 // staker: (address,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig 7 // rewardRate: uint64
	+
	itob
	replace3
	frame_bury 4 // staker: (address,uint64,uint64,uint64)

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:444
	// this.totalStaked.value = this.totalStaked.value + rewardRate
	bytec 5 //  "totalStaked"
	dup
	app_global_get
	frame_dig 7 // rewardRate: uint64
	+
	app_global_put
	b *if33_end

*if33_else:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:446
	// staker.accruedxUSDRewards = staker.accruedxUSDRewards + rewardRate
	frame_dig 4 // staker: (address,uint64,uint64,uint64)
	pushint 48 // headOffset
	frame_dig 4 // staker: (address,uint64,uint64,uint64)
	extract 48 8
	btoi
	frame_dig 7 // rewardRate: uint64
	+
	itob
	replace3
	frame_bury 4 // staker: (address,uint64,uint64,uint64)

*if33_end:

*if31_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:449
	// this.stakers.value[i] = staker
	frame_dig 2 // i: uint64
	intc 5 // 56
	* // acc * typeLength
	frame_dig 4 // staker: (address,uint64,uint64,uint64)
	bytec 2 //  "stakers"
	cover 2
	box_replace

*if26_end:

*for_1_continue:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:401
	// i += 1
	frame_dig 2 // i: uint64
	intc 1 // 1
	+
	frame_bury 2 // i: uint64
	b *for_1

*for_1_end:
	// *if34_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:452
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 3 // 300
	<
	bz *if34_end

	// *if34_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:453
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 0 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 4 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if34_end:
	// *if35_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:456
	// this.injectedxUSDRewards.value > 0
	bytec 9 //  "injectedxUSDRewards"
	app_global_get
	intc 0 // 0
	>
	bz *if35_end

	// *if35_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:457
	// sendAssetTransfer({
	//           xferAsset: AssetID.fromUint64(this.xUSDAssetId.value),
	//           assetReceiver: this.txn.sender,
	//           assetAmount: this.injectedxUSDRewards.value,
	//           fee: 0,
	//         })
	itxn_begin
	intc 7 //  axfer
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:458
	// xferAsset: AssetID.fromUint64(this.xUSDAssetId.value)
	bytec 13 //  "xUSDAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:459
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:460
	// assetAmount: this.injectedxUSDRewards.value
	bytec 9 //  "injectedxUSDRewards"
	app_global_get
	itxn_field AssetAmount

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:461
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if35_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:465
	// this.injectedxUSDRewards.value = 0
	bytec 9 //  "injectedxUSDRewards"
	intc 0 // 0
	app_global_put

*if23_end:
	retsub

// getStaker(address: Address): StakeInfo
getStaker:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:470
	// for (let i = 0; i < this.numStakers.value; i += 1)
	intc 0 // 0
	frame_bury 0 // i: uint64

*for_2:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:470
	// i < this.numStakers.value
	frame_dig 0 // i: uint64
	bytec 3 //  "numStakers"
	app_global_get
	<
	bz *for_2_end

	// *if36_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:471
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 3 // 300
	<
	bz *if36_end

	// *if36_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:472
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 0 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 4 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if36_end:
	// *if37_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:474
	// this.stakers.value[i].account === address
	frame_dig 0 // i: uint64
	intc 5 // 56
	* // acc * typeLength
	intc 0 // 0
	+
	intc 6 // 32
	bytec 2 //  "stakers"
	cover 2
	box_extract
	frame_dig -1 // address: Address
	==
	bz *if37_end

	// *if37_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:475
	// return clone(this.stakers.value[i]);
	frame_dig 0 // i: uint64
	intc 5 // 56
	* // acc * typeLength
	intc 5 // 56
	bytec 2 //  "stakers"
	cover 2
	box_extract
	b *getStaker*return

*if37_end:

*for_2_continue:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:470
	// i += 1
	frame_dig 0 // i: uint64
	intc 1 // 1
	+
	frame_bury 0 // i: uint64
	b *for_2

*for_2_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:478
	// return {
	//       account: globals.zeroAddress,
	//       stake: 0,
	//       accruedASARewards: 0,
	//       accruedxUSDRewards: 0,
	//     };
	global ZeroAddress
	bytec 6 // 0x0000000000000000
	concat
	bytec 6 // 0x0000000000000000
	concat
	bytec 6 // 0x0000000000000000
	concat

*getStaker*return:
	// set the subroutine return value
	frame_bury 0
	retsub

// claimRewards()void
*abi_route_claimRewards:
	// execute claimRewards()void
	callsub claimRewards
	intc 1 // 1
	return

// claimRewards(): void
claimRewards:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:487
	// this.pickupRewards()
	callsub pickupRewards

	// *if38_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:488
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 3 // 300
	<
	bz *if38_end

	// *if38_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:489
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 0 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 4 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if38_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:491
	// this.accrueRewards()
	callsub accrueRewards

	// *if39_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:492
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 3 // 300
	<
	bz *if39_end

	// *if39_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:493
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 0 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 4 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if39_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:495
	// staker = this.getStaker(this.txn.sender)
	txn Sender
	callsub getStaker
	frame_bury 0 // staker: (address,uint64,uint64,uint64)

	// *if40_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:497
	// staker.accruedASARewards > 0
	frame_dig 0 // staker: (address,uint64,uint64,uint64)
	extract 40 8
	btoi
	intc 0 // 0
	>
	bz *if40_end

	// *if40_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:498
	// sendAssetTransfer({
	//         xferAsset: AssetID.fromUint64(this.rewardAssetId.value),
	//         assetReceiver: this.txn.sender,
	//         sender: this.app.address,
	//         assetAmount: staker.accruedASARewards,
	//         fee: 0,
	//       })
	itxn_begin
	intc 7 //  axfer
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:499
	// xferAsset: AssetID.fromUint64(this.rewardAssetId.value)
	bytec 4 //  "rewardAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:500
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:501
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:502
	// assetAmount: staker.accruedASARewards
	frame_dig 0 // staker: (address,uint64,uint64,uint64)
	extract 40 8
	btoi
	itxn_field AssetAmount

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:503
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:505
	// this.paidASARewards.value = this.paidASARewards.value - staker.accruedASARewards
	bytec 12 //  "paidASARewards"
	dup
	app_global_get
	frame_dig 0 // staker: (address,uint64,uint64,uint64)
	extract 40 8
	btoi
	-
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:506
	// staker.accruedASARewards = 0
	frame_dig 0 // staker: (address,uint64,uint64,uint64)
	bytec 6 // 0x0000000000000000
	replace2 40
	frame_bury 0 // staker: (address,uint64,uint64,uint64)

*if40_end:
	// *if41_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:508
	// staker.accruedxUSDRewards > 0
	frame_dig 0 // staker: (address,uint64,uint64,uint64)
	extract 48 8
	btoi
	intc 0 // 0
	>
	bz *if41_end

	// *if41_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:509
	// sendAssetTransfer({
	//         xferAsset: AssetID.fromUint64(this.xUSDAssetId.value),
	//         assetReceiver: this.txn.sender,
	//         sender: this.app.address,
	//         assetAmount: staker.accruedxUSDRewards,
	//         fee: 0,
	//       })
	itxn_begin
	intc 7 //  axfer
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:510
	// xferAsset: AssetID.fromUint64(this.xUSDAssetId.value)
	bytec 13 //  "xUSDAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:511
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:512
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:513
	// assetAmount: staker.accruedxUSDRewards
	frame_dig 0 // staker: (address,uint64,uint64,uint64)
	extract 48 8
	btoi
	itxn_field AssetAmount

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:514
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:516
	// staker.accruedxUSDRewards = 0
	frame_dig 0 // staker: (address,uint64,uint64,uint64)
	bytec 6 // 0x0000000000000000
	replace2 48
	frame_bury 0 // staker: (address,uint64,uint64,uint64)

*if41_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:519
	// this.setStaker(staker.account, staker)
	frame_dig 0 // staker: (address,uint64,uint64,uint64)
	frame_dig 0 // staker: (address,uint64,uint64,uint64)
	extract 0 32
	callsub setStaker

	// *if42_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:520
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 3 // 300
	<
	bz *if42_end

	// *if42_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:521
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 0 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 4 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if42_end:
	retsub

// unstake(uint64)void
*abi_route_unstake:
	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// execute unstake(uint64)void
	callsub unstake
	intc 1 // 1
	return

// unstake(quantity: uint64): void
unstake:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 4

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:526
	// this.pickupRewards()
	callsub pickupRewards

	// *if43_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:527
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 3 // 300
	<
	bz *if43_end

	// *if43_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:528
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 0 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 4 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if43_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:530
	// this.accrueRewards()
	callsub accrueRewards

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:531
	// for (let i = 0; i < this.numStakers.value; i += 1)
	intc 0 // 0
	frame_bury 0 // i: uint64

*for_3:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:531
	// i < this.numStakers.value
	frame_dig 0 // i: uint64
	bytec 3 //  "numStakers"
	app_global_get
	<
	bz *for_3_end

	// *if44_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:532
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 3 // 300
	<
	bz *if44_end

	// *if44_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:533
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 0 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 4 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if44_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:535
	// staker = clone(this.stakers.value[i])
	frame_dig 0 // i: uint64
	intc 5 // 56
	* // acc * typeLength
	intc 5 // 56
	bytec 2 //  "stakers"
	cover 2
	box_extract
	frame_bury 1 // staker: (address,uint64,uint64,uint64)

	// *if45_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:536
	// staker.account === this.txn.sender
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	extract 0 32
	txn Sender
	==
	bz *if45_end

	// *if45_consequent
	// *if46_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:537
	// staker.stake > 0
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	extract 32 8
	btoi
	intc 0 // 0
	>
	bz *if46_end

	// *if46_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:538
	// sendAssetTransfer({
	//             xferAsset: AssetID.fromUint64(this.stakedAssetId.value),
	//             assetReceiver: this.txn.sender,
	//             sender: this.app.address,
	//             assetAmount: quantity === 0 ? staker.stake : quantity,
	//             fee: 0,
	//           })
	itxn_begin
	intc 7 //  axfer
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:539
	// xferAsset: AssetID.fromUint64(this.stakedAssetId.value)
	bytec 14 //  "stakedAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:540
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:541
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:542
	// assetAmount: quantity === 0 ? staker.stake : quantity
	frame_dig -1 // quantity: uint64
	intc 0 // 0
	==
	bz *ternary0_false
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	extract 32 8
	btoi
	b *ternary0_end

*ternary0_false:
	frame_dig -1 // quantity: uint64

*ternary0_end:
	itxn_field AssetAmount

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:543
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if46_end:
	// *if47_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:548
	// staker.accruedASARewards > 0
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	extract 40 8
	btoi
	intc 0 // 0
	>
	bz *if47_end

	// *if47_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:549
	// sendAssetTransfer({
	//             xferAsset: AssetID.fromUint64(this.rewardAssetId.value),
	//             assetReceiver: this.txn.sender,
	//             sender: this.app.address,
	//             assetAmount: staker.accruedASARewards,
	//             fee: 0,
	//           })
	itxn_begin
	intc 7 //  axfer
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:550
	// xferAsset: AssetID.fromUint64(this.rewardAssetId.value)
	bytec 4 //  "rewardAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:551
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:552
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:553
	// assetAmount: staker.accruedASARewards
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	extract 40 8
	btoi
	itxn_field AssetAmount

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:554
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:556
	// staker.accruedASARewards = 0
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	bytec 6 // 0x0000000000000000
	replace2 40
	frame_bury 1 // staker: (address,uint64,uint64,uint64)

*if47_end:
	// *if48_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:560
	// staker.accruedxUSDRewards > 0
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	extract 48 8
	btoi
	intc 0 // 0
	>
	bz *if48_end

	// *if48_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:561
	// sendAssetTransfer({
	//             xferAsset: AssetID.fromUint64(this.xUSDAssetId.value),
	//             assetReceiver: this.txn.sender,
	//             sender: this.app.address,
	//             assetAmount: staker.accruedxUSDRewards,
	//             fee: 0,
	//           })
	itxn_begin
	intc 7 //  axfer
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:562
	// xferAsset: AssetID.fromUint64(this.xUSDAssetId.value)
	bytec 13 //  "xUSDAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:563
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:564
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:565
	// assetAmount: staker.accruedxUSDRewards
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	extract 48 8
	btoi
	itxn_field AssetAmount

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:566
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:568
	// staker.accruedxUSDRewards = 0
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	bytec 6 // 0x0000000000000000
	replace2 48
	frame_bury 1 // staker: (address,uint64,uint64,uint64)

*if48_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:572
	// this.totalStaked.value = this.totalStaked.value - (quantity === 0 ? staker.stake : quantity)
	bytec 5 //  "totalStaked"
	dup
	app_global_get
	frame_dig -1 // quantity: uint64
	intc 0 // 0
	==
	bz *ternary2_false
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	extract 32 8
	btoi
	b *ternary2_end

*ternary2_false:
	frame_dig -1 // quantity: uint64

*ternary2_end:
	-
	app_global_put

	// *if49_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:574
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 3 // 300
	<
	bz *if49_end

	// *if49_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:575
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 0 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 4 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if49_end:
	// *if50_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:578
	// quantity === 0
	frame_dig -1 // quantity: uint64
	intc 0 // 0
	==
	bz *if50_else

	// *if50_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:579
	// removedStaker: StakeInfo = {
	//             account: globals.zeroAddress,
	//             stake: 0,
	//             accruedxUSDRewards: 0,
	//             accruedASARewards: 0,
	//           }
	global ZeroAddress
	bytec 6 // 0x0000000000000000
	concat
	bytec 6 // 0x0000000000000000
	concat
	bytec 6 // 0x0000000000000000
	concat
	frame_bury 2 // removedStaker: StakeInfo

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:585
	// this.setStaker(staker.account, removedStaker)
	frame_dig 2 // removedStaker: StakeInfo
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	extract 0 32
	callsub setStaker

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:589
	// lastStaker = this.getStaker(this.stakers.value[this.numStakers.value - 1].account)
	bytec 3 //  "numStakers"
	app_global_get
	intc 1 // 1
	-
	intc 5 // 56
	* // acc * typeLength
	intc 0 // 0
	+
	intc 6 // 32
	bytec 2 //  "stakers"
	cover 2
	box_extract
	callsub getStaker
	frame_bury 3 // lastStaker: (address,uint64,uint64,uint64)

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:590
	// lastStakerIndex = this.getStakerIndex(this.stakers.value[this.numStakers.value - 1].account)
	bytec 3 //  "numStakers"
	app_global_get
	intc 1 // 1
	-
	intc 5 // 56
	* // acc * typeLength
	intc 0 // 0
	+
	intc 6 // 32
	bytec 2 //  "stakers"
	cover 2
	box_extract
	callsub getStakerIndex
	frame_bury 4 // lastStakerIndex: uint64

	// *if51_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:591
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 3 // 300
	<
	bz *if51_end

	// *if51_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:592
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 0 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 4 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if51_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:594
	// this.setStakerAtIndex(lastStaker, i)
	frame_dig 0 // i: uint64
	frame_dig 3 // lastStaker: (address,uint64,uint64,uint64)
	callsub setStakerAtIndex

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:597
	// this.setStakerAtIndex(removedStaker, lastStakerIndex)
	frame_dig 4 // lastStakerIndex: uint64
	frame_dig 2 // removedStaker: StakeInfo
	callsub setStakerAtIndex

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:598
	// this.numStakers.value = this.numStakers.value - 1
	bytec 3 //  "numStakers"
	dup
	app_global_get
	intc 1 // 1
	-
	app_global_put
	b *if50_end

*if50_else:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:600
	// staker.stake = staker.stake - quantity
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	intc 6 //  headOffset
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig -1 // quantity: uint64
	-
	itob
	replace3
	frame_bury 1 // staker: (address,uint64,uint64,uint64)

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:601
	// staker.accruedASARewards = 0
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	bytec 6 // 0x0000000000000000
	replace2 40
	frame_bury 1 // staker: (address,uint64,uint64,uint64)

*if50_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:603
	// this.setStaker(staker.account, staker)
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	frame_dig 1 // staker: (address,uint64,uint64,uint64)
	extract 0 32
	callsub setStaker

*if45_end:

*for_3_continue:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:531
	// i += 1
	frame_dig 0 // i: uint64
	intc 1 // 1
	+
	frame_bury 0 // i: uint64
	b *for_3

*for_3_end:
	retsub

// getStakerIndex(address: Address): uint64
getStakerIndex:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:609
	// for (let i = 0; i < this.numStakers.value; i += 1)
	intc 0 // 0
	frame_bury 0 // i: uint64

*for_4:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:609
	// i < this.numStakers.value
	frame_dig 0 // i: uint64
	bytec 3 //  "numStakers"
	app_global_get
	<
	bz *for_4_end

	// *if52_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:610
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 3 // 300
	<
	bz *if52_end

	// *if52_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:611
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 0 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 4 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if52_end:
	// *if53_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:613
	// this.stakers.value[i].account === address
	frame_dig 0 // i: uint64
	intc 5 // 56
	* // acc * typeLength
	intc 0 // 0
	+
	intc 6 // 32
	bytec 2 //  "stakers"
	cover 2
	box_extract
	frame_dig -1 // address: Address
	==
	bz *if53_end

	// *if53_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:614
	// return i;
	frame_dig 0 // i: uint64
	b *getStakerIndex*return

*if53_end:

*for_4_continue:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:609
	// i += 1
	frame_dig 0 // i: uint64
	intc 1 // 1
	+
	frame_bury 0 // i: uint64
	b *for_4

*for_4_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:617
	// return 0;
	intc 0 // 0

*getStakerIndex*return:
	// set the subroutine return value
	frame_bury 0
	retsub

// setStaker(stakerAccount: Address, staker: StakeInfo): void
setStaker:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:621
	// for (let i = 0; i < this.numStakers.value; i += 1)
	intc 0 // 0
	frame_bury 0 // i: uint64

*for_5:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:621
	// i < this.numStakers.value
	frame_dig 0 // i: uint64
	bytec 3 //  "numStakers"
	app_global_get
	<
	bz *for_5_end

	// *if54_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:622
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 3 // 300
	<
	bz *if54_end

	// *if54_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:623
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 0 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 4 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if54_end:
	// *if55_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:625
	// this.stakers.value[i].account === stakerAccount
	frame_dig 0 // i: uint64
	intc 5 // 56
	* // acc * typeLength
	intc 0 // 0
	+
	intc 6 // 32
	bytec 2 //  "stakers"
	cover 2
	box_extract
	frame_dig -1 // stakerAccount: Address
	==
	bz *if55_elseif1_condition

	// *if55_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:626
	// this.stakers.value[i] = staker
	frame_dig 0 // i: uint64
	intc 5 // 56
	* // acc * typeLength
	frame_dig -2 // staker: StakeInfo
	bytec 2 //  "stakers"
	cover 2
	box_replace

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:627
	// return;
	retsub
	b *if55_end

*if55_elseif1_condition:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:629
	// this.stakers.value[i].account === globals.zeroAddress
	frame_dig 0 // i: uint64
	intc 5 // 56
	* // acc * typeLength
	intc 0 // 0
	+
	intc 6 // 32
	bytec 2 //  "stakers"
	cover 2
	box_extract
	global ZeroAddress
	==
	bz *if55_end

	// *if55_elseif1_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:630
	// this.stakers.value[i] = staker
	frame_dig 0 // i: uint64
	intc 5 // 56
	* // acc * typeLength
	frame_dig -2 // staker: StakeInfo
	bytec 2 //  "stakers"
	cover 2
	box_replace

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:631
	// return;
	retsub

*if55_end:

*for_5_continue:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:621
	// i += 1
	frame_dig 0 // i: uint64
	intc 1 // 1
	+
	frame_bury 0 // i: uint64
	b *for_5

*for_5_end:
	retsub

// setStakerAtIndex(staker: StakeInfo, index: uint64): void
setStakerAtIndex:
	proto 2 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:637
	// this.stakers.value[index] = staker
	frame_dig -2 // index: uint64
	intc 5 // 56
	* // acc * typeLength
	frame_dig -1 // staker: StakeInfo
	bytec 2 //  "stakers"
	cover 2
	box_replace
	retsub

// setFreeze(bool)void
*abi_route_setFreeze:
	// enabled: bool
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 1
	==

	// argument 0 (enabled) for setFreeze must be a bool
	assert
	intc 0 // 0
	getbit

	// execute setFreeze(bool)void
	callsub setFreeze
	intc 1 // 1
	return

// setFreeze(enabled: boolean): void
setFreeze:
	proto 1 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:641
	// assert(this.txn.sender === this.injectorAddress.value, 'Only injector can freeze payouts')
	txn Sender
	bytec 10 //  "injectorAddress"
	app_global_get
	==

	// Only injector can freeze payouts
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:642
	// this.freeze.value = enabled
	bytec 17 //  "freeze"
	frame_dig -1 // enabled: boolean
	bytec 11 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put
	retsub

// gas()void
*abi_route_gas:
	// execute gas()void
	callsub gas
	intc 1 // 1
	return

// gas(): void
gas:
	proto 0 0
	retsub

*create_NoOp:
	pushbytes 0x35e44c1f // method "createApplication(address,address,address)void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x1c057ab9 // method "initApplication(uint64,uint64,uint64,uint64)void"
	pushbytes 0xa3fea40f // method "updateAdminAddress(address)void"
	pushbytes 0x5f84e60b // method "setPoolActive()void"
	pushbytes 0xb72cf360 // method "setPoolEnding()void"
	pushbytes 0x682ac693 // method "updateInjectedASARewards(uint64)void"
	pushbytes 0xe7fe9cce // method "updatePaidASARewards(uint64)void"
	pushbytes 0xc477a44d // method "updateInjectedxUSDRewards(uint64)void"
	pushbytes 0x1b924159 // method "updateTreasuryAddress(address)void"
	pushbytes 0x2d9d7cab // method "updateInjectorAddress(address)void"
	pushbytes 0xf69dd772 // method "updateNumStakers(uint64)void"
	pushbytes 0xd24963b8 // method "updateFreeze(bool)void"
	pushbytes 0xdb284061 // method "updatePoolEnding(bool)void"
	pushbytes 0x4c436726 // method "getMBRForPoolCreation()(uint64)"
	pushbytes 0x47cfcc04 // method "initStorage(pay)void"
	pushbytes 0x347007eb // method "injectRewards(axfer,uint64,uint64)void"
	pushbytes 0xc6ba8f19 // method "injectxUSD(axfer,uint64)void"
	pushbytes 0xf4eb4a03 // method "stake(axfer,uint64)void"
	pushbytes 0xea4bca57 // method "accrueRewards()void"
	pushbytes 0xa5ae6bd1 // method "claimRewards()void"
	pushbytes 0x813ce89a // method "unstake(uint64)void"
	pushbytes 0xbb6bc6e3 // method "setFreeze(bool)void"
	pushbytes 0x3172ca9d // method "gas()void"
	txna ApplicationArgs 0
	match *abi_route_initApplication *abi_route_updateAdminAddress *abi_route_setPoolActive *abi_route_setPoolEnding *abi_route_updateInjectedASARewards *abi_route_updatePaidASARewards *abi_route_updateInjectedxUSDRewards *abi_route_updateTreasuryAddress *abi_route_updateInjectorAddress *abi_route_updateNumStakers *abi_route_updateFreeze *abi_route_updatePoolEnding *abi_route_getMBRForPoolCreation *abi_route_initStorage *abi_route_injectRewards *abi_route_injectxUSD *abi_route_stake *abi_route_accrueRewards *abi_route_claimRewards *abi_route_unstake *abi_route_setFreeze *abi_route_gas

	// this contract does not implement the given ABI method for call NoOp
	err

*call_DeleteApplication:
	pushbytes 0x2487c32c // method "deleteApplication()void"
	txna ApplicationArgs 0
	match *abi_route_deleteApplication

	// this contract does not implement the given ABI method for call DeleteApplication
	err