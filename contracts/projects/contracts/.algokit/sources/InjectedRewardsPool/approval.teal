#pragma version 9

// This TEAL was generated by TEALScript v0.103.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *call_DeleteApplication *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication(address,address)void
*abi_route_createApplication:
	// injectorAddress: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 0 (injectorAddress) for createApplication must be a address
	assert

	// adminAddress: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (adminAddress) for createApplication must be a address
	assert

	// execute createApplication(address,address)void
	callsub createApplication
	int 1
	return

// createApplication(adminAddress: Address, injectorAddress: Address): void
createApplication:
	proto 2 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:60
	// this.adminAddress.value = adminAddress
	byte 0x61646d696e41646472657373 // "adminAddress"
	frame_dig -1 // adminAddress: Address
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:61
	// this.injectorAddress.value = injectorAddress
	byte 0x696e6a6563746f7241646472657373 // "injectorAddress"
	frame_dig -2 // injectorAddress: Address
	app_global_put
	retsub

// initApplication(uint64,uint64,uint64)void
*abi_route_initApplication:
	// minStakePeriodForRewards: uint64
	txna ApplicationArgs 3
	btoi

	// rewardAssetId: uint64
	txna ApplicationArgs 2
	btoi

	// stakedAsset: uint64
	txna ApplicationArgs 1
	btoi

	// execute initApplication(uint64,uint64,uint64)void
	callsub initApplication
	int 1
	return

// initApplication(stakedAsset: uint64, rewardAssetId: uint64, minStakePeriodForRewards: uint64): void
initApplication:
	proto 3 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:69
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can init application')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can init application
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:71
	// this.stakedAssetId.value = stakedAsset
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	frame_dig -1 // stakedAsset: uint64
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:72
	// this.rewardAssetId.value = rewardAssetId
	byte 0x72657761726441737365744964 // "rewardAssetId"
	frame_dig -2 // rewardAssetId: uint64
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:73
	// this.totalStaked.value = 0
	byte 0x746f74616c5374616b6564 // "totalStaked"
	int 0
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:74
	// this.minStakePeriodForRewards.value = minStakePeriodForRewards
	byte 0x6d696e5374616b65506572696f64466f7252657761726473 // "minStakePeriodForRewards"
	frame_dig -3 // minStakePeriodForRewards: uint64
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:75
	// this.lastRewardInjectionTime.value = 0
	byte 0x6c617374526577617264496e6a656374696f6e54696d65 // "lastRewardInjectionTime"
	int 0
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:76
	// this.freeze.value = false
	byte 0x667265657a65 // "freeze"
	int 0
	byte 0x00
	int 0
	uncover 2
	setbit
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:77
	// this.injectedASARewards.value = 0
	byte 0x696e6a656374656441534152657761726473 // "injectedASARewards"
	int 0
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:78
	// this.numStakers.value = 0
	byte 0x6e756d5374616b657273 // "numStakers"
	int 0
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:79
	// this.algoInjectedRewards.value = 0
	byte 0x616c676f496e6a656374656452657761726473 // "algoInjectedRewards"
	int 0
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:81
	// sendAssetTransfer({
	//       xferAsset: AssetID.fromUint64(stakedAsset),
	//       assetReceiver: this.app.address,
	//       assetAmount: 0,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:82
	// xferAsset: AssetID.fromUint64(stakedAsset)
	frame_dig -1 // stakedAsset: uint64
	itxn_field XferAsset

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:83
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:84
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// updateMinStakePeriod(uint64)void
*abi_route_updateMinStakePeriod:
	// minStakePeriodForRewards: uint64
	txna ApplicationArgs 1
	btoi

	// execute updateMinStakePeriod(uint64)void
	callsub updateMinStakePeriod
	int 1
	return

// updateMinStakePeriod(minStakePeriodForRewards: uint64): void
updateMinStakePeriod:
	proto 1 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:90
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can update min stake period')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can update min stake period
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:91
	// this.minStakePeriodForRewards.value = minStakePeriodForRewards
	byte 0x6d696e5374616b65506572696f64466f7252657761726473 // "minStakePeriodForRewards"
	frame_dig -1 // minStakePeriodForRewards: uint64
	app_global_put
	retsub

// updateAdminAddress(address)void
*abi_route_updateAdminAddress:
	// adminAddress: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (adminAddress) for updateAdminAddress must be a address
	assert

	// execute updateAdminAddress(address)void
	callsub updateAdminAddress
	int 1
	return

// updateAdminAddress(adminAddress: Address): void
updateAdminAddress:
	proto 1 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:94
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can update admin address')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can update admin address
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:95
	// this.adminAddress.value = adminAddress
	byte 0x61646d696e41646472657373 // "adminAddress"
	frame_dig -1 // adminAddress: Address
	app_global_put
	retsub

// updateInjectedASARewards(uint64)void
*abi_route_updateInjectedASARewards:
	// injectedASARewards: uint64
	txna ApplicationArgs 1
	btoi

	// execute updateInjectedASARewards(uint64)void
	callsub updateInjectedASARewards
	int 1
	return

// updateInjectedASARewards(injectedASARewards: uint64): void
updateInjectedASARewards:
	proto 1 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:98
	// assert(this.txn.sender === this.injectorAddress.value, 'Only admin can update injected rewards')
	txn Sender
	byte 0x696e6a6563746f7241646472657373 // "injectorAddress"
	app_global_get
	==

	// Only admin can update injected rewards
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:99
	// this.injectedASARewards.value = injectedASARewards
	byte 0x696e6a656374656441534152657761726473 // "injectedASARewards"
	frame_dig -1 // injectedASARewards: uint64
	app_global_put
	retsub

// updateInjectedAlgoRewards(uint64)void
*abi_route_updateInjectedAlgoRewards:
	// injectedAlgoRewards: uint64
	txna ApplicationArgs 1
	btoi

	// execute updateInjectedAlgoRewards(uint64)void
	callsub updateInjectedAlgoRewards
	int 1
	return

// updateInjectedAlgoRewards(injectedAlgoRewards: uint64): void
updateInjectedAlgoRewards:
	proto 1 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:102
	// assert(this.txn.sender === this.injectorAddress.value, 'Only admin can update injected rewards')
	txn Sender
	byte 0x696e6a6563746f7241646472657373 // "injectorAddress"
	app_global_get
	==

	// Only admin can update injected rewards
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:103
	// this.algoInjectedRewards.value = injectedAlgoRewards
	byte 0x616c676f496e6a656374656452657761726473 // "algoInjectedRewards"
	frame_dig -1 // injectedAlgoRewards: uint64
	app_global_put
	retsub

// costForBoxStorage(totalNumBytes: uint64): uint64
costForBoxStorage:
	proto 1 1

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:110
	// return SCBOX_PERBOX + totalNumBytes * SCBOX_PERBYTE
	int 2500
	frame_dig -1 // totalNumBytes: uint64
	int 400
	*
	+
	retsub

// getMBRForPoolCreation()(uint64)
*abi_route_getMBRForPoolCreation:
	// The ABI return prefix
	byte 0x151f7c75

	// execute getMBRForPoolCreation()(uint64)
	callsub getMBRForPoolCreation
	concat
	log
	int 1
	return

// getMBRForPoolCreation(): mbrReturn
getMBRForPoolCreation:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:114
	// nonAlgoRewardMBR = 0
	int 0
	frame_bury 0 // nonAlgoRewardMBR: uint64

	// *if0_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:115
	// this.rewardAssetId.value !== 0
	byte 0x72657761726441737365744964 // "rewardAssetId"
	app_global_get
	int 0
	!=
	bz *if0_end

	// *if0_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:116
	// nonAlgoRewardMBR += ASSET_HOLDING_FEE
	frame_dig 0 // nonAlgoRewardMBR: uint64
	int 100000
	+
	frame_bury 0 // nonAlgoRewardMBR: uint64

*if0_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:118
	// mbr = ALGORAND_ACCOUNT_MIN_BALANCE +
	//       nonAlgoRewardMBR +
	//       this.costForBoxStorage(7 + len<StakeInfo>() * MAX_STAKERS_PER_POOL) +
	//       this.costForBoxStorage(7 + len<uint64>() * 15)
	int 100000
	frame_dig 0 // nonAlgoRewardMBR: uint64
	+
	int 22007
	callsub costForBoxStorage
	+
	int 127
	callsub costForBoxStorage
	+
	frame_bury 1 // mbr: uint64

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:123
	// return {
	//       mbrPayment: mbr
	//     }
	frame_dig 1 // mbr: uint64
	itob

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// initStorage(pay)void
*abi_route_initStorage:
	// mbrPayment: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==

	// argument 0 (mbrPayment) for initStorage must be a pay transaction
	assert

	// execute initStorage(pay)void
	callsub initStorage
	int 1
	return

// initStorage(mbrPayment: PayTxn): void
initStorage:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:129
	// assert(!this.stakers.exists, 'staking pool already initialized')
	byte 0x7374616b657273 // "stakers"
	box_len
	swap
	pop
	!

	// staking pool already initialized
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:130
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can init storage')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can init storage
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:132
	// nonAlgoRewardMBR = 0
	int 0
	frame_bury 0 // nonAlgoRewardMBR: uint64

	// *if1_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:133
	// this.rewardAssetId.value !== 0
	byte 0x72657761726441737365744964 // "rewardAssetId"
	app_global_get
	int 0
	!=
	bz *if1_end

	// *if1_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:134
	// nonAlgoRewardMBR += ASSET_HOLDING_FEE
	frame_dig 0 // nonAlgoRewardMBR: uint64
	int 100000
	+
	frame_bury 0 // nonAlgoRewardMBR: uint64

*if1_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:136
	// poolMBR = ALGORAND_ACCOUNT_MIN_BALANCE +
	//       nonAlgoRewardMBR +
	//       this.costForBoxStorage(7 + len<StakeInfo>() * MAX_STAKERS_PER_POOL) +
	//       this.costForBoxStorage(7 + len<uint64>() * 15)
	int 100000
	frame_dig 0 // nonAlgoRewardMBR: uint64
	+
	int 22007
	callsub costForBoxStorage
	+
	int 127
	callsub costForBoxStorage
	+
	frame_bury 1 // poolMBR: uint64

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:142
	// verifyPayTxn(mbrPayment, { receiver: this.app.address, amount: poolMBR })
	// verify receiver
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Amount
	frame_dig 1 // poolMBR: uint64
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"amount","expected":"poolMBR"}
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:143
	// this.stakers.create()
	byte 0x7374616b657273 // "stakers"
	int 22000
	box_create
	pop

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:144
	// this.minimumBalance.value = poolMBR
	byte 0x6d696e696d756d42616c616e6365 // "minimumBalance"
	frame_dig 1 // poolMBR: uint64
	app_global_put

	// *if2_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:146
	// nonAlgoRewardMBR > 0
	frame_dig 0 // nonAlgoRewardMBR: uint64
	int 0
	>
	bz *if2_end

	// *if2_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:148
	// sendAssetTransfer({
	//         xferAsset: AssetID.fromUint64(this.rewardAssetId.value),
	//         assetReceiver: this.app.address,
	//         assetAmount: 0,
	//       })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:149
	// xferAsset: AssetID.fromUint64(this.rewardAssetId.value)
	byte 0x72657761726441737365744964 // "rewardAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:150
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:151
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if2_end:
	retsub

// injectRewards(axfer,uint64,uint64)void
*abi_route_injectRewards:
	// rewardAssetId: uint64
	txna ApplicationArgs 2
	btoi

	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// rewardTxn: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==

	// argument 2 (rewardTxn) for injectRewards must be a axfer transaction
	assert

	// execute injectRewards(axfer,uint64,uint64)void
	callsub injectRewards
	int 1
	return

// injectRewards(rewardTxn: AssetTransferTxn, quantity: uint64, rewardAssetId: uint64): void
injectRewards:
	proto 3 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:159
	// assert(this.txn.sender === this.injectorAddress.value, 'Only injector can inject rewards')
	txn Sender
	byte 0x696e6a6563746f7241646472657373 // "injectorAddress"
	app_global_get
	==

	// Only injector can inject rewards
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:161
	// verifyAssetTransferTxn(rewardTxn, {
	//       sender: this.injectorAddress.value,
	//       assetReceiver: this.app.address,
	//       xferAsset: AssetID.fromUint64(rewardAssetId),
	//       assetAmount: quantity,
	//     })
	// verify sender
	frame_dig -1 // rewardTxn: AssetTransferTxn
	gtxns Sender
	byte 0x696e6a6563746f7241646472657373 // "injectorAddress"
	app_global_get
	==

	// transaction verification failed: {"txn":"rewardTxn","field":"sender","expected":"this.injectorAddress.value"}
	assert

	// verify assetReceiver
	frame_dig -1 // rewardTxn: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"rewardTxn","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig -1 // rewardTxn: AssetTransferTxn
	gtxns XferAsset
	frame_dig -3 // rewardAssetId: uint64
	==

	// transaction verification failed: {"txn":"rewardTxn","field":"xferAsset","expected":"AssetID.fromUint64(rewardAssetId)"}
	assert

	// verify assetAmount
	frame_dig -1 // rewardTxn: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -2 // quantity: uint64
	==

	// transaction verification failed: {"txn":"rewardTxn","field":"assetAmount","expected":"quantity"}
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:167
	// this.injectedASARewards.value += quantity
	byte 0x696e6a656374656441534152657761726473 // "injectedASARewards"
	app_global_get
	frame_dig -2 // quantity: uint64
	+
	byte 0x696e6a656374656441534152657761726473 // "injectedASARewards"
	swap
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:168
	// this.lastRewardInjectionTime.value = globals.latestTimestamp
	byte 0x6c617374526577617264496e6a656374696f6e54696d65 // "lastRewardInjectionTime"
	global LatestTimestamp
	app_global_put
	retsub

// injectAlgoRewards(pay,uint64)void
*abi_route_injectAlgoRewards:
	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// payTxn: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==

	// argument 1 (payTxn) for injectAlgoRewards must be a pay transaction
	assert

	// execute injectAlgoRewards(pay,uint64)void
	callsub injectAlgoRewards
	int 1
	return

// injectAlgoRewards(payTxn: PayTxn, quantity: uint64): void
injectAlgoRewards:
	proto 2 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:172
	// assert(this.txn.sender === this.injectorAddress.value, 'Only admin can inject rewards')
	txn Sender
	byte 0x696e6a6563746f7241646472657373 // "injectorAddress"
	app_global_get
	==

	// Only admin can inject rewards
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:174
	// verifyPayTxn(payTxn, {
	//       receiver: this.app.address,
	//       amount: quantity,
	//     })
	// verify receiver
	frame_dig -1 // payTxn: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payTxn","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // payTxn: PayTxn
	gtxns Amount
	frame_dig -2 // quantity: uint64
	==

	// transaction verification failed: {"txn":"payTxn","field":"amount","expected":"quantity"}
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:179
	// this.algoInjectedRewards.value += quantity
	byte 0x616c676f496e6a656374656452657761726473 // "algoInjectedRewards"
	app_global_get
	frame_dig -2 // quantity: uint64
	+
	byte 0x616c676f496e6a656374656452657761726473 // "algoInjectedRewards"
	swap
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:180
	// this.lastRewardInjectionTime.value = globals.latestTimestamp
	byte 0x6c617374526577617264496e6a656374696f6e54696d65 // "lastRewardInjectionTime"
	global LatestTimestamp
	app_global_put
	retsub

// deleteApplication()void
*abi_route_deleteApplication:
	// execute deleteApplication()void
	callsub deleteApplication
	int 1
	return

// deleteApplication(): void
deleteApplication:
	proto 0 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:185
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can delete application')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can delete application
	assert
	retsub

// stake(axfer,uint64)void
*abi_route_stake:
	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// stakeTxn: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==

	// argument 1 (stakeTxn) for stake must be a axfer transaction
	assert

	// execute stake(axfer,uint64)void
	callsub stake
	int 1
	return

// stake(stakeTxn: AssetTransferTxn, quantity: uint64): void
stake:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:200
	// currentTimeStamp = globals.latestTimestamp
	global LatestTimestamp
	frame_bury 0 // currentTimeStamp: uint64

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:201
	// assert(quantity > 0, 'Invalid quantity')
	frame_dig -2 // quantity: uint64
	int 0
	>

	// Invalid quantity
	assert

	// *if3_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:202
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if3_end

	// *if3_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:203
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if3_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:205
	// verifyAssetTransferTxn(stakeTxn, {
	//       sender: this.txn.sender,
	//       assetReceiver: this.app.address,
	//       xferAsset: AssetID.fromUint64(this.stakedAssetId.value),
	//       assetAmount: quantity,
	//     })
	// verify sender
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"stakeTxn","field":"sender","expected":"this.txn.sender"}
	assert

	// verify assetReceiver
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"stakeTxn","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns XferAsset
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	app_global_get
	==

	// transaction verification failed: {"txn":"stakeTxn","field":"xferAsset","expected":"AssetID.fromUint64(this.stakedAssetId.value)"}
	assert

	// verify assetAmount
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -2 // quantity: uint64
	==

	// transaction verification failed: {"txn":"stakeTxn","field":"assetAmount","expected":"quantity"}
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:211
	// actionComplete: boolean = false
	int 0
	frame_bury 1 // actionComplete: boolean

	// *if4_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:212
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if4_end

	// *if4_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:213
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if4_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:215
	// for (let i = 0; i < this.stakers.value.length; i += 1)
	int 0
	frame_bury 2 // i: uint64

*for_0:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:215
	// i < this.stakers.value.length
	frame_dig 2 // i: uint64
	int 250
	<
	bz *for_0_end

	// *if5_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:216
	// actionComplete
	frame_dig 1 // actionComplete: boolean
	bz *if5_end

	// *if5_consequent
	b *for_0_end

*if5_end:
	// *if6_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:218
	// this.stakers.value[i].account === this.txn.sender
	frame_dig 2 // i: uint64
	int 88
	* // acc * typeLength
	int 0
	+
	int 32
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	txn Sender
	==
	bz *if6_elseif1_condition

	// *if6_consequent
	// *if7_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:221
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if7_end

	// *if7_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:222
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if7_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:225
	// staker = clone(this.stakers.value[i])
	frame_dig 2 // i: uint64
	int 88
	* // acc * typeLength
	int 88
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	frame_bury 3 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:226
	// staker.stake += stakeTxn.assetAmount
	frame_dig 3 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 32 // headOffset
	frame_dig 3 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns AssetAmount
	+
	itob
	replace3
	frame_bury 3 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// *if8_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:228
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if8_end

	// *if8_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:229
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if8_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:231
	// staker.stakeDuration = 0
	frame_dig 3 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	byte 0x0000000000000000
	replace2 40
	frame_bury 3 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:232
	// staker.stakeStartTime = currentTimeStamp
	frame_dig 3 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 48 // headOffset
	frame_dig 0 // currentTimeStamp: uint64
	itob
	replace3
	frame_bury 3 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// *if9_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:233
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if9_end

	// *if9_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:234
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if9_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:236
	// this.stakers.value[i] = staker
	frame_dig 2 // i: uint64
	int 88
	* // acc * typeLength
	frame_dig 3 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace

	// *if10_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:237
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if10_end

	// *if10_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:238
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if10_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:240
	// this.totalStaked.value += stakeTxn.assetAmount
	byte 0x746f74616c5374616b6564 // "totalStaked"
	app_global_get
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns AssetAmount
	+
	byte 0x746f74616c5374616b6564 // "totalStaked"
	swap
	app_global_put

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:241
	// actionComplete = true
	int 1
	frame_bury 1 // actionComplete: boolean
	b *if6_end

*if6_elseif1_condition:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:243
	// this.stakers.value[i].account === globals.zeroAddress
	frame_dig 2 // i: uint64
	int 88
	* // acc * typeLength
	int 0
	+
	int 32
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	global ZeroAddress
	==
	bz *if6_end

	// *if6_elseif1_consequent
	// *if11_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:244
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if11_end

	// *if11_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:245
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if11_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:247
	// this.totalStaked.value = this.totalStaked.value + stakeTxn.assetAmount
	byte 0x746f74616c5374616b6564 // "totalStaked"
	dup
	app_global_get
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns AssetAmount
	+
	app_global_put

	// *if12_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:248
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if12_end

	// *if12_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:249
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if12_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:251
	// this.stakers.value[i] = {
	//           account: this.txn.sender,
	//           stake: stakeTxn.assetAmount,
	//           stakeDuration: 0,
	//           stakeStartTime: currentTimeStamp,
	//           algoAccuredRewards: 0,
	//           lastUpdateTime: currentTimeStamp,
	//           accruedASARewards: 0,
	//           userSharePercentage: 0
	//         }
	frame_dig 2 // i: uint64
	int 88
	* // acc * typeLength
	txn Sender
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns AssetAmount
	itob
	concat
	byte 0x0000000000000000
	concat
	frame_dig 0 // currentTimeStamp: uint64
	itob
	concat
	byte 0x0000000000000000
	concat
	frame_dig 0 // currentTimeStamp: uint64
	itob
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace

	// *if13_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:261
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if13_end

	// *if13_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:262
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if13_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:264
	// this.numStakers.value = this.numStakers.value + 1
	byte 0x6e756d5374616b657273 // "numStakers"
	dup
	app_global_get
	int 1
	+
	app_global_put

	// *if14_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:265
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if14_end

	// *if14_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:266
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if14_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:268
	// actionComplete = true
	int 1
	frame_bury 1 // actionComplete: boolean

*if6_end:
	// *if15_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:271
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if15_end

	// *if15_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:272
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if15_end:

*for_0_continue:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:215
	// i += 1
	frame_dig 2 // i: uint64
	int 1
	+
	frame_bury 2 // i: uint64
	b *for_0

*for_0_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:275
	// assert(actionComplete, 'Stake  failed')
	frame_dig 1 // actionComplete: boolean

	// Stake  failed
	assert
	retsub

// accrueRewards()void
*abi_route_accrueRewards:
	// execute accrueRewards()void
	callsub accrueRewards
	int 1
	return

// accrueRewards(): void
accrueRewards:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 9

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:281
	// algoRewards = this.algoInjectedRewards.value
	byte 0x616c676f496e6a656374656452657761726473 // "algoInjectedRewards"
	app_global_get
	frame_bury 0 // algoRewards: uint64

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:283
	// additionalASARewards = this.injectedASARewards.value
	byte 0x696e6a656374656441534152657761726473 // "injectedASARewards"
	app_global_get
	frame_bury 1 // additionalASARewards: uint64

	// *if16_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:284
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if16_end

	// *if16_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:285
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if16_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:287
	// totalViableStake = 0
	int 0
	frame_bury 2 // totalViableStake: uint64

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:288
	// for (let i = 0; i < this.numStakers.value; i += 1)
	int 0
	frame_bury 3 // i: uint64

*for_1:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:288
	// i < this.numStakers.value
	frame_dig 3 // i: uint64
	byte 0x6e756d5374616b657273 // "numStakers"
	app_global_get
	<
	bz *for_1_end

	// *if17_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:289
	// this.stakers.value[i].stake > 0
	frame_dig 3 // i: uint64
	int 88
	* // acc * typeLength
	int 32 // headOffset
	+
	int 8
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	btoi
	int 0
	>
	bz *if17_end

	// *if17_consequent
	// *if18_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:290
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if18_end

	// *if18_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:291
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if18_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:293
	// this.stakers.value[i].stakeDuration = globals.latestTimestamp - this.stakers.value[i].stakeStartTime
	frame_dig 3 // i: uint64
	int 88
	* // acc * typeLength
	int 40 // headOffset
	+
	global LatestTimestamp
	frame_dig 3 // i: uint64
	int 88
	* // acc * typeLength
	int 48 // headOffset
	+
	int 8
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	btoi
	-
	itob
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace

	// *if19_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:295
	// this.stakers.value[i].stakeDuration >= this.minStakePeriodForRewards.value
	frame_dig 3 // i: uint64
	int 88
	* // acc * typeLength
	int 40 // headOffset
	+
	int 8
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	btoi
	byte 0x6d696e5374616b65506572696f64466f7252657761726473 // "minStakePeriodForRewards"
	app_global_get
	>=
	bz *if19_end

	// *if19_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:296
	// totalViableStake += this.stakers.value[i].stake
	frame_dig 2 // totalViableStake: uint64
	frame_dig 3 // i: uint64
	int 88
	* // acc * typeLength
	int 32 // headOffset
	+
	int 8
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	btoi
	+
	frame_bury 2 // totalViableStake: uint64

*if19_end:

*if17_end:

*for_1_continue:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:288
	// i += 1
	frame_dig 3 // i: uint64
	int 1
	+
	frame_bury 3 // i: uint64
	b *for_1

*for_1_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:301
	// for (let i = 0; i < this.numStakers.value; i += 1)
	int 0
	frame_bury 4 // i: uint64

*for_2:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:301
	// i < this.numStakers.value
	frame_dig 4 // i: uint64
	byte 0x6e756d5374616b657273 // "numStakers"
	app_global_get
	<
	bz *for_2_end

	// *if20_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:302
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if20_end

	// *if20_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:303
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if20_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:305
	// stake = this.stakers.value[i].stake
	frame_dig 4 // i: uint64
	int 88
	* // acc * typeLength
	int 32 // headOffset
	+
	int 8
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	btoi
	frame_bury 5 // stake: uint64

	// *if21_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:307
	// stake > 0
	frame_dig 5 // stake: uint64
	int 0
	>
	bz *if21_end

	// *if21_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:308
	// staker = clone(this.stakers.value[i])
	frame_dig 4 // i: uint64
	int 88
	* // acc * typeLength
	int 88
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	frame_bury 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// *if22_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:310
	// staker.stakeDuration > this.minStakePeriodForRewards.value
	frame_dig 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 40 8
	btoi
	byte 0x6d696e5374616b65506572696f64466f7252657761726473 // "minStakePeriodForRewards"
	app_global_get
	>
	bz *if22_end

	// *if22_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:313
	// stakerShare = wideRatio([stake, PRECISION], [totalViableStake])
	frame_dig 5 // stake: uint64
	int 1000000000000000
	mulw
	int 0
	frame_dig 2 // totalViableStake: uint64
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 7 // stakerShare: uint64

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:314
	// staker.userSharePercentage = stakerShare
	frame_dig 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 80 // headOffset
	frame_dig 7 // stakerShare: uint64
	itob
	replace3
	frame_bury 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// *if23_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:316
	// algoRewards > this.numStakers.value
	frame_dig 0 // algoRewards: uint64
	byte 0x6e756d5374616b657273 // "numStakers"
	app_global_get
	>
	bz *if23_end

	// *if23_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:317
	// algoRewardRate = wideRatio([algoRewards, stakerShare], [PRECISION])
	frame_dig 0 // algoRewards: uint64
	frame_dig 7 // stakerShare: uint64
	mulw
	int 0
	int 1000000000000000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 8 // algoRewardRate: uint64

	// *if24_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:318
	// algoRewardRate === 0
	frame_dig 8 // algoRewardRate: uint64
	int 0
	==
	bz *if24_end

	// *if24_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:319
	// algoRewardRate = 1
	int 1
	frame_bury 8 // algoRewardRate: uint64

*if24_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:321
	// staker.algoAccuredRewards = staker.algoAccuredRewards + algoRewardRate
	frame_dig 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 56 // headOffset
	frame_dig 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 56 8
	btoi
	frame_dig 8 // algoRewardRate: uint64
	+
	itob
	replace3
	frame_bury 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:322
	// this.algoInjectedRewards.value = this.algoInjectedRewards.value - algoRewardRate
	byte 0x616c676f496e6a656374656452657761726473 // "algoInjectedRewards"
	dup
	app_global_get
	frame_dig 8 // algoRewardRate: uint64
	-
	app_global_put

	// *if25_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:324
	// this.stakedAssetId.value === 0
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	app_global_get
	int 0
	==
	bz *if25_end

	// *if25_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:325
	// staker.stake = staker.stake + algoRewardRate
	frame_dig 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 32 // headOffset
	frame_dig 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig 8 // algoRewardRate: uint64
	+
	itob
	replace3
	frame_bury 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:326
	// this.totalStaked.value = this.totalStaked.value + algoRewardRate
	byte 0x746f74616c5374616b6564 // "totalStaked"
	dup
	app_global_get
	frame_dig 8 // algoRewardRate: uint64
	+
	app_global_put

*if25_end:

*if23_end:
	// *if26_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:330
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if26_end

	// *if26_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:331
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if26_end:
	// *if27_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:334
	// additionalASARewards > this.numStakers.value
	frame_dig 1 // additionalASARewards: uint64
	byte 0x6e756d5374616b657273 // "numStakers"
	app_global_get
	>
	bz *if27_end

	// *if27_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:335
	// rewardRate = wideRatio([additionalASARewards, stakerShare], [PRECISION])
	frame_dig 1 // additionalASARewards: uint64
	frame_dig 7 // stakerShare: uint64
	mulw
	int 0
	int 1000000000000000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 9 // rewardRate: uint64

	// *if28_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:336
	// rewardRate === 0
	frame_dig 9 // rewardRate: uint64
	int 0
	==
	bz *if28_end

	// *if28_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:337
	// rewardRate = 1
	int 1
	frame_bury 9 // rewardRate: uint64

*if28_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:341
	// this.injectedASARewards.value = this.injectedASARewards.value - rewardRate
	byte 0x696e6a656374656441534152657761726473 // "injectedASARewards"
	dup
	app_global_get
	frame_dig 9 // rewardRate: uint64
	-
	app_global_put

	// *if29_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:342
	// this.rewardAssetId.value === this.stakedAssetId.value
	byte 0x72657761726441737365744964 // "rewardAssetId"
	app_global_get
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	app_global_get
	==
	bz *if29_else

	// *if29_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:344
	// staker.stake = staker.stake + rewardRate
	frame_dig 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 32 // headOffset
	frame_dig 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig 9 // rewardRate: uint64
	+
	itob
	replace3
	frame_bury 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:345
	// this.totalStaked.value = this.totalStaked.value + rewardRate
	byte 0x746f74616c5374616b6564 // "totalStaked"
	dup
	app_global_get
	frame_dig 9 // rewardRate: uint64
	+
	app_global_put
	b *if29_end

*if29_else:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:347
	// staker.accruedASARewards = staker.accruedASARewards + rewardRate
	frame_dig 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 72 // headOffset
	frame_dig 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 72 8
	btoi
	frame_dig 9 // rewardRate: uint64
	+
	itob
	replace3
	frame_bury 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

*if29_end:

*if27_end:

*if22_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:351
	// staker.lastUpdateTime = globals.latestTimestamp
	frame_dig 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 64 // headOffset
	global LatestTimestamp
	itob
	replace3
	frame_bury 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:352
	// this.stakers.value[i] = staker
	frame_dig 4 // i: uint64
	int 88
	* // acc * typeLength
	frame_dig 6 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace

*if21_end:

*for_2_continue:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:301
	// i += 1
	frame_dig 4 // i: uint64
	int 1
	+
	frame_bury 4 // i: uint64
	b *for_2

*for_2_end:
	retsub

// getStaker(address: Address): StakeInfo
getStaker:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:358
	// for (let i = 0; i < this.numStakers.value; i += 1)
	int 0
	frame_bury 0 // i: uint64

*for_3:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:358
	// i < this.numStakers.value
	frame_dig 0 // i: uint64
	byte 0x6e756d5374616b657273 // "numStakers"
	app_global_get
	<
	bz *for_3_end

	// *if30_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:359
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if30_end

	// *if30_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:360
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if30_end:
	// *if31_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:362
	// this.stakers.value[i].account === address
	frame_dig 0 // i: uint64
	int 88
	* // acc * typeLength
	int 0
	+
	int 32
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	frame_dig -1 // address: Address
	==
	bz *if31_end

	// *if31_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:363
	// return clone(this.stakers.value[i]);
	frame_dig 0 // i: uint64
	int 88
	* // acc * typeLength
	int 88
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	b *getStaker*return

*if31_end:

*for_3_continue:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:358
	// i += 1
	frame_dig 0 // i: uint64
	int 1
	+
	frame_bury 0 // i: uint64
	b *for_3

*for_3_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:366
	// return {
	//       account: globals.zeroAddress,
	//       stake: 0,
	//       stakeDuration: 0,
	//       stakeStartTime: 0,
	//       lastUpdateTime: 0,
	//       algoAccuredRewards: 0,
	//       accruedASARewards: 0,
	//       userSharePercentage: 0
	//     }
	global ZeroAddress
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat

*getStaker*return:
	// set the subroutine return value
	frame_bury 0
	retsub

// claimRewards()void
*abi_route_claimRewards:
	// execute claimRewards()void
	callsub claimRewards
	int 1
	return

// claimRewards(): void
claimRewards:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// *if32_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:379
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if32_end

	// *if32_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:380
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if32_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:382
	// staker = this.getStaker(this.txn.sender)
	txn Sender
	callsub getStaker
	frame_bury 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// *if33_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:385
	// staker.algoAccuredRewards > 0
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 56 8
	btoi
	int 0
	>
	bz *if33_end

	// *if33_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:386
	// sendPayment({
	//         amount: staker.algoAccuredRewards,
	//         receiver: this.txn.sender,
	//         sender: this.app.address,
	//         fee: 1_000,
	//       })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:387
	// amount: staker.algoAccuredRewards
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 56 8
	btoi
	itxn_field Amount

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:388
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:389
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:390
	// fee: 1_000
	int 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:392
	// staker.algoAccuredRewards = 0
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	byte 0x0000000000000000
	replace2 56
	frame_bury 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

*if33_end:
	// *if34_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:396
	// staker.accruedASARewards > 0
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 72 8
	btoi
	int 0
	>
	bz *if34_end

	// *if34_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:397
	// sendAssetTransfer({
	//         xferAsset: AssetID.fromUint64(this.rewardAssetId.value),
	//         assetReceiver: this.txn.sender,
	//         sender: this.app.address,
	//         assetAmount: staker.accruedASARewards,
	//         fee: 1_000,
	//       })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:398
	// xferAsset: AssetID.fromUint64(this.rewardAssetId.value)
	byte 0x72657761726441737365744964 // "rewardAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:399
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:400
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:401
	// assetAmount: staker.accruedASARewards
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 72 8
	btoi
	itxn_field AssetAmount

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:402
	// fee: 1_000
	int 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:404
	// staker.accruedASARewards = 0
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	byte 0x0000000000000000
	replace2 72
	frame_bury 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

*if34_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:408
	// staker.lastUpdateTime = globals.latestTimestamp
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 64 // headOffset
	global LatestTimestamp
	itob
	replace3
	frame_bury 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:409
	// this.setStaker(staker.account, staker)
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 0 32
	callsub setStaker

	// *if35_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:410
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if35_end

	// *if35_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:411
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if35_end:
	retsub

// unstake(uint64)void
*abi_route_unstake:
	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// execute unstake(uint64)void
	callsub unstake
	int 1
	return

// unstake(quantity: uint64): void
unstake:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 4

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:416
	// for (let i = 0; i < this.numStakers.value; i += 1)
	int 0
	frame_bury 0 // i: uint64

*for_4:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:416
	// i < this.numStakers.value
	frame_dig 0 // i: uint64
	byte 0x6e756d5374616b657273 // "numStakers"
	app_global_get
	<
	bz *for_4_end

	// *if36_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:417
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if36_end

	// *if36_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:418
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if36_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:420
	// staker = clone(this.stakers.value[i])
	frame_dig 0 // i: uint64
	int 88
	* // acc * typeLength
	int 88
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	frame_bury 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// *if37_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:421
	// staker.account === this.txn.sender
	frame_dig 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 0 32
	txn Sender
	==
	bz *if37_end

	// *if37_consequent
	// *if38_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:423
	// staker.stake > 0
	frame_dig 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	int 0
	>
	bz *if38_end

	// *if38_consequent
	// *if39_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:424
	// this.stakedAssetId.value === 0
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	app_global_get
	int 0
	==
	bz *if39_else

	// *if39_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:425
	// sendPayment({
	//               amount: quantity === 0 ? staker.stake : quantity,
	//               receiver: this.txn.sender,
	//               sender: this.app.address,
	//               fee: 1_000,
	//             })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:426
	// amount: quantity === 0 ? staker.stake : quantity
	frame_dig -1 // quantity: uint64
	int 0
	==
	bz *ternary0_false
	frame_dig 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	b *ternary0_end

*ternary0_false:
	frame_dig -1 // quantity: uint64

*ternary0_end:
	itxn_field Amount

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:427
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:428
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:429
	// fee: 1_000
	int 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if39_end

*if39_else:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:433
	// sendAssetTransfer({
	//               xferAsset: AssetID.fromUint64(this.stakedAssetId.value),
	//               assetReceiver: this.txn.sender,
	//               sender: this.app.address,
	//               assetAmount: quantity === 0 ? staker.stake : quantity,
	//               fee: 1_000,
	//             })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:434
	// xferAsset: AssetID.fromUint64(this.stakedAssetId.value)
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:435
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:436
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:437
	// assetAmount: quantity === 0 ? staker.stake : quantity
	frame_dig -1 // quantity: uint64
	int 0
	==
	bz *ternary1_false
	frame_dig 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	b *ternary1_end

*ternary1_false:
	frame_dig -1 // quantity: uint64

*ternary1_end:
	itxn_field AssetAmount

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:438
	// fee: 1_000
	int 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if39_end:

*if38_end:
	// *if40_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:444
	// staker.algoAccuredRewards > 0
	frame_dig 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 56 8
	btoi
	int 0
	>
	bz *if40_end

	// *if40_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:445
	// sendPayment({
	//             amount: staker.algoAccuredRewards,
	//             receiver: this.txn.sender,
	//             sender: this.app.address,
	//             fee: 1_000,
	//           })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:446
	// amount: staker.algoAccuredRewards
	frame_dig 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 56 8
	btoi
	itxn_field Amount

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:447
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:448
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:449
	// fee: 1_000
	int 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:451
	// staker.algoAccuredRewards = 0
	frame_dig 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	byte 0x0000000000000000
	replace2 56
	frame_bury 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

*if40_end:
	// *if41_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:455
	// staker.accruedASARewards > 0
	frame_dig 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 72 8
	btoi
	int 0
	>
	bz *if41_end

	// *if41_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:456
	// sendAssetTransfer({
	//             xferAsset: AssetID.fromUint64(this.rewardAssetId.value),
	//             assetReceiver: this.txn.sender,
	//             sender: this.app.address,
	//             assetAmount: staker.accruedASARewards,
	//             fee: 1_000,
	//           })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:457
	// xferAsset: AssetID.fromUint64(this.rewardAssetId.value)
	byte 0x72657761726441737365744964 // "rewardAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:458
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:459
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:460
	// assetAmount: staker.accruedASARewards
	frame_dig 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 72 8
	btoi
	itxn_field AssetAmount

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:461
	// fee: 1_000
	int 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:463
	// staker.accruedASARewards = 0
	frame_dig 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	byte 0x0000000000000000
	replace2 72
	frame_bury 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

*if41_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:467
	// this.totalStaked.value = this.totalStaked.value - (quantity === 0 ? staker.stake : quantity)
	byte 0x746f74616c5374616b6564 // "totalStaked"
	dup
	app_global_get
	frame_dig -1 // quantity: uint64
	int 0
	==
	bz *ternary3_false
	frame_dig 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	b *ternary3_end

*ternary3_false:
	frame_dig -1 // quantity: uint64

*ternary3_end:
	-
	app_global_put

	// *if42_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:469
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if42_end

	// *if42_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:470
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if42_end:
	// *if43_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:473
	// quantity === 0
	frame_dig -1 // quantity: uint64
	int 0
	==
	bz *if43_else

	// *if43_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:474
	// removedStaker: StakeInfo = {
	//             account: globals.zeroAddress,
	//             stake: 0,
	//             stakeDuration: 0,
	//             stakeStartTime: 0,
	//             lastUpdateTime: 0,
	//             algoAccuredRewards: 0,
	//             accruedASARewards: 0,
	//             userSharePercentage: 0
	//           }
	global ZeroAddress
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	frame_bury 2 // removedStaker: StakeInfo

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:484
	// this.setStaker(staker.account, removedStaker)
	frame_dig 2 // removedStaker: StakeInfo
	frame_dig 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 0 32
	callsub setStaker

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:486
	// lastStaker = this.getStaker(this.stakers.value[this.numStakers.value - 1].account)
	byte 0x6e756d5374616b657273 // "numStakers"
	app_global_get
	int 1
	-
	int 88
	* // acc * typeLength
	int 0
	+
	int 32
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	callsub getStaker
	frame_bury 3 // lastStaker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:487
	// lastStakerIndex = this.getStakerIndex(this.stakers.value[this.numStakers.value - 1].account)
	byte 0x6e756d5374616b657273 // "numStakers"
	app_global_get
	int 1
	-
	int 88
	* // acc * typeLength
	int 0
	+
	int 32
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	callsub getStakerIndex
	frame_bury 4 // lastStakerIndex: uint64

	// *if44_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:488
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if44_end

	// *if44_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:489
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if44_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:491
	// this.setStakerAtIndex(lastStaker, i)
	frame_dig 0 // i: uint64
	frame_dig 3 // lastStaker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	callsub setStakerAtIndex

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:493
	// this.setStakerAtIndex(removedStaker, lastStakerIndex)
	frame_dig 4 // lastStakerIndex: uint64
	frame_dig 2 // removedStaker: StakeInfo
	callsub setStakerAtIndex

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:494
	// this.numStakers.value = this.numStakers.value - 1
	byte 0x6e756d5374616b657273 // "numStakers"
	dup
	app_global_get
	int 1
	-
	app_global_put
	b *if43_end

*if43_else:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:497
	// staker.stake = staker.stake - quantity
	frame_dig 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 32 // headOffset
	frame_dig 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig -1 // quantity: uint64
	-
	itob
	replace3
	frame_bury 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:498
	// staker.accruedASARewards = 0
	frame_dig 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	byte 0x0000000000000000
	replace2 72
	frame_bury 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

*if43_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:500
	// staker.lastUpdateTime = globals.latestTimestamp
	frame_dig 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 64 // headOffset
	global LatestTimestamp
	itob
	replace3
	frame_bury 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:501
	// this.setStaker(staker.account, staker)
	frame_dig 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	frame_dig 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 0 32
	callsub setStaker

*if37_end:

*for_4_continue:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:416
	// i += 1
	frame_dig 0 // i: uint64
	int 1
	+
	frame_bury 0 // i: uint64
	b *for_4

*for_4_end:
	retsub

// getStakerIndex(address: Address): uint64
getStakerIndex:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:507
	// for (let i = 0; i < this.numStakers.value; i += 1)
	int 0
	frame_bury 0 // i: uint64

*for_5:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:507
	// i < this.numStakers.value
	frame_dig 0 // i: uint64
	byte 0x6e756d5374616b657273 // "numStakers"
	app_global_get
	<
	bz *for_5_end

	// *if45_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:508
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if45_end

	// *if45_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:509
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if45_end:
	// *if46_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:511
	// this.stakers.value[i].account === address
	frame_dig 0 // i: uint64
	int 88
	* // acc * typeLength
	int 0
	+
	int 32
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	frame_dig -1 // address: Address
	==
	bz *if46_end

	// *if46_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:512
	// return i;
	frame_dig 0 // i: uint64
	b *getStakerIndex*return

*if46_end:

*for_5_continue:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:507
	// i += 1
	frame_dig 0 // i: uint64
	int 1
	+
	frame_bury 0 // i: uint64
	b *for_5

*for_5_end:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:515
	// return 0;
	int 0

*getStakerIndex*return:
	// set the subroutine return value
	frame_bury 0
	retsub

// setStaker(stakerAccount: Address, staker: StakeInfo): void
setStaker:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:519
	// for (let i = 0; i < this.numStakers.value; i += 1)
	int 0
	frame_bury 0 // i: uint64

*for_6:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:519
	// i < this.numStakers.value
	frame_dig 0 // i: uint64
	byte 0x6e756d5374616b657273 // "numStakers"
	app_global_get
	<
	bz *for_6_end

	// *if47_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:520
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if47_end

	// *if47_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:521
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if47_end:
	// *if48_condition
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:523
	// this.stakers.value[i].account === stakerAccount
	frame_dig 0 // i: uint64
	int 88
	* // acc * typeLength
	int 0
	+
	int 32
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	frame_dig -1 // stakerAccount: Address
	==
	bz *if48_elseif1_condition

	// *if48_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:524
	// this.stakers.value[i] = staker
	frame_dig 0 // i: uint64
	int 88
	* // acc * typeLength
	frame_dig -2 // staker: StakeInfo
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:525
	// return;
	retsub
	b *if48_end

*if48_elseif1_condition:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:526
	// this.stakers.value[i].account === globals.zeroAddress
	frame_dig 0 // i: uint64
	int 88
	* // acc * typeLength
	int 0
	+
	int 32
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	global ZeroAddress
	==
	bz *if48_end

	// *if48_elseif1_consequent
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:527
	// this.stakers.value[i] = staker
	frame_dig 0 // i: uint64
	int 88
	* // acc * typeLength
	frame_dig -2 // staker: StakeInfo
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:528
	// return;
	retsub

*if48_end:

*for_6_continue:
	// contracts/PermissionlessInjectedRewardsPool.algo.ts:519
	// i += 1
	frame_dig 0 // i: uint64
	int 1
	+
	frame_bury 0 // i: uint64
	b *for_6

*for_6_end:
	retsub

// setStakerAtIndex(staker: StakeInfo, index: uint64): void
setStakerAtIndex:
	proto 2 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:533
	// this.stakers.value[index] = staker
	frame_dig -2 // index: uint64
	int 88
	* // acc * typeLength
	frame_dig -1 // staker: StakeInfo
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace
	retsub

// setFreeze(bool)void
*abi_route_setFreeze:
	// enabled: bool
	txna ApplicationArgs 1
	dup
	len
	int 1
	==

	// argument 0 (enabled) for setFreeze must be a bool
	assert
	int 0
	getbit

	// execute setFreeze(bool)void
	callsub setFreeze
	int 1
	return

// setFreeze(enabled: boolean): void
setFreeze:
	proto 1 0

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:537
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can freeze payouts')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can freeze payouts
	assert

	// contracts/PermissionlessInjectedRewardsPool.algo.ts:538
	// this.freeze.value = enabled
	byte 0x667265657a65 // "freeze"
	frame_dig -1 // enabled: boolean
	byte 0x00
	int 0
	uncover 2
	setbit
	app_global_put
	retsub

// gas()void
*abi_route_gas:
	// execute gas()void
	callsub gas
	int 1
	return

// gas(): void
gas:
	proto 0 0
	retsub

*create_NoOp:
	method "createApplication(address,address)void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	method "initApplication(uint64,uint64,uint64)void"
	method "updateMinStakePeriod(uint64)void"
	method "updateAdminAddress(address)void"
	method "updateInjectedASARewards(uint64)void"
	method "updateInjectedAlgoRewards(uint64)void"
	method "getMBRForPoolCreation()(uint64)"
	method "initStorage(pay)void"
	method "injectRewards(axfer,uint64,uint64)void"
	method "injectAlgoRewards(pay,uint64)void"
	method "stake(axfer,uint64)void"
	method "accrueRewards()void"
	method "claimRewards()void"
	method "unstake(uint64)void"
	method "setFreeze(bool)void"
	method "gas()void"
	txna ApplicationArgs 0
	match *abi_route_initApplication *abi_route_updateMinStakePeriod *abi_route_updateAdminAddress *abi_route_updateInjectedASARewards *abi_route_updateInjectedAlgoRewards *abi_route_getMBRForPoolCreation *abi_route_initStorage *abi_route_injectRewards *abi_route_injectAlgoRewards *abi_route_stake *abi_route_accrueRewards *abi_route_claimRewards *abi_route_unstake *abi_route_setFreeze *abi_route_gas

	// this contract does not implement the given ABI method for call NoOp
	err

*call_DeleteApplication:
	method "deleteApplication()void"
	txna ApplicationArgs 0
	match *abi_route_deleteApplication

	// this contract does not implement the given ABI method for call DeleteApplication
	err