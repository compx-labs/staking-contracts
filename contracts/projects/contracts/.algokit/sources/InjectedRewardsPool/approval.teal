#pragma version 9

// This TEAL was generated by TEALScript v0.103.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *call_OptIn *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *call_DeleteApplication *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication(address)void
*abi_route_createApplication:
	// adminAddress: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (adminAddress) for createApplication must be a address
	assert

	// execute createApplication(address)void
	callsub createApplication
	int 1
	return

// createApplication(adminAddress: Address): void
createApplication:
	proto 1 0

	// contracts/InjectedRewardsPool.algo.ts:82
	// this.adminAddress.value = adminAddress
	byte 0x61646d696e41646472657373 // "adminAddress"
	frame_dig -1 // adminAddress: Address
	app_global_put
	retsub

// initApplication(uint64,uint64[5],uint64,address)void
*abi_route_initApplication:
	// oracleAdmin: address
	txna ApplicationArgs 4
	dup
	len
	int 32
	==

	// argument 0 (oracleAdmin) for initApplication must be a address
	assert

	// minStakePeriodForRewards: uint64
	txna ApplicationArgs 3
	btoi

	// rewardAssets: uint64[5]
	txna ApplicationArgs 2
	dup
	len
	int 40
	==

	// argument 2 (rewardAssets) for initApplication must be a uint64[5]
	assert

	// stakedAsset: uint64
	txna ApplicationArgs 1
	btoi

	// execute initApplication(uint64,uint64[5],uint64,address)void
	callsub initApplication
	int 1
	return

// initApplication(stakedAsset: uint64, rewardAssets: StaticArray<uint64, 5>, minStakePeriodForRewards: uint64, oracleAdmin: Address): void
initApplication:
	proto 4 0

	// contracts/InjectedRewardsPool.algo.ts:90
	// assert(this.adminAddress.value !== globals.zeroAddress, 'Admin address not set')
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	global ZeroAddress
	!=

	// Admin address not set
	assert

	// contracts/InjectedRewardsPool.algo.ts:91
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can init application')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can init application
	assert

	// contracts/InjectedRewardsPool.algo.ts:92
	// this.stakedAssetId.value = stakedAsset
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	frame_dig -1 // stakedAsset: uint64
	app_global_put

	// contracts/InjectedRewardsPool.algo.ts:93
	// this.rewardAssets.value = rewardAssets
	byte 0x726577617264417373657473 // "rewardAssets"
	frame_dig -2 // rewardAssets: StaticArray<uint64, 5>
	box_put

	// contracts/InjectedRewardsPool.algo.ts:94
	// this.numRewards.value = rewardAssets.length
	byte 0x6e756d52657761726473 // "numRewards"
	int 5
	app_global_put

	// contracts/InjectedRewardsPool.algo.ts:95
	// this.totalStaked.value = 0
	byte 0x746f74616c5374616b6564 // "totalStaked"
	int 0
	app_global_put

	// contracts/InjectedRewardsPool.algo.ts:96
	// this.totalStakingWeight.value = 0 as uint128
	byte 0x746f74616c5374616b696e67576569676874 // "totalStakingWeight"
	byte 0x00000000000000000000000000000000
	app_global_put

	// contracts/InjectedRewardsPool.algo.ts:97
	// this.oracleAdminAddress.value = oracleAdmin
	byte 0x6f7261636c6541646d696e41646472657373 // "oracleAdminAddress"
	frame_dig -4 // oracleAdmin: Address
	app_global_put

	// contracts/InjectedRewardsPool.algo.ts:98
	// this.stakeAssetPrice.value = 0
	byte 0x7374616b6541737365745072696365 // "stakeAssetPrice"
	int 0
	app_global_put

	// contracts/InjectedRewardsPool.algo.ts:99
	// this.rewardAssetPrices.create()
	byte 0x7265776172644173736574507269636573 // "rewardAssetPrices"
	int 40
	box_create
	pop

	// contracts/InjectedRewardsPool.algo.ts:100
	// this.minStakePeriodForRewards.value = minStakePeriodForRewards
	byte 0x6d696e5374616b65506572696f64466f7252657761726473 // "minStakePeriodForRewards"
	frame_dig -3 // minStakePeriodForRewards: uint64
	app_global_put

	// contracts/InjectedRewardsPool.algo.ts:101
	// this.injectedRewards.create()
	byte 0x696e6a656374656452657761726473 // "injectedRewards"
	int 40
	box_create
	pop

	// contracts/InjectedRewardsPool.algo.ts:102
	// this.lastRewardInjectionTime.value = 0
	byte 0x6c617374526577617264496e6a656374696f6e54696d65 // "lastRewardInjectionTime"
	int 0
	app_global_put
	retsub

// optInToApplication()void
*abi_route_optInToApplication:
	// execute optInToApplication()void
	callsub optInToApplication
	int 1
	return

// optInToApplication(): void
optInToApplication:
	proto 0 0

	// contracts/InjectedRewardsPool.algo.ts:107
	// this.stakeDuration(this.txn.sender).value = 0
	txn Sender
	byte 0x7374616b654475726174696f6e // "stakeDuration"
	int 0
	app_local_put

	// contracts/InjectedRewardsPool.algo.ts:108
	// this.stakeStartTime(this.txn.sender).value = globals.latestTimestamp
	txn Sender
	byte 0x7374616b65537461727454696d65 // "stakeStartTime"
	global LatestTimestamp
	app_local_put

	// contracts/InjectedRewardsPool.algo.ts:109
	// this.userStakingWeight(this.txn.sender).value = 0
	txn Sender
	byte 0x757365725374616b696e67576569676874 // "userStakingWeight"
	int 0
	app_local_put

	// contracts/InjectedRewardsPool.algo.ts:110
	// this.lastRewardRate(this.txn.sender).value = 0
	txn Sender
	byte 0x6c61737452657761726452617465 // "lastRewardRate"
	int 0
	app_local_put

	// contracts/InjectedRewardsPool.algo.ts:111
	// this.algoAccuredRewards(this.txn.sender).value = 0
	txn Sender
	byte 0x616c676f4163637572656452657761726473 // "algoAccuredRewards"
	int 0
	app_local_put

	// contracts/InjectedRewardsPool.algo.ts:112
	// this.lastUpdateTime(this.txn.sender).value = 0
	txn Sender
	byte 0x6c61737455706461746554696d65 // "lastUpdateTime"
	int 0
	app_local_put

	// contracts/InjectedRewardsPool.algo.ts:113
	// this.algoRewardRate(this.txn.sender).value = 0
	txn Sender
	byte 0x616c676f52657761726452617465 // "algoRewardRate"
	int 0
	app_local_put

	// contracts/InjectedRewardsPool.algo.ts:114
	// this.userShare(this.txn.sender).value = 0
	txn Sender
	byte 0x757365725368617265 // "userShare"
	int 0
	app_local_put

	// contracts/InjectedRewardsPool.algo.ts:115
	// this.accruedRewards(this.txn.sender).value = [0, 0, 0, 0, 0]
	txn Sender
	byte 0x6163637275656452657761726473 // "accruedRewards"
	byte 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000
	app_local_put

	// contracts/InjectedRewardsPool.algo.ts:116
	// this.rewardRate(this.txn.sender).value = [0, 0, 0, 0, 0]
	txn Sender
	byte 0x72657761726452617465 // "rewardRate"
	byte 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000
	app_local_put
	retsub

// updateParams(uint64)void
*abi_route_updateParams:
	// minStakePeriodForRewards: uint64
	txna ApplicationArgs 1
	btoi

	// execute updateParams(uint64)void
	callsub updateParams
	int 1
	return

// updateParams(minStakePeriodForRewards: uint64): void
updateParams:
	proto 1 0

	// contracts/InjectedRewardsPool.algo.ts:121
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can update params')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can update params
	assert

	// contracts/InjectedRewardsPool.algo.ts:122
	// this.minStakePeriodForRewards.value = minStakePeriodForRewards
	byte 0x6d696e5374616b65506572696f64466f7252657761726473 // "minStakePeriodForRewards"
	frame_dig -1 // minStakePeriodForRewards: uint64
	app_global_put
	retsub

// costForBoxStorage(totalNumBytes: uint64): uint64
costForBoxStorage:
	proto 1 1

	// contracts/InjectedRewardsPool.algo.ts:129
	// return SCBOX_PERBOX + totalNumBytes * SCBOX_PERBYTE
	int 2500
	frame_dig -1 // totalNumBytes: uint64
	int 400
	*
	+
	retsub

// getMBRForPoolCreation()(uint64)
*abi_route_getMBRForPoolCreation:
	// The ABI return prefix
	byte 0x151f7c75

	// execute getMBRForPoolCreation()(uint64)
	callsub getMBRForPoolCreation
	concat
	log
	int 1
	return

// getMBRForPoolCreation(): mbrReturn
getMBRForPoolCreation:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts/InjectedRewardsPool.algo.ts:133
	// nonAlgoRewardMBR = 0
	int 0
	frame_bury 0 // nonAlgoRewardMBR: uint64

	// contracts/InjectedRewardsPool.algo.ts:134
	// for (var i = 0; i < this.rewardAssets.value.length; i += 1)
	int 0
	frame_bury 1 // i: uint64

*for_0:
	// contracts/InjectedRewardsPool.algo.ts:134
	// i < this.rewardAssets.value.length
	frame_dig 1 // i: uint64
	int 5
	<
	bz *for_0_end

	// *if0_condition
	// contracts/InjectedRewardsPool.algo.ts:135
	// this.rewardAssets.value[i] !== 0
	frame_dig 1 // i: uint64
	int 8
	* // acc * typeLength
	int 8
	byte 0x726577617264417373657473 // "rewardAssets"
	cover 2
	box_extract
	btoi
	int 0
	!=
	bz *if0_end

	// *if0_consequent
	// contracts/InjectedRewardsPool.algo.ts:136
	// nonAlgoRewardMBR += ASSET_HOLDING_FEE
	frame_dig 0 // nonAlgoRewardMBR: uint64
	int 100000
	+
	frame_bury 0 // nonAlgoRewardMBR: uint64

*if0_end:

*for_0_continue:
	// contracts/InjectedRewardsPool.algo.ts:134
	// i += 1
	frame_dig 1 // i: uint64
	int 1
	+
	frame_bury 1 // i: uint64
	b *for_0

*for_0_end:
	// contracts/InjectedRewardsPool.algo.ts:139
	// mbr = ALGORAND_ACCOUNT_MIN_BALANCE +
	//       nonAlgoRewardMBR +
	//       this.costForBoxStorage(7 + len<StakeInfo>() * MAX_STAKERS_PER_POOL) +
	//       this.costForBoxStorage(7 + len<uint64>() * 15)
	int 100000
	frame_dig 0 // nonAlgoRewardMBR: uint64
	+
	int 47
	callsub costForBoxStorage
	+
	int 127
	callsub costForBoxStorage
	+
	frame_bury 2 // mbr: uint64

	// contracts/InjectedRewardsPool.algo.ts:144
	// return {
	//       mbrPayment: mbr
	//     }
	frame_dig 2 // mbr: uint64
	itob

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// initStorage(pay)void
*abi_route_initStorage:
	// mbrPayment: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==

	// argument 0 (mbrPayment) for initStorage must be a pay transaction
	assert

	// execute initStorage(pay)void
	callsub initStorage
	int 1
	return

// initStorage(mbrPayment: PayTxn): void
initStorage:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// contracts/InjectedRewardsPool.algo.ts:150
	// assert(!this.stakers.exists, 'staking pool already initialized')
	byte 0x7374616b657273 // "stakers"
	box_len
	swap
	pop
	!

	// staking pool already initialized
	assert

	// contracts/InjectedRewardsPool.algo.ts:151
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can init storage')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can init storage
	assert

	// contracts/InjectedRewardsPool.algo.ts:153
	// nonAlgoRewardMBR = 0
	int 0
	frame_bury 0 // nonAlgoRewardMBR: uint64

	// contracts/InjectedRewardsPool.algo.ts:154
	// for (var i = 0; i < this.rewardAssets.value.length; i += 1)
	int 0
	frame_bury 1 // i: uint64

*for_1:
	// contracts/InjectedRewardsPool.algo.ts:154
	// i < this.rewardAssets.value.length
	frame_dig 1 // i: uint64
	int 5
	<
	bz *for_1_end

	// *if1_condition
	// contracts/InjectedRewardsPool.algo.ts:155
	// this.rewardAssets.value[i] !== 0
	frame_dig 1 // i: uint64
	int 8
	* // acc * typeLength
	int 8
	byte 0x726577617264417373657473 // "rewardAssets"
	cover 2
	box_extract
	btoi
	int 0
	!=
	bz *if1_end

	// *if1_consequent
	// contracts/InjectedRewardsPool.algo.ts:156
	// nonAlgoRewardMBR += ASSET_HOLDING_FEE
	frame_dig 0 // nonAlgoRewardMBR: uint64
	int 100000
	+
	frame_bury 0 // nonAlgoRewardMBR: uint64

*if1_end:

*for_1_continue:
	// contracts/InjectedRewardsPool.algo.ts:154
	// i += 1
	frame_dig 1 // i: uint64
	int 1
	+
	frame_bury 1 // i: uint64
	b *for_1

*for_1_end:
	// contracts/InjectedRewardsPool.algo.ts:159
	// poolMBR = ALGORAND_ACCOUNT_MIN_BALANCE +
	//       nonAlgoRewardMBR +
	//       this.costForBoxStorage(7 + len<StakeInfo>() * MAX_STAKERS_PER_POOL) +
	//       this.costForBoxStorage(7 + len<uint64>() * 15)
	int 100000
	frame_dig 0 // nonAlgoRewardMBR: uint64
	+
	int 47
	callsub costForBoxStorage
	+
	int 127
	callsub costForBoxStorage
	+
	frame_bury 2 // poolMBR: uint64

	// contracts/InjectedRewardsPool.algo.ts:165
	// verifyPayTxn(mbrPayment, { receiver: this.app.address, amount: poolMBR })
	// verify receiver
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Amount
	frame_dig 2 // poolMBR: uint64
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"amount","expected":"poolMBR"}
	assert

	// contracts/InjectedRewardsPool.algo.ts:166
	// this.stakers.create()
	byte 0x7374616b657273 // "stakers"
	int 40
	box_create
	pop

	// contracts/InjectedRewardsPool.algo.ts:167
	// this.minimumBalance.value = poolMBR
	byte 0x6d696e696d756d42616c616e6365 // "minimumBalance"
	frame_dig 2 // poolMBR: uint64
	app_global_put

	// *if2_condition
	// contracts/InjectedRewardsPool.algo.ts:169
	// nonAlgoRewardMBR > 0
	frame_dig 0 // nonAlgoRewardMBR: uint64
	int 0
	>
	bz *if2_end

	// *if2_consequent
	// contracts/InjectedRewardsPool.algo.ts:171
	// for (var i = 0; i < this.rewardAssets.value.length; i += 1)
	int 0
	frame_bury 3 // i: uint64

*for_2:
	// contracts/InjectedRewardsPool.algo.ts:171
	// i < this.rewardAssets.value.length
	frame_dig 3 // i: uint64
	int 5
	<
	bz *for_2_end

	// *if3_condition
	// contracts/InjectedRewardsPool.algo.ts:172
	// this.rewardAssets.value[i] !== 0
	frame_dig 3 // i: uint64
	int 8
	* // acc * typeLength
	int 8
	byte 0x726577617264417373657473 // "rewardAssets"
	cover 2
	box_extract
	btoi
	int 0
	!=
	bz *if3_end

	// *if3_consequent
	// contracts/InjectedRewardsPool.algo.ts:173
	// sendAssetTransfer({
	//             xferAsset: AssetID.fromUint64(this.rewardAssets.value[i]),
	//             assetReceiver: this.app.address,
	//             assetAmount: 0,
	//           })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/InjectedRewardsPool.algo.ts:174
	// xferAsset: AssetID.fromUint64(this.rewardAssets.value[i])
	frame_dig 3 // i: uint64
	int 8
	* // acc * typeLength
	int 8
	byte 0x726577617264417373657473 // "rewardAssets"
	cover 2
	box_extract
	btoi
	itxn_field XferAsset

	// contracts/InjectedRewardsPool.algo.ts:175
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/InjectedRewardsPool.algo.ts:176
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if3_end:

*for_2_continue:
	// contracts/InjectedRewardsPool.algo.ts:171
	// i += 1
	frame_dig 3 // i: uint64
	int 1
	+
	frame_bury 3 // i: uint64
	b *for_2

*for_2_end:

*if2_end:
	retsub

// injectRewards(axfer,uint64,uint64)void
*abi_route_injectRewards:
	// rewardAssetId: uint64
	txna ApplicationArgs 2
	btoi

	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// rewardTxn: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==

	// argument 2 (rewardTxn) for injectRewards must be a axfer transaction
	assert

	// execute injectRewards(axfer,uint64,uint64)void
	callsub injectRewards
	int 1
	return

// injectRewards(rewardTxn: AssetTransferTxn, quantity: uint64, rewardAssetId: uint64): void
injectRewards:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/InjectedRewardsPool.algo.ts:188
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can inject rewards')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can inject rewards
	assert

	// contracts/InjectedRewardsPool.algo.ts:189
	// assert(this.txn.numAssets > 1, 'Invalid number of assets')
	txn NumAssets
	int 1
	>

	// Invalid number of assets
	assert

	// contracts/InjectedRewardsPool.algo.ts:191
	// for (let i = 0; i < this.rewardAssets.value.length; i += 1)
	int 0
	frame_bury 0 // i: uint64

*for_3:
	// contracts/InjectedRewardsPool.algo.ts:191
	// i < this.rewardAssets.value.length
	frame_dig 0 // i: uint64
	int 5
	<
	bz *for_3_end

	// *if4_condition
	// contracts/InjectedRewardsPool.algo.ts:192
	// this.rewardAssets.value[i] === rewardAssetId
	frame_dig 0 // i: uint64
	int 8
	* // acc * typeLength
	int 8
	byte 0x726577617264417373657473 // "rewardAssets"
	cover 2
	box_extract
	btoi
	frame_dig -3 // rewardAssetId: uint64
	==
	bz *if4_end

	// *if4_consequent
	// contracts/InjectedRewardsPool.algo.ts:193
	// verifyAssetTransferTxn(rewardTxn, {
	//           sender: this.adminAddress.value,
	//           assetReceiver: this.app.address,
	//           xferAsset: AssetID.fromUint64(rewardAssetId),
	//           assetAmount: quantity,
	//         })
	// verify sender
	frame_dig -1 // rewardTxn: AssetTransferTxn
	gtxns Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// transaction verification failed: {"txn":"rewardTxn","field":"sender","expected":"this.adminAddress.value"}
	assert

	// verify assetReceiver
	frame_dig -1 // rewardTxn: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"rewardTxn","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig -1 // rewardTxn: AssetTransferTxn
	gtxns XferAsset
	frame_dig -3 // rewardAssetId: uint64
	==

	// transaction verification failed: {"txn":"rewardTxn","field":"xferAsset","expected":"AssetID.fromUint64(rewardAssetId)"}
	assert

	// verify assetAmount
	frame_dig -1 // rewardTxn: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -2 // quantity: uint64
	==

	// transaction verification failed: {"txn":"rewardTxn","field":"assetAmount","expected":"quantity"}
	assert

	// contracts/InjectedRewardsPool.algo.ts:199
	// this.injectedRewards.value[i] += quantity
	frame_dig 0 // i: uint64
	int 8
	* // acc * typeLength
	frame_dig 0 // i: uint64
	int 8
	* // acc * typeLength
	int 8
	byte 0x696e6a656374656452657761726473 // "injectedRewards"
	cover 2
	box_extract
	btoi
	frame_dig -2 // quantity: uint64
	+
	itob
	byte 0x696e6a656374656452657761726473 // "injectedRewards"
	cover 2
	box_replace

	// contracts/InjectedRewardsPool.algo.ts:200
	// this.lastRewardInjectionTime.value = globals.latestTimestamp
	byte 0x6c617374526577617264496e6a656374696f6e54696d65 // "lastRewardInjectionTime"
	global LatestTimestamp
	app_global_put

*if4_end:

*for_3_continue:
	// contracts/InjectedRewardsPool.algo.ts:191
	// i += 1
	frame_dig 0 // i: uint64
	int 1
	+
	frame_bury 0 // i: uint64
	b *for_3

*for_3_end:
	retsub

// injectAlgoRewards(pay,uint64)void
*abi_route_injectAlgoRewards:
	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// payTxn: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==

	// argument 1 (payTxn) for injectAlgoRewards must be a pay transaction
	assert

	// execute injectAlgoRewards(pay,uint64)void
	callsub injectAlgoRewards
	int 1
	return

// injectAlgoRewards(payTxn: PayTxn, quantity: uint64): void
injectAlgoRewards:
	proto 2 0

	// contracts/InjectedRewardsPool.algo.ts:206
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can inject rewards')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can inject rewards
	assert

	// contracts/InjectedRewardsPool.algo.ts:208
	// verifyPayTxn(payTxn, {
	//       receiver: this.app.address,
	//       amount: quantity,
	//     })
	// verify receiver
	frame_dig -1 // payTxn: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payTxn","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // payTxn: PayTxn
	gtxns Amount
	frame_dig -2 // quantity: uint64
	==

	// transaction verification failed: {"txn":"payTxn","field":"amount","expected":"quantity"}
	assert

	// contracts/InjectedRewardsPool.algo.ts:213
	// this.algoInjectedRewards.value += quantity
	byte 0x616c676f496e6a656374656452657761726473 // "algoInjectedRewards"
	app_global_get
	frame_dig -2 // quantity: uint64
	+
	byte 0x616c676f496e6a656374656452657761726473 // "algoInjectedRewards"
	swap
	app_global_put

	// contracts/InjectedRewardsPool.algo.ts:214
	// this.lastRewardInjectionTime.value = globals.latestTimestamp
	byte 0x6c617374526577617264496e6a656374696f6e54696d65 // "lastRewardInjectionTime"
	global LatestTimestamp
	app_global_put
	retsub

// deleteApplication()void
*abi_route_deleteApplication:
	// execute deleteApplication()void
	callsub deleteApplication
	int 1
	return

// deleteApplication(): void
deleteApplication:
	proto 0 0

	// contracts/InjectedRewardsPool.algo.ts:219
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can delete application')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can delete application
	assert

	// contracts/InjectedRewardsPool.algo.ts:220
	// assert(this.totalStaked.value === 0, 'Staked assets still exist')
	byte 0x746f74616c5374616b6564 // "totalStaked"
	app_global_get
	int 0
	==

	// Staked assets still exist
	assert
	retsub

// setPrices(uint64,uint64[5])void
*abi_route_setPrices:
	// rewardTokenPrices: uint64[5]
	txna ApplicationArgs 2
	dup
	len
	int 40
	==

	// argument 0 (rewardTokenPrices) for setPrices must be a uint64[5]
	assert

	// stakeAssetPrice: uint64
	txna ApplicationArgs 1
	btoi

	// execute setPrices(uint64,uint64[5])void
	callsub setPrices
	int 1
	return

// setPrices(stakeAssetPrice: uint64, rewardTokenPrices: StaticArray<uint64, 5>): void
setPrices:
	proto 2 0

	// contracts/InjectedRewardsPool.algo.ts:234
	// assert(this.txn.sender === this.oracleAdminAddress.value, 'Only oracle admin can set prices')
	txn Sender
	byte 0x6f7261636c6541646d696e41646472657373 // "oracleAdminAddress"
	app_global_get
	==

	// Only oracle admin can set prices
	assert

	// contracts/InjectedRewardsPool.algo.ts:235
	// assert(stakeAssetPrice > 0, 'Invalid stake token price')
	frame_dig -1 // stakeAssetPrice: uint64
	int 0
	>

	// Invalid stake token price
	assert

	// contracts/InjectedRewardsPool.algo.ts:236
	// assert(rewardTokenPrices.length === this.numRewards.value, 'Invalid number of reward token prices')
	int 5
	byte 0x6e756d52657761726473 // "numRewards"
	app_global_get
	==

	// Invalid number of reward token prices
	assert

	// contracts/InjectedRewardsPool.algo.ts:238
	// this.stakeAssetPrice.value = stakeAssetPrice
	byte 0x7374616b6541737365745072696365 // "stakeAssetPrice"
	frame_dig -1 // stakeAssetPrice: uint64
	app_global_put

	// contracts/InjectedRewardsPool.algo.ts:239
	// this.rewardAssetPrices.value = rewardTokenPrices
	byte 0x7265776172644173736574507269636573 // "rewardAssetPrices"
	frame_dig -2 // rewardTokenPrices: StaticArray<uint64, 5>
	box_put
	retsub

// stake(axfer,uint64)void
*abi_route_stake:
	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// stakeTxn: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==

	// argument 1 (stakeTxn) for stake must be a axfer transaction
	assert

	// execute stake(axfer,uint64)void
	callsub stake
	int 1
	return

// stake(stakeTxn: AssetTransferTxn, quantity: uint64): void
stake:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// contracts/InjectedRewardsPool.algo.ts:247
	// currentTimeStamp = globals.latestTimestamp
	global LatestTimestamp
	frame_bury 0 // currentTimeStamp: uint64

	// contracts/InjectedRewardsPool.algo.ts:248
	// assert(quantity > 0, 'Invalid quantity')
	frame_dig -2 // quantity: uint64
	int 0
	>

	// Invalid quantity
	assert

	// contracts/InjectedRewardsPool.algo.ts:250
	// verifyAssetTransferTxn(stakeTxn, {
	//       sender: this.txn.sender,
	//       assetReceiver: this.app.address,
	//       xferAsset: AssetID.fromUint64(this.stakedAssetId.value),
	//       assetAmount: quantity,
	//     })
	// verify sender
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"stakeTxn","field":"sender","expected":"this.txn.sender"}
	assert

	// verify assetReceiver
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"stakeTxn","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns XferAsset
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	app_global_get
	==

	// transaction verification failed: {"txn":"stakeTxn","field":"xferAsset","expected":"AssetID.fromUint64(this.stakedAssetId.value)"}
	assert

	// verify assetAmount
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -2 // quantity: uint64
	==

	// transaction verification failed: {"txn":"stakeTxn","field":"assetAmount","expected":"quantity"}
	assert

	// contracts/InjectedRewardsPool.algo.ts:256
	// actionComplete: boolean = false
	int 0
	frame_bury 1 // actionComplete: boolean

	// contracts/InjectedRewardsPool.algo.ts:257
	// for (let i = 0; i < this.stakers.value.length; i += 1)
	int 0
	frame_bury 2 // i: uint64

*for_4:
	// contracts/InjectedRewardsPool.algo.ts:257
	// i < this.stakers.value.length
	frame_dig 2 // i: uint64
	int 1
	<
	bz *for_4_end

	// *if5_condition
	// contracts/InjectedRewardsPool.algo.ts:258
	// actionComplete
	frame_dig 1 // actionComplete: boolean
	bz *if5_end

	// *if5_consequent
	b *for_4_end

*if5_end:
	// contracts/InjectedRewardsPool.algo.ts:263
	// staker = clone(this.stakers.value[i])
	frame_dig 2 // i: uint64
	int 40
	* // acc * typeLength
	int 40
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	frame_bury 3 // staker: (address,uint64)

	// *if6_condition
	// contracts/InjectedRewardsPool.algo.ts:264
	// staker.account === this.txn.sender
	frame_dig 3 // staker: (address,uint64)
	extract 0 32
	txn Sender
	==
	bz *if6_elseif1_condition

	// *if6_consequent
	// contracts/InjectedRewardsPool.algo.ts:265
	// staker.stake += stakeTxn.assetAmount
	frame_dig 3 // staker: (address,uint64)
	int 32 // headOffset
	frame_dig 3 // staker: (address,uint64)
	extract 32 8
	btoi
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns AssetAmount
	+
	itob
	replace3
	frame_bury 3 // staker: (address,uint64)

	// contracts/InjectedRewardsPool.algo.ts:266
	// this.stakers.value[i] = staker
	frame_dig 2 // i: uint64
	int 40
	* // acc * typeLength
	frame_dig 3 // staker: (address,uint64)
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace

	// contracts/InjectedRewardsPool.algo.ts:267
	// actionComplete = true
	int 1
	frame_bury 1 // actionComplete: boolean
	b *if6_end

*if6_elseif1_condition:
	// contracts/InjectedRewardsPool.algo.ts:269
	// this.stakers.value[i].account === globals.zeroAddress
	frame_dig 2 // i: uint64
	int 40
	* // acc * typeLength
	int 0
	+
	int 32
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	global ZeroAddress
	==
	bz *if6_end

	// *if6_elseif1_consequent
	// contracts/InjectedRewardsPool.algo.ts:271
	// this.totalStaked.value += stakeTxn.assetAmount
	byte 0x746f74616c5374616b6564 // "totalStaked"
	app_global_get
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns AssetAmount
	+
	byte 0x746f74616c5374616b6564 // "totalStaked"
	swap
	app_global_put

	// contracts/InjectedRewardsPool.algo.ts:273
	// this.stakers.value[i] = {
	//           account: this.txn.sender,
	//           stake: stakeTxn.assetAmount,
	//         }
	frame_dig 2 // i: uint64
	int 40
	* // acc * typeLength
	txn Sender
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns AssetAmount
	itob
	concat
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace

	// contracts/InjectedRewardsPool.algo.ts:277
	// this.accruedRewards(this.txn.sender).value = [0, 0, 0, 0, 0]
	txn Sender
	byte 0x6163637275656452657761726473 // "accruedRewards"
	byte 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000
	app_local_put

	// contracts/InjectedRewardsPool.algo.ts:278
	// this.rewardRate(this.txn.sender).value = [0, 0, 0, 0, 0]
	txn Sender
	byte 0x72657761726452617465 // "rewardRate"
	byte 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000
	app_local_put

	// contracts/InjectedRewardsPool.algo.ts:279
	// actionComplete = true
	int 1
	frame_bury 1 // actionComplete: boolean

*if6_end:

*for_4_continue:
	// contracts/InjectedRewardsPool.algo.ts:257
	// i += 1
	frame_dig 2 // i: uint64
	int 1
	+
	frame_bury 2 // i: uint64
	b *for_4

*for_4_end:
	retsub

// calculateRewardRates(): void
calculateRewardRates:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 5

	// contracts/InjectedRewardsPool.algo.ts:285
	// for (let i = 0; i < this.stakers.value.length; i += 1)
	int 0
	frame_bury 0 // i: uint64

*for_5:
	// contracts/InjectedRewardsPool.algo.ts:285
	// i < this.stakers.value.length
	frame_dig 0 // i: uint64
	int 1
	<
	bz *for_5_end

	// contracts/InjectedRewardsPool.algo.ts:290
	// staker = clone(this.stakers.value[i])
	frame_dig 0 // i: uint64
	int 40
	* // acc * typeLength
	int 40
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	frame_bury 1 // staker: (address,uint64)

	// *if7_condition
	// contracts/InjectedRewardsPool.algo.ts:291
	// staker.account === globals.zeroAddress
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	global ZeroAddress
	==
	bz *if7_end

	// *if7_consequent
	b *for_5_continue

*if7_end:
	// *if8_condition
	// contracts/InjectedRewardsPool.algo.ts:293
	// this.userStakingWeight(staker.account).value > 0
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x757365725374616b696e67576569676874 // "userStakingWeight"
	app_local_get
	int 0
	>
	bz *if8_end

	// *if8_consequent
	// contracts/InjectedRewardsPool.algo.ts:294
	// this.totalStakingWeight.value = this.totalStakingWeight.value - (this.userStakingWeight(staker.account).value as uint128)
	byte 0x746f74616c5374616b696e67576569676874 // "totalStakingWeight"
	dup
	app_global_get
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x757365725374616b696e67576569676874 // "userStakingWeight"
	app_local_get
	itob
	b-
	dup
	bitlen
	int 128
	<=

	// this.totalStakingWeight.value - (this.userStakingWeight(staker.account).value as uint128) overflowed 128 bits
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 16
	-
	swap
	substring3
	app_global_put

*if8_end:
	// contracts/InjectedRewardsPool.algo.ts:296
	// userStakingWeight = 0
	int 0
	frame_bury 2 // userStakingWeight: uint64

	// contracts/InjectedRewardsPool.algo.ts:298
	// userStakingWeight = userStakingWeight + (wideRatio([staker.stake, this.stakeAssetPrice.value], [this.algoPrice.value]))
	frame_dig 2 // userStakingWeight: uint64
	frame_dig 1 // staker: (address,uint64)
	extract 32 8
	btoi
	byte 0x7374616b6541737365745072696365 // "stakeAssetPrice"
	app_global_get
	mulw
	int 0
	byte 0x616c676f5072696365 // "algoPrice"
	app_global_get
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	+
	frame_bury 2 // userStakingWeight: uint64

	// contracts/InjectedRewardsPool.algo.ts:299
	// for (var j = 0; j < this.rewardAssets.value.length; j += 1)
	int 0
	frame_bury 3 // j: uint64

*for_6:
	// contracts/InjectedRewardsPool.algo.ts:299
	// j < this.rewardAssets.value.length
	frame_dig 3 // j: uint64
	int 5
	<
	bz *for_6_end

	// *if9_condition
	// contracts/InjectedRewardsPool.algo.ts:300
	// this.injectedRewards.value[j] === 0
	frame_dig 3 // j: uint64
	int 8
	* // acc * typeLength
	int 8
	byte 0x696e6a656374656452657761726473 // "injectedRewards"
	cover 2
	box_extract
	btoi
	int 0
	==
	bz *if9_end

	// *if9_consequent
	b *for_6_continue

*if9_end:
	// contracts/InjectedRewardsPool.algo.ts:301
	// userStakingWeight = userStakingWeight + (wideRatio([staker.stake, this.stakeAssetPrice.value], [this.rewardAssetPrices.value[j]]))
	frame_dig 2 // userStakingWeight: uint64
	frame_dig 1 // staker: (address,uint64)
	extract 32 8
	btoi
	byte 0x7374616b6541737365745072696365 // "stakeAssetPrice"
	app_global_get
	mulw
	int 0
	frame_dig 3 // j: uint64
	int 8
	* // acc * typeLength
	int 8
	byte 0x7265776172644173736574507269636573 // "rewardAssetPrices"
	cover 2
	box_extract
	btoi
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	+
	frame_bury 2 // userStakingWeight: uint64

*for_6_continue:
	// contracts/InjectedRewardsPool.algo.ts:299
	// j += 1
	frame_dig 3 // j: uint64
	int 1
	+
	frame_bury 3 // j: uint64
	b *for_6

*for_6_end:
	// contracts/InjectedRewardsPool.algo.ts:304
	// this.userStakingWeight(staker.account).value = userStakingWeight
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x757365725374616b696e67576569676874 // "userStakingWeight"
	frame_dig 2 // userStakingWeight: uint64
	app_local_put

	// contracts/InjectedRewardsPool.algo.ts:305
	// this.totalStakingWeight.value = this.totalStakingWeight.value + (userStakingWeight as uint128)
	byte 0x746f74616c5374616b696e67576569676874 // "totalStakingWeight"
	dup
	app_global_get
	frame_dig 2 // userStakingWeight: uint64
	itob
	b+
	dup
	bitlen
	int 128
	<=

	// this.totalStakingWeight.value + (userStakingWeight as uint128) overflowed 128 bits
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 16
	-
	swap
	substring3
	app_global_put

	// contracts/InjectedRewardsPool.algo.ts:307
	// this.userShare(staker.account).value = wideRatio([userStakingWeight, PRECISION], [this.totalStakingWeight.value as uint64])
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x757365725368617265 // "userShare"
	frame_dig 2 // userStakingWeight: uint64
	int 1000000000000000
	mulw
	int 0
	byte 0x746f74616c5374616b696e67576569676874 // "totalStakingWeight"
	app_global_get
	dup
	bitlen
	int 64
	<=

	// this.totalStakingWeight.value as uint64 overflowed 64 bits
	assert
	extract 8 8
	btoi
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	app_local_put

	// contracts/InjectedRewardsPool.algo.ts:308
	// userSharePercentage = wideRatio([this.userShare(staker.account).value, 100], [PRECISION])
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x757365725368617265 // "userShare"
	app_local_get
	int 100
	mulw
	int 0
	int 1000000000000000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 4 // userSharePercentage: uint64

	// contracts/InjectedRewardsPool.algo.ts:310
	// for (var k = 0; k < this.rewardAssets.value.length; k += 1)
	int 0
	frame_bury 5 // k: uint64

*for_7:
	// contracts/InjectedRewardsPool.algo.ts:310
	// k < this.rewardAssets.value.length
	frame_dig 5 // k: uint64
	int 5
	<
	bz *for_7_end

	// *if10_condition
	// contracts/InjectedRewardsPool.algo.ts:311
	// this.injectedRewards.value[k] === 0
	frame_dig 5 // k: uint64
	int 8
	* // acc * typeLength
	int 8
	byte 0x696e6a656374656452657761726473 // "injectedRewards"
	cover 2
	box_extract
	btoi
	int 0
	==
	bz *if10_end

	// *if10_consequent
	b *for_7_continue

*if10_end:
	// contracts/InjectedRewardsPool.algo.ts:312
	// this.rewardRate(staker.account).value[k] = wideRatio([this.injectedRewards.value[k], userSharePercentage], [100])
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x72657761726452617465 // "rewardRate"
	app_local_get
	frame_dig 5 // k: uint64
	int 8
	* // acc * typeLength
	frame_dig 5 // k: uint64
	int 8
	* // acc * typeLength
	int 8
	byte 0x696e6a656374656452657761726473 // "injectedRewards"
	cover 2
	box_extract
	btoi
	frame_dig 4 // userSharePercentage: uint64
	mulw
	int 0
	int 100
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	itob
	replace3
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x72657761726452617465 // "rewardRate"
	uncover 2
	app_local_put

	// *if11_condition
	// contracts/InjectedRewardsPool.algo.ts:313
	// this.rewardRate(staker.account).value[k] === 0
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x72657761726452617465 // "rewardRate"
	app_local_get
	frame_dig 5 // k: uint64
	int 8
	* // acc * typeLength
	int 8
	extract3
	btoi
	int 0
	==
	bz *if11_end

	// *if11_consequent
	// contracts/InjectedRewardsPool.algo.ts:314
	// this.rewardRate(staker.account).value[k] = 1
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x72657761726452617465 // "rewardRate"
	app_local_get
	frame_dig 5 // k: uint64
	int 8
	* // acc * typeLength
	byte 0x0000000000000001
	replace3
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x72657761726452617465 // "rewardRate"
	uncover 2
	app_local_put

*if11_end:

*for_7_continue:
	// contracts/InjectedRewardsPool.algo.ts:310
	// k += 1
	frame_dig 5 // k: uint64
	int 1
	+
	frame_bury 5 // k: uint64
	b *for_7

*for_7_end:
	// contracts/InjectedRewardsPool.algo.ts:318
	// this.stakers.value[i] = staker
	frame_dig 0 // i: uint64
	int 40
	* // acc * typeLength
	frame_dig 1 // staker: (address,uint64)
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace

*for_5_continue:
	// contracts/InjectedRewardsPool.algo.ts:285
	// i += 1
	frame_dig 0 // i: uint64
	int 1
	+
	frame_bury 0 // i: uint64
	b *for_5

*for_5_end:
	retsub

// accrueRewards()void
*abi_route_accrueRewards:
	// execute accrueRewards()void
	callsub accrueRewards
	int 1
	return

// accrueRewards(): void
accrueRewards:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts/InjectedRewardsPool.algo.ts:324
	// this.calculateRewardRates()
	callsub calculateRewardRates

	// contracts/InjectedRewardsPool.algo.ts:325
	// for (let i = 0; i < this.stakers.value.length; i += 1)
	int 0
	frame_bury 0 // i: uint64

*for_8:
	// contracts/InjectedRewardsPool.algo.ts:325
	// i < this.stakers.value.length
	frame_dig 0 // i: uint64
	int 1
	<
	bz *for_8_end

	// contracts/InjectedRewardsPool.algo.ts:329
	// staker = clone(this.stakers.value[i])
	frame_dig 0 // i: uint64
	int 40
	* // acc * typeLength
	int 40
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	frame_bury 1 // staker: (address,uint64)

	// *if12_condition
	// contracts/InjectedRewardsPool.algo.ts:330
	// staker.account === globals.zeroAddress
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	global ZeroAddress
	==
	bz *if12_end

	// *if12_consequent
	b *for_8_continue

*if12_end:
	// *if13_condition
	// contracts/InjectedRewardsPool.algo.ts:332
	// staker.stake > 0
	frame_dig 1 // staker: (address,uint64)
	extract 32 8
	btoi
	int 0
	>
	bz *if13_end

	// *if13_consequent
	// contracts/InjectedRewardsPool.algo.ts:333
	// this.stakeDuration(staker.account).value = globals.latestTimestamp - this.stakeStartTime(staker.account).value
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x7374616b654475726174696f6e // "stakeDuration"
	global LatestTimestamp
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x7374616b65537461727454696d65 // "stakeStartTime"
	app_local_get
	-
	app_local_put

	// *if14_condition
	// contracts/InjectedRewardsPool.algo.ts:334
	// this.stakeDuration(staker.account).value < this.minStakePeriodForRewards.value
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x7374616b654475726174696f6e // "stakeDuration"
	app_local_get
	byte 0x6d696e5374616b65506572696f64466f7252657761726473 // "minStakePeriodForRewards"
	app_global_get
	<
	bz *if14_end

	// *if14_consequent
	// contracts/InjectedRewardsPool.algo.ts:334
	// return;
	retsub

*if14_end:
	// contracts/InjectedRewardsPool.algo.ts:336
	// this.algoAccuredRewards(staker.account).value = this.algoAccuredRewards(staker.account).value + this.algoRewardRate(staker.account).value
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x616c676f4163637572656452657761726473 // "algoAccuredRewards"
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x616c676f4163637572656452657761726473 // "algoAccuredRewards"
	app_local_get
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x616c676f52657761726452617465 // "algoRewardRate"
	app_local_get
	+
	app_local_put

	// contracts/InjectedRewardsPool.algo.ts:337
	// this.algoInjectedRewards.value = this.algoInjectedRewards.value - this.algoRewardRate(staker.account).value
	byte 0x616c676f496e6a656374656452657761726473 // "algoInjectedRewards"
	dup
	app_global_get
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x616c676f52657761726452617465 // "algoRewardRate"
	app_local_get
	-
	app_global_put

	// *if15_condition
	// contracts/InjectedRewardsPool.algo.ts:339
	// this.stakedAssetId.value === 0
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	app_global_get
	int 0
	==
	bz *if15_end

	// *if15_consequent
	// contracts/InjectedRewardsPool.algo.ts:340
	// staker.stake = staker.stake + this.algoRewardRate(staker.account).value
	frame_dig 1 // staker: (address,uint64)
	int 32 // headOffset
	frame_dig 1 // staker: (address,uint64)
	extract 32 8
	btoi
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x616c676f52657761726452617465 // "algoRewardRate"
	app_local_get
	+
	itob
	replace3
	frame_bury 1 // staker: (address,uint64)

	// contracts/InjectedRewardsPool.algo.ts:341
	// this.totalStaked.value = this.totalStaked.value + this.algoRewardRate(staker.account).value
	byte 0x746f74616c5374616b6564 // "totalStaked"
	dup
	app_global_get
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x616c676f52657761726452617465 // "algoRewardRate"
	app_local_get
	+
	app_global_put

*if15_end:
	// contracts/InjectedRewardsPool.algo.ts:344
	// for (var j = 0; j < this.rewardAssets.value.length; j += 1)
	int 0
	frame_bury 2 // j: uint64

*for_9:
	// contracts/InjectedRewardsPool.algo.ts:344
	// j < this.rewardAssets.value.length
	frame_dig 2 // j: uint64
	int 5
	<
	bz *for_9_end

	// contracts/InjectedRewardsPool.algo.ts:346
	// this.accruedRewards(staker.account).value[j] = this.accruedRewards(staker.account).value[j] + this.rewardRate(staker.account).value[j]
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x6163637275656452657761726473 // "accruedRewards"
	app_local_get
	frame_dig 2 // j: uint64
	int 8
	* // acc * typeLength
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x6163637275656452657761726473 // "accruedRewards"
	app_local_get
	frame_dig 2 // j: uint64
	int 8
	* // acc * typeLength
	int 8
	extract3
	btoi
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x72657761726452617465 // "rewardRate"
	app_local_get
	frame_dig 2 // j: uint64
	int 8
	* // acc * typeLength
	int 8
	extract3
	btoi
	+
	itob
	replace3
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x6163637275656452657761726473 // "accruedRewards"
	uncover 2
	app_local_put

	// contracts/InjectedRewardsPool.algo.ts:347
	// this.injectedRewards.value[j] = this.injectedRewards.value[j] - this.rewardRate(staker.account).value[j]
	frame_dig 2 // j: uint64
	int 8
	* // acc * typeLength
	frame_dig 2 // j: uint64
	int 8
	* // acc * typeLength
	int 8
	byte 0x696e6a656374656452657761726473 // "injectedRewards"
	cover 2
	box_extract
	btoi
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x72657761726452617465 // "rewardRate"
	app_local_get
	frame_dig 2 // j: uint64
	int 8
	* // acc * typeLength
	int 8
	extract3
	btoi
	-
	itob
	byte 0x696e6a656374656452657761726473 // "injectedRewards"
	cover 2
	box_replace

	// *if16_condition
	// contracts/InjectedRewardsPool.algo.ts:349
	// this.rewardAssets.value[j] === this.stakedAssetId.value
	frame_dig 2 // j: uint64
	int 8
	* // acc * typeLength
	int 8
	byte 0x726577617264417373657473 // "rewardAssets"
	cover 2
	box_extract
	btoi
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	app_global_get
	==
	bz *if16_end

	// *if16_consequent
	// contracts/InjectedRewardsPool.algo.ts:351
	// staker.stake = staker.stake + this.rewardRate(staker.account).value[j]
	frame_dig 1 // staker: (address,uint64)
	int 32 // headOffset
	frame_dig 1 // staker: (address,uint64)
	extract 32 8
	btoi
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x72657761726452617465 // "rewardRate"
	app_local_get
	frame_dig 2 // j: uint64
	int 8
	* // acc * typeLength
	int 8
	extract3
	btoi
	+
	itob
	replace3
	frame_bury 1 // staker: (address,uint64)

	// contracts/InjectedRewardsPool.algo.ts:352
	// this.totalStaked.value = this.totalStaked.value + this.rewardRate(staker.account).value[j]
	byte 0x746f74616c5374616b6564 // "totalStaked"
	dup
	app_global_get
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x72657761726452617465 // "rewardRate"
	app_local_get
	frame_dig 2 // j: uint64
	int 8
	* // acc * typeLength
	int 8
	extract3
	btoi
	+
	app_global_put

*if16_end:

*for_9_continue:
	// contracts/InjectedRewardsPool.algo.ts:344
	// j += 1
	frame_dig 2 // j: uint64
	int 1
	+
	frame_bury 2 // j: uint64
	b *for_9

*for_9_end:
	// contracts/InjectedRewardsPool.algo.ts:355
	// this.lastUpdateTime(staker.account).value = globals.latestTimestamp
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x6c61737455706461746554696d65 // "lastUpdateTime"
	global LatestTimestamp
	app_local_put

	// contracts/InjectedRewardsPool.algo.ts:356
	// this.stakers.value[i] = staker
	frame_dig 0 // i: uint64
	int 40
	* // acc * typeLength
	frame_dig 1 // staker: (address,uint64)
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace

*if13_end:

*for_8_continue:
	// contracts/InjectedRewardsPool.algo.ts:325
	// i += 1
	frame_dig 0 // i: uint64
	int 1
	+
	frame_bury 0 // i: uint64
	b *for_8

*for_8_end:
	retsub

// claimRewards()void
*abi_route_claimRewards:
	// execute claimRewards()void
	callsub claimRewards
	int 1
	return

// claimRewards(): void
claimRewards:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts/InjectedRewardsPool.algo.ts:363
	// for (let i = 0; i < this.stakers.value.length; i += 1)
	int 0
	frame_bury 0 // i: uint64

*for_10:
	// contracts/InjectedRewardsPool.algo.ts:363
	// i < this.stakers.value.length
	frame_dig 0 // i: uint64
	int 1
	<
	bz *for_10_end

	// contracts/InjectedRewardsPool.algo.ts:367
	// staker = clone(this.stakers.value[i])
	frame_dig 0 // i: uint64
	int 40
	* // acc * typeLength
	int 40
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	frame_bury 1 // staker: (address,uint64)

	// *if17_condition
	// contracts/InjectedRewardsPool.algo.ts:369
	// staker.account === this.txn.sender
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	txn Sender
	==
	bz *if17_end

	// *if17_consequent
	// *if18_condition
	// contracts/InjectedRewardsPool.algo.ts:370
	// this.algoAccuredRewards(staker.account).value > 0
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x616c676f4163637572656452657761726473 // "algoAccuredRewards"
	app_local_get
	int 0
	>
	bz *if18_end

	// *if18_consequent
	// contracts/InjectedRewardsPool.algo.ts:371
	// sendPayment({
	//             amount: this.algoAccuredRewards(staker.account).value,
	//             receiver: this.txn.sender,
	//             sender: this.app.address,
	//             fee: 1_000,
	//           })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/InjectedRewardsPool.algo.ts:372
	// amount: this.algoAccuredRewards(staker.account).value
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x616c676f4163637572656452657761726473 // "algoAccuredRewards"
	app_local_get
	itxn_field Amount

	// contracts/InjectedRewardsPool.algo.ts:373
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/InjectedRewardsPool.algo.ts:374
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/InjectedRewardsPool.algo.ts:375
	// fee: 1_000
	int 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/InjectedRewardsPool.algo.ts:377
	// this.algoAccuredRewards(staker.account).value = 0
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x616c676f4163637572656452657761726473 // "algoAccuredRewards"
	int 0
	app_local_put

*if18_end:
	// contracts/InjectedRewardsPool.algo.ts:380
	// for (var j = 0; j < this.rewardAssets.value.length; j += 1)
	int 0
	frame_bury 2 // j: uint64

*for_11:
	// contracts/InjectedRewardsPool.algo.ts:380
	// j < this.rewardAssets.value.length
	frame_dig 2 // j: uint64
	int 5
	<
	bz *for_11_end

	// *if19_condition
	// contracts/InjectedRewardsPool.algo.ts:381
	// this.accruedRewards(staker.account).value[j] > 0
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x6163637275656452657761726473 // "accruedRewards"
	app_local_get
	frame_dig 2 // j: uint64
	int 8
	* // acc * typeLength
	int 8
	extract3
	btoi
	int 0
	>
	bz *if19_end

	// *if19_consequent
	// contracts/InjectedRewardsPool.algo.ts:382
	// sendAssetTransfer({
	//               xferAsset: AssetID.fromUint64(this.rewardAssets.value[j]),
	//               assetReceiver: this.txn.sender,
	//               sender: this.app.address,
	//               assetAmount: this.accruedRewards(staker.account).value[j],
	//               fee: 1_000,
	//             })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/InjectedRewardsPool.algo.ts:383
	// xferAsset: AssetID.fromUint64(this.rewardAssets.value[j])
	frame_dig 2 // j: uint64
	int 8
	* // acc * typeLength
	int 8
	byte 0x726577617264417373657473 // "rewardAssets"
	cover 2
	box_extract
	btoi
	itxn_field XferAsset

	// contracts/InjectedRewardsPool.algo.ts:384
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/InjectedRewardsPool.algo.ts:385
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/InjectedRewardsPool.algo.ts:386
	// assetAmount: this.accruedRewards(staker.account).value[j]
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x6163637275656452657761726473 // "accruedRewards"
	app_local_get
	frame_dig 2 // j: uint64
	int 8
	* // acc * typeLength
	int 8
	extract3
	btoi
	itxn_field AssetAmount

	// contracts/InjectedRewardsPool.algo.ts:387
	// fee: 1_000
	int 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if19_end:
	// contracts/InjectedRewardsPool.algo.ts:390
	// this.accruedRewards(staker.account).value[j] = 0
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x6163637275656452657761726473 // "accruedRewards"
	app_local_get
	frame_dig 2 // j: uint64
	int 8
	* // acc * typeLength
	byte 0x0000000000000000
	replace3
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x6163637275656452657761726473 // "accruedRewards"
	uncover 2
	app_local_put

	// contracts/InjectedRewardsPool.algo.ts:391
	// this.stakers.value[i] = staker
	frame_dig 0 // i: uint64
	int 40
	* // acc * typeLength
	frame_dig 1 // staker: (address,uint64)
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace

*for_11_continue:
	// contracts/InjectedRewardsPool.algo.ts:380
	// j += 1
	frame_dig 2 // j: uint64
	int 1
	+
	frame_bury 2 // j: uint64
	b *for_11

*for_11_end:

*if17_end:
	// contracts/InjectedRewardsPool.algo.ts:394
	// this.lastUpdateTime(staker.account).value = globals.latestTimestamp
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x6c61737455706461746554696d65 // "lastUpdateTime"
	global LatestTimestamp
	app_local_put

*for_10_continue:
	// contracts/InjectedRewardsPool.algo.ts:363
	// i += 1
	frame_dig 0 // i: uint64
	int 1
	+
	frame_bury 0 // i: uint64
	b *for_10

*for_10_end:
	retsub

// unstake(uint64)void
*abi_route_unstake:
	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// execute unstake(uint64)void
	callsub unstake
	int 1
	return

// unstake(quantity: uint64): void
unstake:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts/InjectedRewardsPool.algo.ts:402
	// for (let i = 0; i < this.stakers.value.length; i += 1)
	int 0
	frame_bury 0 // i: uint64

*for_12:
	// contracts/InjectedRewardsPool.algo.ts:402
	// i < this.stakers.value.length
	frame_dig 0 // i: uint64
	int 1
	<
	bz *for_12_end

	// contracts/InjectedRewardsPool.algo.ts:406
	// staker = clone(this.stakers.value[i])
	frame_dig 0 // i: uint64
	int 40
	* // acc * typeLength
	int 40
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	frame_bury 1 // staker: (address,uint64)

	// *if20_condition
	// contracts/InjectedRewardsPool.algo.ts:409
	// staker.stake === 0
	frame_dig 1 // staker: (address,uint64)
	extract 32 8
	btoi
	int 0
	==
	bz *if20_end

	// *if20_consequent
	b *for_12_continue

*if20_end:
	// *if21_condition
	// contracts/InjectedRewardsPool.algo.ts:411
	// staker.stake > 0
	frame_dig 1 // staker: (address,uint64)
	extract 32 8
	btoi
	int 0
	>
	bz *if21_end

	// *if21_consequent
	// *if22_condition
	// contracts/InjectedRewardsPool.algo.ts:412
	// this.stakedAssetId.value === 0
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	app_global_get
	int 0
	==
	bz *if22_else

	// *if22_consequent
	// contracts/InjectedRewardsPool.algo.ts:413
	// sendPayment({
	//             amount: quantity === 0 ? staker.stake : quantity,
	//             receiver: this.txn.sender,
	//             sender: this.app.address,
	//             fee: 1_000,
	//           })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/InjectedRewardsPool.algo.ts:414
	// amount: quantity === 0 ? staker.stake : quantity
	frame_dig -1 // quantity: uint64
	int 0
	==
	bz *ternary0_false
	frame_dig 1 // staker: (address,uint64)
	extract 32 8
	btoi
	b *ternary0_end

*ternary0_false:
	frame_dig -1 // quantity: uint64

*ternary0_end:
	itxn_field Amount

	// contracts/InjectedRewardsPool.algo.ts:415
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/InjectedRewardsPool.algo.ts:416
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/InjectedRewardsPool.algo.ts:417
	// fee: 1_000
	int 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if22_end

*if22_else:
	// contracts/InjectedRewardsPool.algo.ts:421
	// sendAssetTransfer({
	//             xferAsset: AssetID.fromUint64(this.stakedAssetId.value),
	//             assetReceiver: this.txn.sender,
	//             sender: this.app.address,
	//             assetAmount: quantity === 0 ? staker.stake : quantity,
	//             fee: 1_000,
	//           })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/InjectedRewardsPool.algo.ts:422
	// xferAsset: AssetID.fromUint64(this.stakedAssetId.value)
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/InjectedRewardsPool.algo.ts:423
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/InjectedRewardsPool.algo.ts:424
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/InjectedRewardsPool.algo.ts:425
	// assetAmount: quantity === 0 ? staker.stake : quantity
	frame_dig -1 // quantity: uint64
	int 0
	==
	bz *ternary1_false
	frame_dig 1 // staker: (address,uint64)
	extract 32 8
	btoi
	b *ternary1_end

*ternary1_false:
	frame_dig -1 // quantity: uint64

*ternary1_end:
	itxn_field AssetAmount

	// contracts/InjectedRewardsPool.algo.ts:426
	// fee: 1_000
	int 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if22_end:

*if21_end:
	// *if23_condition
	// contracts/InjectedRewardsPool.algo.ts:432
	// this.algoAccuredRewards(staker.account).value > 0
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x616c676f4163637572656452657761726473 // "algoAccuredRewards"
	app_local_get
	int 0
	>
	bz *if23_end

	// *if23_consequent
	// contracts/InjectedRewardsPool.algo.ts:433
	// sendPayment({
	//           amount: this.algoAccuredRewards(staker.account).value,
	//           receiver: this.txn.sender,
	//           sender: this.app.address,
	//           fee: 1_000,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/InjectedRewardsPool.algo.ts:434
	// amount: this.algoAccuredRewards(staker.account).value
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x616c676f4163637572656452657761726473 // "algoAccuredRewards"
	app_local_get
	itxn_field Amount

	// contracts/InjectedRewardsPool.algo.ts:435
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/InjectedRewardsPool.algo.ts:436
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/InjectedRewardsPool.algo.ts:437
	// fee: 1_000
	int 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/InjectedRewardsPool.algo.ts:439
	// this.algoAccuredRewards(staker.account).value = 0
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x616c676f4163637572656452657761726473 // "algoAccuredRewards"
	int 0
	app_local_put

*if23_end:
	// contracts/InjectedRewardsPool.algo.ts:442
	// for (let j = 0; j < this.rewardAssets.value.length; j += 1)
	int 0
	frame_bury 2 // j: uint64

*for_13:
	// contracts/InjectedRewardsPool.algo.ts:442
	// j < this.rewardAssets.value.length
	frame_dig 2 // j: uint64
	int 5
	<
	bz *for_13_end

	// *if24_condition
	// contracts/InjectedRewardsPool.algo.ts:443
	// this.accruedRewards(staker.account).value[j] > 0
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x6163637275656452657761726473 // "accruedRewards"
	app_local_get
	frame_dig 2 // j: uint64
	int 8
	* // acc * typeLength
	int 8
	extract3
	btoi
	int 0
	>
	bz *if24_end

	// *if24_consequent
	// contracts/InjectedRewardsPool.algo.ts:444
	// sendAssetTransfer({
	//             xferAsset: AssetID.fromUint64(this.rewardAssets.value[j]),
	//             assetReceiver: this.txn.sender,
	//             sender: this.app.address,
	//             assetAmount: this.accruedRewards(staker.account).value[j],
	//             fee: 1_000,
	//           })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/InjectedRewardsPool.algo.ts:445
	// xferAsset: AssetID.fromUint64(this.rewardAssets.value[j])
	frame_dig 2 // j: uint64
	int 8
	* // acc * typeLength
	int 8
	byte 0x726577617264417373657473 // "rewardAssets"
	cover 2
	box_extract
	btoi
	itxn_field XferAsset

	// contracts/InjectedRewardsPool.algo.ts:446
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/InjectedRewardsPool.algo.ts:447
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/InjectedRewardsPool.algo.ts:448
	// assetAmount: this.accruedRewards(staker.account).value[j]
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x6163637275656452657761726473 // "accruedRewards"
	app_local_get
	frame_dig 2 // j: uint64
	int 8
	* // acc * typeLength
	int 8
	extract3
	btoi
	itxn_field AssetAmount

	// contracts/InjectedRewardsPool.algo.ts:449
	// fee: 1_000
	int 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/InjectedRewardsPool.algo.ts:451
	// this.accruedRewards(staker.account).value[j] = 0
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x6163637275656452657761726473 // "accruedRewards"
	app_local_get
	frame_dig 2 // j: uint64
	int 8
	* // acc * typeLength
	byte 0x0000000000000000
	replace3
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x6163637275656452657761726473 // "accruedRewards"
	uncover 2
	app_local_put

*if24_end:

*for_13_continue:
	// contracts/InjectedRewardsPool.algo.ts:442
	// j += 1
	frame_dig 2 // j: uint64
	int 1
	+
	frame_bury 2 // j: uint64
	b *for_13

*for_13_end:
	// contracts/InjectedRewardsPool.algo.ts:456
	// this.totalStakingWeight.value = this.totalStakingWeight.value - (this.userStakingWeight(staker.account).value as uint128)
	byte 0x746f74616c5374616b696e67576569676874 // "totalStakingWeight"
	dup
	app_global_get
	frame_dig 1 // staker: (address,uint64)
	extract 0 32
	byte 0x757365725374616b696e67576569676874 // "userStakingWeight"
	app_local_get
	itob
	b-
	dup
	bitlen
	int 128
	<=

	// this.totalStakingWeight.value - (this.userStakingWeight(staker.account).value as uint128) overflowed 128 bits
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 16
	-
	swap
	substring3
	app_global_put

	// contracts/InjectedRewardsPool.algo.ts:457
	// this.totalStaked.value = this.totalStaked.value - staker.stake
	byte 0x746f74616c5374616b6564 // "totalStaked"
	dup
	app_global_get
	frame_dig 1 // staker: (address,uint64)
	extract 32 8
	btoi
	-
	app_global_put

	// *if25_condition
	// contracts/InjectedRewardsPool.algo.ts:459
	// quantity === 0
	frame_dig -1 // quantity: uint64
	int 0
	==
	bz *if25_else

	// *if25_consequent
	// contracts/InjectedRewardsPool.algo.ts:460
	// this.stakers.value[i] = {
	//           account: globals.zeroAddress,
	//           stake: 0,
	//         }
	frame_dig 0 // i: uint64
	int 40
	* // acc * typeLength
	global ZeroAddress
	byte 0x0000000000000000
	concat
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace

	// contracts/InjectedRewardsPool.algo.ts:464
	// this.accruedRewards(this.txn.sender).value = [0, 0, 0, 0, 0]
	txn Sender
	byte 0x6163637275656452657761726473 // "accruedRewards"
	byte 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000
	app_local_put

	// contracts/InjectedRewardsPool.algo.ts:465
	// this.rewardRate(this.txn.sender).value = [0, 0, 0, 0, 0]
	txn Sender
	byte 0x72657761726452617465 // "rewardRate"
	byte 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000
	app_local_put

	// contracts/InjectedRewardsPool.algo.ts:466
	// this.stakeDuration(this.txn.sender).value = 0
	txn Sender
	byte 0x7374616b654475726174696f6e // "stakeDuration"
	int 0
	app_local_put

	// contracts/InjectedRewardsPool.algo.ts:467
	// this.stakeStartTime(this.txn.sender).value = 0
	txn Sender
	byte 0x7374616b65537461727454696d65 // "stakeStartTime"
	int 0
	app_local_put

	// contracts/InjectedRewardsPool.algo.ts:468
	// this.userStakingWeight(this.txn.sender).value = 0
	txn Sender
	byte 0x757365725374616b696e67576569676874 // "userStakingWeight"
	int 0
	app_local_put

	// contracts/InjectedRewardsPool.algo.ts:469
	// this.lastRewardRate(this.txn.sender).value = 0
	txn Sender
	byte 0x6c61737452657761726452617465 // "lastRewardRate"
	int 0
	app_local_put

	// contracts/InjectedRewardsPool.algo.ts:470
	// this.algoAccuredRewards(this.txn.sender).value = 0
	txn Sender
	byte 0x616c676f4163637572656452657761726473 // "algoAccuredRewards"
	int 0
	app_local_put

	// contracts/InjectedRewardsPool.algo.ts:471
	// this.lastUpdateTime(this.txn.sender).value = 0
	txn Sender
	byte 0x6c61737455706461746554696d65 // "lastUpdateTime"
	int 0
	app_local_put

	// contracts/InjectedRewardsPool.algo.ts:472
	// this.algoRewardRate(this.txn.sender).value = 0
	txn Sender
	byte 0x616c676f52657761726452617465 // "algoRewardRate"
	int 0
	app_local_put

	// contracts/InjectedRewardsPool.algo.ts:473
	// this.userShare(this.txn.sender).value = 0
	txn Sender
	byte 0x757365725368617265 // "userShare"
	int 0
	app_local_put
	b *if25_end

*if25_else:
	// contracts/InjectedRewardsPool.algo.ts:476
	// staker.stake = staker.stake - quantity
	frame_dig 1 // staker: (address,uint64)
	int 32 // headOffset
	frame_dig 1 // staker: (address,uint64)
	extract 32 8
	btoi
	frame_dig -1 // quantity: uint64
	-
	itob
	replace3
	frame_bury 1 // staker: (address,uint64)

	// contracts/InjectedRewardsPool.algo.ts:477
	// this.accruedRewards(this.txn.sender).value = [0, 0, 0, 0, 0]
	txn Sender
	byte 0x6163637275656452657761726473 // "accruedRewards"
	byte 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000
	app_local_put

*if25_end:
	// contracts/InjectedRewardsPool.algo.ts:479
	// this.lastUpdateTime(this.txn.sender).value = globals.latestTimestamp
	txn Sender
	byte 0x6c61737455706461746554696d65 // "lastUpdateTime"
	global LatestTimestamp
	app_local_put

	// contracts/InjectedRewardsPool.algo.ts:480
	// this.stakers.value[i] = staker
	frame_dig 0 // i: uint64
	int 40
	* // acc * typeLength
	frame_dig 1 // staker: (address,uint64)
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace

*for_12_continue:
	// contracts/InjectedRewardsPool.algo.ts:402
	// i += 1
	frame_dig 0 // i: uint64
	int 1
	+
	frame_bury 0 // i: uint64
	b *for_12

*for_12_end:
	retsub

*create_NoOp:
	method "createApplication(address)void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	method "initApplication(uint64,uint64[5],uint64,address)void"
	method "updateParams(uint64)void"
	method "getMBRForPoolCreation()(uint64)"
	method "initStorage(pay)void"
	method "injectRewards(axfer,uint64,uint64)void"
	method "injectAlgoRewards(pay,uint64)void"
	method "setPrices(uint64,uint64[5])void"
	method "stake(axfer,uint64)void"
	method "accrueRewards()void"
	method "claimRewards()void"
	method "unstake(uint64)void"
	txna ApplicationArgs 0
	match *abi_route_initApplication *abi_route_updateParams *abi_route_getMBRForPoolCreation *abi_route_initStorage *abi_route_injectRewards *abi_route_injectAlgoRewards *abi_route_setPrices *abi_route_stake *abi_route_accrueRewards *abi_route_claimRewards *abi_route_unstake

	// this contract does not implement the given ABI method for call NoOp
	err

*call_OptIn:
	method "optInToApplication()void"
	txna ApplicationArgs 0
	match *abi_route_optInToApplication

	// this contract does not implement the given ABI method for call OptIn
	err

*call_DeleteApplication:
	method "deleteApplication()void"
	txna ApplicationArgs 0
	match *abi_route_deleteApplication

	// this contract does not implement the given ABI method for call DeleteApplication
	err