#pragma version 9

// This TEAL was generated by TEALScript v0.103.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *call_OptIn *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *call_DeleteApplication *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication(address)void
*abi_route_createApplication:
	// adminAddress: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (adminAddress) for createApplication must be a address
	assert

	// execute createApplication(address)void
	callsub createApplication
	int 1
	return

// createApplication(adminAddress: Address): void
createApplication:
	proto 1 0

	// contracts/InjectedRewardsPool.algo.ts:68
	// this.adminAddress.value = adminAddress
	byte 0x61646d696e41646472657373 // "adminAddress"
	frame_dig -1 // adminAddress: Address
	app_global_put
	retsub

// initApplication(uint64,uint64[5],uint64,address)void
*abi_route_initApplication:
	// oracleAdmin: address
	txna ApplicationArgs 4
	dup
	len
	int 32
	==

	// argument 0 (oracleAdmin) for initApplication must be a address
	assert

	// minStakePeriodForRewards: uint64
	txna ApplicationArgs 3
	btoi

	// rewardAssets: uint64[5]
	txna ApplicationArgs 2
	dup
	len
	int 40
	==

	// argument 2 (rewardAssets) for initApplication must be a uint64[5]
	assert

	// stakedAsset: uint64
	txna ApplicationArgs 1
	btoi

	// execute initApplication(uint64,uint64[5],uint64,address)void
	callsub initApplication
	int 1
	return

// initApplication(stakedAsset: uint64, rewardAssets: StaticArray<uint64, 5>, minStakePeriodForRewards: uint64, oracleAdmin: Address): void
initApplication:
	proto 4 0

	// contracts/InjectedRewardsPool.algo.ts:75
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can init application')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can init application
	assert

	// contracts/InjectedRewardsPool.algo.ts:77
	// this.stakedAssetId.value = stakedAsset
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	frame_dig -1 // stakedAsset: uint64
	app_global_put

	// contracts/InjectedRewardsPool.algo.ts:78
	// this.rewardAssets.value = rewardAssets
	byte 0x726577617264417373657473 // "rewardAssets"
	frame_dig -2 // rewardAssets: StaticArray<uint64, 5>
	box_put

	// contracts/InjectedRewardsPool.algo.ts:79
	// this.numRewards.value = rewardAssets.length
	byte 0x6e756d52657761726473 // "numRewards"
	int 5
	app_global_put

	// contracts/InjectedRewardsPool.algo.ts:80
	// this.totalStaked.value = 0
	byte 0x746f74616c5374616b6564 // "totalStaked"
	int 0
	app_global_put

	// contracts/InjectedRewardsPool.algo.ts:81
	// this.totalStakingWeight.value = 0 as uint128
	byte 0x746f74616c5374616b696e67576569676874 // "totalStakingWeight"
	byte 0x00000000000000000000000000000000
	app_global_put

	// contracts/InjectedRewardsPool.algo.ts:82
	// this.oracleAdminAddress.value = oracleAdmin
	byte 0x6f7261636c6541646d696e41646472657373 // "oracleAdminAddress"
	frame_dig -4 // oracleAdmin: Address
	app_global_put

	// contracts/InjectedRewardsPool.algo.ts:83
	// this.minStakePeriodForRewards.value = minStakePeriodForRewards
	byte 0x6d696e5374616b65506572696f64466f7252657761726473 // "minStakePeriodForRewards"
	frame_dig -3 // minStakePeriodForRewards: uint64
	app_global_put

	// contracts/InjectedRewardsPool.algo.ts:84
	// this.injectedRewards.create()
	byte 0x696e6a656374656452657761726473 // "injectedRewards"
	int 40
	box_create
	pop

	// contracts/InjectedRewardsPool.algo.ts:85
	// this.lastRewardInjectionTime.value = 0
	byte 0x6c617374526577617264496e6a656374696f6e54696d65 // "lastRewardInjectionTime"
	int 0
	app_global_put

	// contracts/InjectedRewardsPool.algo.ts:86
	// this.freeze.value = false
	byte 0x667265657a65 // "freeze"
	int 0
	byte 0x00
	int 0
	uncover 2
	setbit
	app_global_put

	// contracts/InjectedRewardsPool.algo.ts:88
	// sendAssetTransfer({
	//       xferAsset: AssetID.fromUint64(stakedAsset),
	//       assetReceiver: this.app.address,
	//       assetAmount: 0,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/InjectedRewardsPool.algo.ts:89
	// xferAsset: AssetID.fromUint64(stakedAsset)
	frame_dig -1 // stakedAsset: uint64
	itxn_field XferAsset

	// contracts/InjectedRewardsPool.algo.ts:90
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/InjectedRewardsPool.algo.ts:91
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// optInToApplication()void
*abi_route_optInToApplication:
	// execute optInToApplication()void
	callsub optInToApplication
	int 1
	return

// optInToApplication(): void
optInToApplication:
	proto 0 0

	// contracts/InjectedRewardsPool.algo.ts:97
	// this.accruedRewards(this.txn.sender).value = [0, 0, 0, 0, 0]
	txn Sender
	byte 0x6163637275656452657761726473 // "accruedRewards"
	byte 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000
	app_local_put
	retsub

// updateMinStakePeriod(uint64)void
*abi_route_updateMinStakePeriod:
	// minStakePeriodForRewards: uint64
	txna ApplicationArgs 1
	btoi

	// execute updateMinStakePeriod(uint64)void
	callsub updateMinStakePeriod
	int 1
	return

// updateMinStakePeriod(minStakePeriodForRewards: uint64): void
updateMinStakePeriod:
	proto 1 0

	// contracts/InjectedRewardsPool.algo.ts:102
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can update min stake period')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can update min stake period
	assert

	// contracts/InjectedRewardsPool.algo.ts:103
	// this.minStakePeriodForRewards.value = minStakePeriodForRewards
	byte 0x6d696e5374616b65506572696f64466f7252657761726473 // "minStakePeriodForRewards"
	frame_dig -1 // minStakePeriodForRewards: uint64
	app_global_put
	retsub

// updateTotalStakingWeight(uint64)void
*abi_route_updateTotalStakingWeight:
	// totalStakingWeight: uint64
	txna ApplicationArgs 1
	btoi

	// execute updateTotalStakingWeight(uint64)void
	callsub updateTotalStakingWeight
	int 1
	return

// updateTotalStakingWeight(totalStakingWeight: uint64): void
updateTotalStakingWeight:
	proto 1 0

	// contracts/InjectedRewardsPool.algo.ts:106
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can update total staking weight')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can update total staking weight
	assert

	// contracts/InjectedRewardsPool.algo.ts:107
	// this.totalStakingWeight.value = totalStakingWeight as uint128
	byte 0x746f74616c5374616b696e67576569676874 // "totalStakingWeight"
	frame_dig -1 // totalStakingWeight: uint64
	itob
	dup
	bitlen
	int 128
	<=

	// totalStakingWeight as uint128 overflowed 128 bits
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 16
	-
	swap
	substring3
	app_global_put
	retsub

// updateAdminAddress(address)void
*abi_route_updateAdminAddress:
	// adminAddress: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (adminAddress) for updateAdminAddress must be a address
	assert

	// execute updateAdminAddress(address)void
	callsub updateAdminAddress
	int 1
	return

// updateAdminAddress(adminAddress: Address): void
updateAdminAddress:
	proto 1 0

	// contracts/InjectedRewardsPool.algo.ts:110
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can update admin address')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can update admin address
	assert

	// contracts/InjectedRewardsPool.algo.ts:111
	// this.adminAddress.value = adminAddress
	byte 0x61646d696e41646472657373 // "adminAddress"
	frame_dig -1 // adminAddress: Address
	app_global_put
	retsub

// updateOracleAdminAddress(address)void
*abi_route_updateOracleAdminAddress:
	// oracleAdminAddress: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (oracleAdminAddress) for updateOracleAdminAddress must be a address
	assert

	// execute updateOracleAdminAddress(address)void
	callsub updateOracleAdminAddress
	int 1
	return

// updateOracleAdminAddress(oracleAdminAddress: Address): void
updateOracleAdminAddress:
	proto 1 0

	// contracts/InjectedRewardsPool.algo.ts:114
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can update oracle admin address')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can update oracle admin address
	assert

	// contracts/InjectedRewardsPool.algo.ts:115
	// this.oracleAdminAddress.value = oracleAdminAddress
	byte 0x6f7261636c6541646d696e41646472657373 // "oracleAdminAddress"
	frame_dig -1 // oracleAdminAddress: Address
	app_global_put
	retsub

// costForBoxStorage(totalNumBytes: uint64): uint64
costForBoxStorage:
	proto 1 1

	// contracts/InjectedRewardsPool.algo.ts:122
	// return SCBOX_PERBOX + totalNumBytes * SCBOX_PERBYTE
	int 2500
	frame_dig -1 // totalNumBytes: uint64
	int 400
	*
	+
	retsub

// getMBRForPoolCreation()(uint64)
*abi_route_getMBRForPoolCreation:
	// The ABI return prefix
	byte 0x151f7c75

	// execute getMBRForPoolCreation()(uint64)
	callsub getMBRForPoolCreation
	concat
	log
	int 1
	return

// getMBRForPoolCreation(): mbrReturn
getMBRForPoolCreation:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts/InjectedRewardsPool.algo.ts:126
	// nonAlgoRewardMBR = 0
	int 0
	frame_bury 0 // nonAlgoRewardMBR: uint64

	// contracts/InjectedRewardsPool.algo.ts:127
	// for (var i = 0; i < this.rewardAssets.value.length; i += 1)
	int 0
	frame_bury 1 // i: uint64

*for_0:
	// contracts/InjectedRewardsPool.algo.ts:127
	// i < this.rewardAssets.value.length
	frame_dig 1 // i: uint64
	int 5
	<
	bz *for_0_end

	// *if0_condition
	// contracts/InjectedRewardsPool.algo.ts:128
	// this.rewardAssets.value[i] !== 0
	frame_dig 1 // i: uint64
	int 8
	* // acc * typeLength
	int 8
	byte 0x726577617264417373657473 // "rewardAssets"
	cover 2
	box_extract
	btoi
	int 0
	!=
	bz *if0_end

	// *if0_consequent
	// contracts/InjectedRewardsPool.algo.ts:129
	// nonAlgoRewardMBR += ASSET_HOLDING_FEE
	frame_dig 0 // nonAlgoRewardMBR: uint64
	int 100000
	+
	frame_bury 0 // nonAlgoRewardMBR: uint64

*if0_end:

*for_0_continue:
	// contracts/InjectedRewardsPool.algo.ts:127
	// i += 1
	frame_dig 1 // i: uint64
	int 1
	+
	frame_bury 1 // i: uint64
	b *for_0

*for_0_end:
	// contracts/InjectedRewardsPool.algo.ts:132
	// mbr = ALGORAND_ACCOUNT_MIN_BALANCE +
	//       nonAlgoRewardMBR +
	//       this.costForBoxStorage(7 + len<StakeInfo>() * MAX_STAKERS_PER_POOL) +
	//       this.costForBoxStorage(7 + len<uint64>() * 15)
	int 100000
	frame_dig 0 // nonAlgoRewardMBR: uint64
	+
	int 10407
	callsub costForBoxStorage
	+
	int 127
	callsub costForBoxStorage
	+
	frame_bury 2 // mbr: uint64

	// contracts/InjectedRewardsPool.algo.ts:137
	// return {
	//       mbrPayment: mbr
	//     }
	frame_dig 2 // mbr: uint64
	itob

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// initStorage(pay)void
*abi_route_initStorage:
	// mbrPayment: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==

	// argument 0 (mbrPayment) for initStorage must be a pay transaction
	assert

	// execute initStorage(pay)void
	callsub initStorage
	int 1
	return

// initStorage(mbrPayment: PayTxn): void
initStorage:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// contracts/InjectedRewardsPool.algo.ts:143
	// assert(!this.stakers.exists, 'staking pool already initialized')
	byte 0x7374616b657273 // "stakers"
	box_len
	swap
	pop
	!

	// staking pool already initialized
	assert

	// contracts/InjectedRewardsPool.algo.ts:144
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can init storage')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can init storage
	assert

	// contracts/InjectedRewardsPool.algo.ts:146
	// nonAlgoRewardMBR = 0
	int 0
	frame_bury 0 // nonAlgoRewardMBR: uint64

	// contracts/InjectedRewardsPool.algo.ts:147
	// for (var i = 0; i < this.rewardAssets.value.length; i += 1)
	int 0
	frame_bury 1 // i: uint64

*for_1:
	// contracts/InjectedRewardsPool.algo.ts:147
	// i < this.rewardAssets.value.length
	frame_dig 1 // i: uint64
	int 5
	<
	bz *for_1_end

	// *if1_condition
	// contracts/InjectedRewardsPool.algo.ts:148
	// this.rewardAssets.value[i] !== 0
	frame_dig 1 // i: uint64
	int 8
	* // acc * typeLength
	int 8
	byte 0x726577617264417373657473 // "rewardAssets"
	cover 2
	box_extract
	btoi
	int 0
	!=
	bz *if1_end

	// *if1_consequent
	// contracts/InjectedRewardsPool.algo.ts:149
	// nonAlgoRewardMBR += ASSET_HOLDING_FEE
	frame_dig 0 // nonAlgoRewardMBR: uint64
	int 100000
	+
	frame_bury 0 // nonAlgoRewardMBR: uint64

*if1_end:

*for_1_continue:
	// contracts/InjectedRewardsPool.algo.ts:147
	// i += 1
	frame_dig 1 // i: uint64
	int 1
	+
	frame_bury 1 // i: uint64
	b *for_1

*for_1_end:
	// contracts/InjectedRewardsPool.algo.ts:152
	// poolMBR = ALGORAND_ACCOUNT_MIN_BALANCE +
	//       nonAlgoRewardMBR +
	//       this.costForBoxStorage(7 + len<StakeInfo>() * MAX_STAKERS_PER_POOL) +
	//       this.costForBoxStorage(7 + len<uint64>() * 15)
	int 100000
	frame_dig 0 // nonAlgoRewardMBR: uint64
	+
	int 10407
	callsub costForBoxStorage
	+
	int 127
	callsub costForBoxStorage
	+
	frame_bury 2 // poolMBR: uint64

	// contracts/InjectedRewardsPool.algo.ts:158
	// verifyPayTxn(mbrPayment, { receiver: this.app.address, amount: poolMBR })
	// verify receiver
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Amount
	frame_dig 2 // poolMBR: uint64
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"amount","expected":"poolMBR"}
	assert

	// contracts/InjectedRewardsPool.algo.ts:159
	// this.stakers.create()
	byte 0x7374616b657273 // "stakers"
	int 10400
	box_create
	pop

	// contracts/InjectedRewardsPool.algo.ts:160
	// this.minimumBalance.value = poolMBR
	byte 0x6d696e696d756d42616c616e6365 // "minimumBalance"
	frame_dig 2 // poolMBR: uint64
	app_global_put

	// *if2_condition
	// contracts/InjectedRewardsPool.algo.ts:162
	// nonAlgoRewardMBR > 0
	frame_dig 0 // nonAlgoRewardMBR: uint64
	int 0
	>
	bz *if2_end

	// *if2_consequent
	// contracts/InjectedRewardsPool.algo.ts:164
	// for (var i = 0; i < this.rewardAssets.value.length; i += 1)
	int 0
	frame_bury 3 // i: uint64

*for_2:
	// contracts/InjectedRewardsPool.algo.ts:164
	// i < this.rewardAssets.value.length
	frame_dig 3 // i: uint64
	int 5
	<
	bz *for_2_end

	// *if3_condition
	// contracts/InjectedRewardsPool.algo.ts:165
	// this.rewardAssets.value[i] !== 0
	frame_dig 3 // i: uint64
	int 8
	* // acc * typeLength
	int 8
	byte 0x726577617264417373657473 // "rewardAssets"
	cover 2
	box_extract
	btoi
	int 0
	!=
	bz *if3_end

	// *if3_consequent
	// contracts/InjectedRewardsPool.algo.ts:166
	// sendAssetTransfer({
	//             xferAsset: AssetID.fromUint64(this.rewardAssets.value[i]),
	//             assetReceiver: this.app.address,
	//             assetAmount: 0,
	//           })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/InjectedRewardsPool.algo.ts:167
	// xferAsset: AssetID.fromUint64(this.rewardAssets.value[i])
	frame_dig 3 // i: uint64
	int 8
	* // acc * typeLength
	int 8
	byte 0x726577617264417373657473 // "rewardAssets"
	cover 2
	box_extract
	btoi
	itxn_field XferAsset

	// contracts/InjectedRewardsPool.algo.ts:168
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/InjectedRewardsPool.algo.ts:169
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if3_end:

*for_2_continue:
	// contracts/InjectedRewardsPool.algo.ts:164
	// i += 1
	frame_dig 3 // i: uint64
	int 1
	+
	frame_bury 3 // i: uint64
	b *for_2

*for_2_end:

*if2_end:
	retsub

// addRewardAsset(uint64)void
*abi_route_addRewardAsset:
	// rewardAssetId: uint64
	txna ApplicationArgs 1
	btoi

	// execute addRewardAsset(uint64)void
	callsub addRewardAsset
	int 1
	return

// addRewardAsset(rewardAssetId: uint64): void
addRewardAsset:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/InjectedRewardsPool.algo.ts:177
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can add reward asset')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can add reward asset
	assert

	// contracts/InjectedRewardsPool.algo.ts:178
	// assert(rewardAssetId !== 0, 'Invalid reward asset')
	frame_dig -1 // rewardAssetId: uint64
	int 0
	!=

	// Invalid reward asset
	assert

	// contracts/InjectedRewardsPool.algo.ts:180
	// for (let i = 0; i < this.rewardAssets.value.length; i += 1)
	int 0
	frame_bury 0 // i: uint64

*for_3:
	// contracts/InjectedRewardsPool.algo.ts:180
	// i < this.rewardAssets.value.length
	frame_dig 0 // i: uint64
	int 5
	<
	bz *for_3_end

	// *if4_condition
	// contracts/InjectedRewardsPool.algo.ts:181
	// this.rewardAssets.value[i] === 0
	frame_dig 0 // i: uint64
	int 8
	* // acc * typeLength
	int 8
	byte 0x726577617264417373657473 // "rewardAssets"
	cover 2
	box_extract
	btoi
	int 0
	==
	bz *if4_end

	// *if4_consequent
	// contracts/InjectedRewardsPool.algo.ts:182
	// this.rewardAssets.value[i] = rewardAssetId
	frame_dig 0 // i: uint64
	int 8
	* // acc * typeLength
	frame_dig -1 // rewardAssetId: uint64
	itob
	byte 0x726577617264417373657473 // "rewardAssets"
	cover 2
	box_replace

	// contracts/InjectedRewardsPool.algo.ts:183
	// sendAssetTransfer({
	//           xferAsset: AssetID.fromUint64(rewardAssetId),
	//           assetReceiver: this.app.address,
	//           assetAmount: 0,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/InjectedRewardsPool.algo.ts:184
	// xferAsset: AssetID.fromUint64(rewardAssetId)
	frame_dig -1 // rewardAssetId: uint64
	itxn_field XferAsset

	// contracts/InjectedRewardsPool.algo.ts:185
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/InjectedRewardsPool.algo.ts:186
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/InjectedRewardsPool.algo.ts:188
	// return;
	retsub

*if4_end:

*for_3_continue:
	// contracts/InjectedRewardsPool.algo.ts:180
	// i += 1
	frame_dig 0 // i: uint64
	int 1
	+
	frame_bury 0 // i: uint64
	b *for_3

*for_3_end:
	retsub

// removeRewardAsset(uint64)void
*abi_route_removeRewardAsset:
	// rewardAssetId: uint64
	txna ApplicationArgs 1
	btoi

	// execute removeRewardAsset(uint64)void
	callsub removeRewardAsset
	int 1
	return

// removeRewardAsset(rewardAssetId: uint64): void
removeRewardAsset:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/InjectedRewardsPool.algo.ts:193
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can remove reward asset')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can remove reward asset
	assert

	// contracts/InjectedRewardsPool.algo.ts:194
	// assert(rewardAssetId !== 0, 'Invalid reward asset')
	frame_dig -1 // rewardAssetId: uint64
	int 0
	!=

	// Invalid reward asset
	assert

	// contracts/InjectedRewardsPool.algo.ts:196
	// for (let i = 0; i < this.rewardAssets.value.length; i += 1)
	int 0
	frame_bury 0 // i: uint64

*for_4:
	// contracts/InjectedRewardsPool.algo.ts:196
	// i < this.rewardAssets.value.length
	frame_dig 0 // i: uint64
	int 5
	<
	bz *for_4_end

	// *if5_condition
	// contracts/InjectedRewardsPool.algo.ts:197
	// this.rewardAssets.value[i] === rewardAssetId
	frame_dig 0 // i: uint64
	int 8
	* // acc * typeLength
	int 8
	byte 0x726577617264417373657473 // "rewardAssets"
	cover 2
	box_extract
	btoi
	frame_dig -1 // rewardAssetId: uint64
	==
	bz *if5_end

	// *if5_consequent
	// contracts/InjectedRewardsPool.algo.ts:198
	// this.rewardAssets.value[i] = 0
	frame_dig 0 // i: uint64
	int 8
	* // acc * typeLength
	byte 0x0000000000000000
	byte 0x726577617264417373657473 // "rewardAssets"
	cover 2
	box_replace

	// contracts/InjectedRewardsPool.algo.ts:199
	// this.injectedRewards.value[i] = 0
	frame_dig 0 // i: uint64
	int 8
	* // acc * typeLength
	byte 0x0000000000000000
	byte 0x696e6a656374656452657761726473 // "injectedRewards"
	cover 2
	box_replace

	// contracts/InjectedRewardsPool.algo.ts:200
	// sendAssetTransfer({
	//           xferAsset: AssetID.fromUint64(rewardAssetId),
	//           assetReceiver: this.app.address,
	//           assetAmount: this.app.address.assetBalance(rewardAssetId),
	//           assetCloseTo: this.adminAddress.value,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/InjectedRewardsPool.algo.ts:201
	// xferAsset: AssetID.fromUint64(rewardAssetId)
	frame_dig -1 // rewardAssetId: uint64
	itxn_field XferAsset

	// contracts/InjectedRewardsPool.algo.ts:202
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/InjectedRewardsPool.algo.ts:203
	// assetAmount: this.app.address.assetBalance(rewardAssetId)
	global CurrentApplicationAddress
	frame_dig -1 // rewardAssetId: uint64
	asset_holding_get AssetBalance
	pop
	itxn_field AssetAmount

	// contracts/InjectedRewardsPool.algo.ts:204
	// assetCloseTo: this.adminAddress.value
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	itxn_field AssetCloseTo

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/InjectedRewardsPool.algo.ts:206
	// return;
	retsub

*if5_end:

*for_4_continue:
	// contracts/InjectedRewardsPool.algo.ts:196
	// i += 1
	frame_dig 0 // i: uint64
	int 1
	+
	frame_bury 0 // i: uint64
	b *for_4

*for_4_end:
	retsub

// injectRewards(axfer,uint64,uint64)void
*abi_route_injectRewards:
	// rewardAssetId: uint64
	txna ApplicationArgs 2
	btoi

	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// rewardTxn: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==

	// argument 2 (rewardTxn) for injectRewards must be a axfer transaction
	assert

	// execute injectRewards(axfer,uint64,uint64)void
	callsub injectRewards
	int 1
	return

// injectRewards(rewardTxn: AssetTransferTxn, quantity: uint64, rewardAssetId: uint64): void
injectRewards:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/InjectedRewardsPool.algo.ts:215
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can inject rewards')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can inject rewards
	assert

	// contracts/InjectedRewardsPool.algo.ts:217
	// rewardAssetFound = false
	int 0
	frame_bury 0 // rewardAssetFound: bool

	// contracts/InjectedRewardsPool.algo.ts:218
	// for (let i = 0; i < this.rewardAssets.value.length; i += 1)
	int 0
	frame_bury 1 // i: uint64

*for_5:
	// contracts/InjectedRewardsPool.algo.ts:218
	// i < this.rewardAssets.value.length
	frame_dig 1 // i: uint64
	int 5
	<
	bz *for_5_end

	// *if6_condition
	// contracts/InjectedRewardsPool.algo.ts:219
	// this.rewardAssets.value[i] === rewardAssetId
	frame_dig 1 // i: uint64
	int 8
	* // acc * typeLength
	int 8
	byte 0x726577617264417373657473 // "rewardAssets"
	cover 2
	box_extract
	btoi
	frame_dig -3 // rewardAssetId: uint64
	==
	bz *if6_end

	// *if6_consequent
	// contracts/InjectedRewardsPool.algo.ts:220
	// rewardAssetFound = true
	int 1
	frame_bury 0 // rewardAssetFound: bool

	// contracts/InjectedRewardsPool.algo.ts:221
	// verifyAssetTransferTxn(rewardTxn, {
	//           sender: this.adminAddress.value,
	//           assetReceiver: this.app.address,
	//           xferAsset: AssetID.fromUint64(rewardAssetId),
	//           assetAmount: quantity,
	//         })
	// verify sender
	frame_dig -1 // rewardTxn: AssetTransferTxn
	gtxns Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// transaction verification failed: {"txn":"rewardTxn","field":"sender","expected":"this.adminAddress.value"}
	assert

	// verify assetReceiver
	frame_dig -1 // rewardTxn: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"rewardTxn","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig -1 // rewardTxn: AssetTransferTxn
	gtxns XferAsset
	frame_dig -3 // rewardAssetId: uint64
	==

	// transaction verification failed: {"txn":"rewardTxn","field":"xferAsset","expected":"AssetID.fromUint64(rewardAssetId)"}
	assert

	// verify assetAmount
	frame_dig -1 // rewardTxn: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -2 // quantity: uint64
	==

	// transaction verification failed: {"txn":"rewardTxn","field":"assetAmount","expected":"quantity"}
	assert

	// contracts/InjectedRewardsPool.algo.ts:227
	// this.injectedRewards.value[i] += quantity
	frame_dig 1 // i: uint64
	int 8
	* // acc * typeLength
	frame_dig 1 // i: uint64
	int 8
	* // acc * typeLength
	int 8
	byte 0x696e6a656374656452657761726473 // "injectedRewards"
	cover 2
	box_extract
	btoi
	frame_dig -2 // quantity: uint64
	+
	itob
	byte 0x696e6a656374656452657761726473 // "injectedRewards"
	cover 2
	box_replace

	// contracts/InjectedRewardsPool.algo.ts:228
	// this.lastRewardInjectionTime.value = globals.latestTimestamp
	byte 0x6c617374526577617264496e6a656374696f6e54696d65 // "lastRewardInjectionTime"
	global LatestTimestamp
	app_global_put

*if6_end:

*for_5_continue:
	// contracts/InjectedRewardsPool.algo.ts:218
	// i += 1
	frame_dig 1 // i: uint64
	int 1
	+
	frame_bury 1 // i: uint64
	b *for_5

*for_5_end:
	// contracts/InjectedRewardsPool.algo.ts:231
	// assert(rewardAssetFound, 'Reward asset not found')
	frame_dig 0 // rewardAssetFound: bool

	// Reward asset not found
	assert
	retsub

// injectAlgoRewards(pay,uint64)void
*abi_route_injectAlgoRewards:
	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// payTxn: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==

	// argument 1 (payTxn) for injectAlgoRewards must be a pay transaction
	assert

	// execute injectAlgoRewards(pay,uint64)void
	callsub injectAlgoRewards
	int 1
	return

// injectAlgoRewards(payTxn: PayTxn, quantity: uint64): void
injectAlgoRewards:
	proto 2 0

	// contracts/InjectedRewardsPool.algo.ts:235
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can inject rewards')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can inject rewards
	assert

	// contracts/InjectedRewardsPool.algo.ts:237
	// verifyPayTxn(payTxn, {
	//       receiver: this.app.address,
	//       amount: quantity,
	//     })
	// verify receiver
	frame_dig -1 // payTxn: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payTxn","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // payTxn: PayTxn
	gtxns Amount
	frame_dig -2 // quantity: uint64
	==

	// transaction verification failed: {"txn":"payTxn","field":"amount","expected":"quantity"}
	assert

	// contracts/InjectedRewardsPool.algo.ts:242
	// this.algoInjectedRewards.value += quantity
	byte 0x616c676f496e6a656374656452657761726473 // "algoInjectedRewards"
	app_global_get
	frame_dig -2 // quantity: uint64
	+
	byte 0x616c676f496e6a656374656452657761726473 // "algoInjectedRewards"
	swap
	app_global_put

	// contracts/InjectedRewardsPool.algo.ts:243
	// this.lastRewardInjectionTime.value = globals.latestTimestamp
	byte 0x6c617374526577617264496e6a656374696f6e54696d65 // "lastRewardInjectionTime"
	global LatestTimestamp
	app_global_put
	retsub

// deleteApplication()void
*abi_route_deleteApplication:
	// execute deleteApplication()void
	callsub deleteApplication
	int 1
	return

// deleteApplication(): void
deleteApplication:
	proto 0 0

	// contracts/InjectedRewardsPool.algo.ts:248
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can delete application')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can delete application
	assert
	retsub

// stake(axfer,uint64)void
*abi_route_stake:
	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// stakeTxn: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==

	// argument 1 (stakeTxn) for stake must be a axfer transaction
	assert

	// execute stake(axfer,uint64)void
	callsub stake
	int 1
	return

// stake(stakeTxn: AssetTransferTxn, quantity: uint64): void
stake:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// contracts/InjectedRewardsPool.algo.ts:263
	// currentTimeStamp = globals.latestTimestamp
	global LatestTimestamp
	frame_bury 0 // currentTimeStamp: uint64

	// contracts/InjectedRewardsPool.algo.ts:264
	// assert(quantity > 0, 'Invalid quantity')
	frame_dig -2 // quantity: uint64
	int 0
	>

	// Invalid quantity
	assert

	// contracts/InjectedRewardsPool.algo.ts:266
	// verifyAssetTransferTxn(stakeTxn, {
	//       sender: this.txn.sender,
	//       assetReceiver: this.app.address,
	//       xferAsset: AssetID.fromUint64(this.stakedAssetId.value),
	//       assetAmount: quantity,
	//     })
	// verify sender
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"stakeTxn","field":"sender","expected":"this.txn.sender"}
	assert

	// verify assetReceiver
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"stakeTxn","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns XferAsset
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	app_global_get
	==

	// transaction verification failed: {"txn":"stakeTxn","field":"xferAsset","expected":"AssetID.fromUint64(this.stakedAssetId.value)"}
	assert

	// verify assetAmount
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -2 // quantity: uint64
	==

	// transaction verification failed: {"txn":"stakeTxn","field":"assetAmount","expected":"quantity"}
	assert

	// contracts/InjectedRewardsPool.algo.ts:272
	// actionComplete: boolean = false
	int 0
	frame_bury 1 // actionComplete: boolean

	// contracts/InjectedRewardsPool.algo.ts:273
	// for (let i = 0; i < this.stakers.value.length; i += 1)
	int 0
	frame_bury 2 // i: uint64

*for_6:
	// contracts/InjectedRewardsPool.algo.ts:273
	// i < this.stakers.value.length
	frame_dig 2 // i: uint64
	int 100
	<
	bz *for_6_end

	// *if7_condition
	// contracts/InjectedRewardsPool.algo.ts:274
	// actionComplete
	frame_dig 1 // actionComplete: boolean
	bz *if7_end

	// *if7_consequent
	b *for_6_end

*if7_end:
	// *if8_condition
	// contracts/InjectedRewardsPool.algo.ts:276
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if8_end

	// *if8_consequent
	// contracts/InjectedRewardsPool.algo.ts:277
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if8_end:
	// contracts/InjectedRewardsPool.algo.ts:279
	// staker = clone(this.stakers.value[i])
	frame_dig 2 // i: uint64
	int 104
	* // acc * typeLength
	int 104
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	frame_bury 3 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// *if9_condition
	// contracts/InjectedRewardsPool.algo.ts:281
	// staker.account === this.txn.sender
	frame_dig 3 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 0 32
	txn Sender
	==
	bz *if9_elseif1_condition

	// *if9_consequent
	// contracts/InjectedRewardsPool.algo.ts:282
	// staker.stake += stakeTxn.assetAmount
	frame_dig 3 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 32 // headOffset
	frame_dig 3 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns AssetAmount
	+
	itob
	replace3
	frame_bury 3 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/InjectedRewardsPool.algo.ts:283
	// this.stakers.value[i] = staker
	frame_dig 2 // i: uint64
	int 104
	* // acc * typeLength
	frame_dig 3 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace

	// contracts/InjectedRewardsPool.algo.ts:284
	// actionComplete = true
	int 1
	frame_bury 1 // actionComplete: boolean
	b *if9_end

*if9_elseif1_condition:
	// contracts/InjectedRewardsPool.algo.ts:286
	// staker.account === globals.zeroAddress
	frame_dig 3 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 0 32
	global ZeroAddress
	==
	bz *if9_end

	// *if9_elseif1_consequent
	// contracts/InjectedRewardsPool.algo.ts:288
	// this.totalStaked.value += stakeTxn.assetAmount
	byte 0x746f74616c5374616b6564 // "totalStaked"
	app_global_get
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns AssetAmount
	+
	byte 0x746f74616c5374616b6564 // "totalStaked"
	swap
	app_global_put

	// contracts/InjectedRewardsPool.algo.ts:290
	// this.stakers.value[i] = {
	//           account: this.txn.sender,
	//           stake: stakeTxn.assetAmount,
	//           stakeDuration: 0,
	//           stakeStartTime: currentTimeStamp,
	//           userStakingWeight: 0,
	//           lastRewardRate: 0,
	//           algoAccuredRewards: 0,
	//           lastUpdateTime: currentTimeStamp,
	//           userShare: 0,
	//           userSharePercentage: 0
	//         }
	frame_dig 2 // i: uint64
	int 104
	* // acc * typeLength
	txn Sender
	frame_dig -1 // stakeTxn: AssetTransferTxn
	gtxns AssetAmount
	itob
	concat
	byte 0x0000000000000000
	concat
	frame_dig 0 // currentTimeStamp: uint64
	itob
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	frame_dig 0 // currentTimeStamp: uint64
	itob
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace

	// contracts/InjectedRewardsPool.algo.ts:303
	// this.numStakers.value = this.numStakers.value + 1
	byte 0x6e756d5374616b657273 // "numStakers"
	dup
	app_global_get
	int 1
	+
	app_global_put

	// contracts/InjectedRewardsPool.algo.ts:304
	// actionComplete = true
	int 1
	frame_bury 1 // actionComplete: boolean

*if9_end:

*for_6_continue:
	// contracts/InjectedRewardsPool.algo.ts:273
	// i += 1
	frame_dig 2 // i: uint64
	int 1
	+
	frame_bury 2 // i: uint64
	b *for_6

*for_6_end:
	// contracts/InjectedRewardsPool.algo.ts:307
	// this.calculateRewardShares()
	callsub calculateRewardShares
	retsub

// calculateShares()void
*abi_route_calculateShares:
	// execute calculateShares()void
	callsub calculateShares
	int 1
	return

// calculateShares(): void
calculateShares:
	proto 0 0

	// contracts/InjectedRewardsPool.algo.ts:311
	// this.calculateRewardShares()
	callsub calculateRewardShares
	retsub

// calculateRewardShares(): void
calculateRewardShares:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts/InjectedRewardsPool.algo.ts:315
	// for (let i = 0; i < this.stakers.value.length; i += 1)
	int 0
	frame_bury 0 // i: uint64

*for_7:
	// contracts/InjectedRewardsPool.algo.ts:315
	// i < this.stakers.value.length
	frame_dig 0 // i: uint64
	int 100
	<
	bz *for_7_end

	// *if10_condition
	// contracts/InjectedRewardsPool.algo.ts:317
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if10_end

	// *if10_consequent
	// contracts/InjectedRewardsPool.algo.ts:318
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if10_end:
	// contracts/InjectedRewardsPool.algo.ts:320
	// staker = clone(this.stakers.value[i])
	frame_dig 0 // i: uint64
	int 104
	* // acc * typeLength
	int 104
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	frame_bury 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// *if11_condition
	// contracts/InjectedRewardsPool.algo.ts:321
	// staker.account === globals.zeroAddress
	frame_dig 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 0 32
	global ZeroAddress
	==
	bz *if11_end

	// *if11_consequent
	b *for_7_continue

*if11_end:
	// *if12_condition
	// contracts/InjectedRewardsPool.algo.ts:323
	// staker.userStakingWeight > 0
	frame_dig 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 56 8
	btoi
	int 0
	>
	bz *if12_end

	// *if12_consequent
	// contracts/InjectedRewardsPool.algo.ts:324
	// this.totalStakingWeight.value = this.totalStakingWeight.value - (staker.userStakingWeight as uint128)
	byte 0x746f74616c5374616b696e67576569676874 // "totalStakingWeight"
	dup
	app_global_get
	frame_dig 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 56 8
	btoi
	itob
	b-
	dup
	bitlen
	int 128
	<=

	// this.totalStakingWeight.value - (staker.userStakingWeight as uint128) overflowed 128 bits
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 16
	-
	swap
	substring3
	app_global_put

*if12_end:
	// contracts/InjectedRewardsPool.algo.ts:326
	// userStakingWeight = 0
	int 0
	frame_bury 2 // userStakingWeight: uint64

	// contracts/InjectedRewardsPool.algo.ts:328
	// userStakingWeight = staker.stake
	frame_dig 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_bury 2 // userStakingWeight: uint64

	// contracts/InjectedRewardsPool.algo.ts:330
	// staker.userStakingWeight = userStakingWeight
	frame_dig 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 56 // headOffset
	frame_dig 2 // userStakingWeight: uint64
	itob
	replace3
	frame_bury 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/InjectedRewardsPool.algo.ts:331
	// this.totalStakingWeight.value = this.totalStakingWeight.value + (userStakingWeight as uint128)
	byte 0x746f74616c5374616b696e67576569676874 // "totalStakingWeight"
	dup
	app_global_get
	frame_dig 2 // userStakingWeight: uint64
	itob
	b+
	dup
	bitlen
	int 128
	<=

	// this.totalStakingWeight.value + (userStakingWeight as uint128) overflowed 128 bits
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 16
	-
	swap
	substring3
	app_global_put

	// contracts/InjectedRewardsPool.algo.ts:333
	// staker.userShare = wideRatio([userStakingWeight, PRECISION], [this.totalStakingWeight.value as uint64])
	frame_dig 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 88 // headOffset
	frame_dig 2 // userStakingWeight: uint64
	int 1000000000000000
	mulw
	int 0
	byte 0x746f74616c5374616b696e67576569676874 // "totalStakingWeight"
	app_global_get
	dup
	bitlen
	int 64
	<=

	// this.totalStakingWeight.value as uint64 overflowed 64 bits
	assert
	extract 8 8
	btoi
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	itob
	replace3
	frame_bury 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/InjectedRewardsPool.algo.ts:334
	// staker.userSharePercentage = wideRatio([staker.userShare, 100], [PRECISION])
	frame_dig 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 96 // headOffset
	frame_dig 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 88 8
	btoi
	int 100
	mulw
	int 0
	int 1000000000000000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	itob
	replace3
	frame_bury 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/InjectedRewardsPool.algo.ts:336
	// this.stakers.value[i] = staker
	frame_dig 0 // i: uint64
	int 104
	* // acc * typeLength
	frame_dig 1 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace

*for_7_continue:
	// contracts/InjectedRewardsPool.algo.ts:315
	// i += 1
	frame_dig 0 // i: uint64
	int 1
	+
	frame_bury 0 // i: uint64
	b *for_7

*for_7_end:
	retsub

// accrueRewards()void
*abi_route_accrueRewards:
	// execute accrueRewards()void
	callsub accrueRewards
	int 1
	return

// accrueRewards(): void
accrueRewards:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 7

	// *if13_condition
	// contracts/InjectedRewardsPool.algo.ts:342
	// this.freeze.value
	byte 0x667265657a65 // "freeze"
	app_global_get
	int 0
	getbit
	bz *if13_end

	// *if13_consequent
	// contracts/InjectedRewardsPool.algo.ts:342
	// return;
	retsub

*if13_end:
	// contracts/InjectedRewardsPool.algo.ts:343
	// algoRewards = this.algoInjectedRewards.value
	byte 0x616c676f496e6a656374656452657761726473 // "algoInjectedRewards"
	app_global_get
	frame_bury 0 // algoRewards: uint64

	// contracts/InjectedRewardsPool.algo.ts:344
	// additionalRewards: uint64[] = []
	byte 0x
	frame_bury 1 // additionalRewards: uint64[]

	// contracts/InjectedRewardsPool.algo.ts:345
	// for (let i = 0; i < this.rewardAssets.value.length; i += 1)
	int 0
	frame_bury 2 // i: uint64

*for_8:
	// contracts/InjectedRewardsPool.algo.ts:345
	// i < this.rewardAssets.value.length
	frame_dig 2 // i: uint64
	int 5
	<
	bz *for_8_end

	// contracts/InjectedRewardsPool.algo.ts:346
	// additionalRewards.push(this.injectedRewards.value[i])
	frame_dig 1 // additionalRewards: uint64[]
	frame_dig 2 // i: uint64
	int 8
	* // acc * typeLength
	int 8
	byte 0x696e6a656374656452657761726473 // "injectedRewards"
	cover 2
	box_extract
	btoi
	itob
	concat
	frame_bury 1 // additionalRewards: uint64[]

*for_8_continue:
	// contracts/InjectedRewardsPool.algo.ts:345
	// i += 1
	frame_dig 2 // i: uint64
	int 1
	+
	frame_bury 2 // i: uint64
	b *for_8

*for_8_end:
	// contracts/InjectedRewardsPool.algo.ts:348
	// for (let i = 0; i < this.stakers.value.length; i += 1)
	int 0
	frame_bury 3 // i: uint64

*for_9:
	// contracts/InjectedRewardsPool.algo.ts:348
	// i < this.stakers.value.length
	frame_dig 3 // i: uint64
	int 100
	<
	bz *for_9_end

	// *if14_condition
	// contracts/InjectedRewardsPool.algo.ts:349
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if14_end

	// *if14_consequent
	// contracts/InjectedRewardsPool.algo.ts:350
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if14_end:
	// contracts/InjectedRewardsPool.algo.ts:352
	// staker = clone(this.stakers.value[i])
	frame_dig 3 // i: uint64
	int 104
	* // acc * typeLength
	int 104
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	frame_bury 4 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// *if15_condition
	// contracts/InjectedRewardsPool.algo.ts:353
	// staker.account === globals.zeroAddress
	frame_dig 4 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 0 32
	global ZeroAddress
	==
	bz *if15_end

	// *if15_consequent
	b *for_9_continue

*if15_end:
	// *if16_condition
	// contracts/InjectedRewardsPool.algo.ts:355
	// staker.stake > 0
	frame_dig 4 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	int 0
	>
	bz *if16_end

	// *if16_consequent
	// contracts/InjectedRewardsPool.algo.ts:356
	// staker.stakeDuration = globals.latestTimestamp - staker.stakeStartTime
	frame_dig 4 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 40 // headOffset
	global LatestTimestamp
	frame_dig 4 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 48 8
	btoi
	-
	itob
	replace3
	frame_bury 4 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// *if17_condition
	// contracts/InjectedRewardsPool.algo.ts:357
	// staker.stakeDuration < this.minStakePeriodForRewards.value
	frame_dig 4 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 40 8
	btoi
	byte 0x6d696e5374616b65506572696f64466f7252657761726473 // "minStakePeriodForRewards"
	app_global_get
	<
	bz *if17_end

	// *if17_consequent
	// contracts/InjectedRewardsPool.algo.ts:357
	// return;
	retsub

*if17_end:
	// *if18_condition
	// contracts/InjectedRewardsPool.algo.ts:359
	// this.algoInjectedRewards.value > 0
	byte 0x616c676f496e6a656374656452657761726473 // "algoInjectedRewards"
	app_global_get
	int 0
	>
	bz *if18_end

	// *if18_consequent
	// contracts/InjectedRewardsPool.algo.ts:360
	// algoRewardRate = wideRatio([algoRewards, staker.userSharePercentage], [100])
	frame_dig 0 // algoRewards: uint64
	frame_dig 4 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 96 8
	btoi
	mulw
	int 0
	int 100
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 5 // algoRewardRate: uint64

	// *if19_condition
	// contracts/InjectedRewardsPool.algo.ts:361
	// algoRewardRate === 0
	frame_dig 5 // algoRewardRate: uint64
	int 0
	==
	bz *if19_end

	// *if19_consequent
	// contracts/InjectedRewardsPool.algo.ts:362
	// algoRewardRate = 1
	int 1
	frame_bury 5 // algoRewardRate: uint64

*if19_end:
	// contracts/InjectedRewardsPool.algo.ts:364
	// staker.algoAccuredRewards = staker.algoAccuredRewards + algoRewardRate
	frame_dig 4 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 72 // headOffset
	frame_dig 4 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 72 8
	btoi
	frame_dig 5 // algoRewardRate: uint64
	+
	itob
	replace3
	frame_bury 4 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/InjectedRewardsPool.algo.ts:365
	// this.algoInjectedRewards.value = this.algoInjectedRewards.value - algoRewardRate
	byte 0x616c676f496e6a656374656452657761726473 // "algoInjectedRewards"
	dup
	app_global_get
	frame_dig 5 // algoRewardRate: uint64
	-
	app_global_put

	// *if20_condition
	// contracts/InjectedRewardsPool.algo.ts:368
	// this.stakedAssetId.value === 0
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	app_global_get
	int 0
	==
	bz *if20_end

	// *if20_consequent
	// contracts/InjectedRewardsPool.algo.ts:369
	// staker.stake = staker.stake + algoRewardRate
	frame_dig 4 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 32 // headOffset
	frame_dig 4 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig 5 // algoRewardRate: uint64
	+
	itob
	replace3
	frame_bury 4 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/InjectedRewardsPool.algo.ts:370
	// this.totalStaked.value = this.totalStaked.value + algoRewardRate
	byte 0x746f74616c5374616b6564 // "totalStaked"
	dup
	app_global_get
	frame_dig 5 // algoRewardRate: uint64
	+
	app_global_put

*if20_end:

*if18_end:
	// contracts/InjectedRewardsPool.algo.ts:373
	// for (var j = 0; j < this.rewardAssets.value.length; j += 1)
	int 0
	frame_bury 6 // j: uint64

*for_10:
	// contracts/InjectedRewardsPool.algo.ts:373
	// j < this.rewardAssets.value.length
	frame_dig 6 // j: uint64
	int 5
	<
	bz *for_10_end

	// *if21_condition
	// contracts/InjectedRewardsPool.algo.ts:374
	// this.injectedRewards.value[j] > 0
	frame_dig 6 // j: uint64
	int 8
	* // acc * typeLength
	int 8
	byte 0x696e6a656374656452657761726473 // "injectedRewards"
	cover 2
	box_extract
	btoi
	int 0
	>
	bz *if21_end

	// *if21_consequent
	// contracts/InjectedRewardsPool.algo.ts:375
	// rewardRate = wideRatio([additionalRewards[j], staker.userSharePercentage], [100])
	frame_dig 1 // additionalRewards: uint64[]
	store 255 // full array
	int 0 // initial offset
	frame_dig 6 // j: uint64
	int 8
	* // acc * typeLength
	+
	load 255 // full array
	swap
	int 8
	extract3
	btoi
	frame_dig 4 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 96 8
	btoi
	mulw
	int 0
	int 100
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 7 // rewardRate: uint64

	// *if22_condition
	// contracts/InjectedRewardsPool.algo.ts:376
	// rewardRate === 0
	frame_dig 7 // rewardRate: uint64
	int 0
	==
	bz *if22_end

	// *if22_consequent
	// contracts/InjectedRewardsPool.algo.ts:377
	// rewardRate = 1
	int 1
	frame_bury 7 // rewardRate: uint64

*if22_end:
	// contracts/InjectedRewardsPool.algo.ts:379
	// this.accruedRewards(staker.account).value[j] = this.accruedRewards(staker.account).value[j] + rewardRate
	frame_dig 4 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 0 32
	byte 0x6163637275656452657761726473 // "accruedRewards"
	app_local_get
	frame_dig 6 // j: uint64
	int 8
	* // acc * typeLength
	frame_dig 4 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 0 32
	byte 0x6163637275656452657761726473 // "accruedRewards"
	app_local_get
	frame_dig 6 // j: uint64
	int 8
	* // acc * typeLength
	int 8
	extract3
	btoi
	frame_dig 7 // rewardRate: uint64
	+
	itob
	replace3
	frame_dig 4 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 0 32
	byte 0x6163637275656452657761726473 // "accruedRewards"
	uncover 2
	app_local_put

	// contracts/InjectedRewardsPool.algo.ts:381
	// this.injectedRewards.value[j] = this.injectedRewards.value[j] - rewardRate
	frame_dig 6 // j: uint64
	int 8
	* // acc * typeLength
	frame_dig 6 // j: uint64
	int 8
	* // acc * typeLength
	int 8
	byte 0x696e6a656374656452657761726473 // "injectedRewards"
	cover 2
	box_extract
	btoi
	frame_dig 7 // rewardRate: uint64
	-
	itob
	byte 0x696e6a656374656452657761726473 // "injectedRewards"
	cover 2
	box_replace

	// *if23_condition
	// contracts/InjectedRewardsPool.algo.ts:383
	// this.rewardAssets.value[j] === this.stakedAssetId.value
	frame_dig 6 // j: uint64
	int 8
	* // acc * typeLength
	int 8
	byte 0x726577617264417373657473 // "rewardAssets"
	cover 2
	box_extract
	btoi
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	app_global_get
	==
	bz *if23_end

	// *if23_consequent
	// contracts/InjectedRewardsPool.algo.ts:385
	// staker.stake = staker.stake + rewardRate
	frame_dig 4 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 32 // headOffset
	frame_dig 4 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig 7 // rewardRate: uint64
	+
	itob
	replace3
	frame_bury 4 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/InjectedRewardsPool.algo.ts:386
	// this.totalStaked.value = this.totalStaked.value + rewardRate
	byte 0x746f74616c5374616b6564 // "totalStaked"
	dup
	app_global_get
	frame_dig 7 // rewardRate: uint64
	+
	app_global_put

*if23_end:

*if21_end:
	// contracts/InjectedRewardsPool.algo.ts:389
	// staker.lastUpdateTime = globals.latestTimestamp
	frame_dig 4 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 80 // headOffset
	global LatestTimestamp
	itob
	replace3
	frame_bury 4 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/InjectedRewardsPool.algo.ts:390
	// this.stakers.value[i] = staker
	frame_dig 3 // i: uint64
	int 104
	* // acc * typeLength
	frame_dig 4 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace

*for_10_continue:
	// contracts/InjectedRewardsPool.algo.ts:373
	// j += 1
	frame_dig 6 // j: uint64
	int 1
	+
	frame_bury 6 // j: uint64
	b *for_10

*for_10_end:

*if16_end:

*for_9_continue:
	// contracts/InjectedRewardsPool.algo.ts:348
	// i += 1
	frame_dig 3 // i: uint64
	int 1
	+
	frame_bury 3 // i: uint64
	b *for_9

*for_9_end:
	retsub

// getStaker(address: Address): StakeInfo
getStaker:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/InjectedRewardsPool.algo.ts:397
	// for (let i = 0; i < this.stakers.value.length; i += 1)
	int 0
	frame_bury 0 // i: uint64

*for_11:
	// contracts/InjectedRewardsPool.algo.ts:397
	// i < this.stakers.value.length
	frame_dig 0 // i: uint64
	int 100
	<
	bz *for_11_end

	// *if24_condition
	// contracts/InjectedRewardsPool.algo.ts:398
	// this.stakers.value[i].account === address
	frame_dig 0 // i: uint64
	int 104
	* // acc * typeLength
	int 0
	+
	int 32
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	frame_dig -1 // address: Address
	==
	bz *if24_end

	// *if24_consequent
	// contracts/InjectedRewardsPool.algo.ts:399
	// return clone(this.stakers.value[i]);
	frame_dig 0 // i: uint64
	int 104
	* // acc * typeLength
	int 104
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	b *getStaker*return

*if24_end:

*for_11_continue:
	// contracts/InjectedRewardsPool.algo.ts:397
	// i += 1
	frame_dig 0 // i: uint64
	int 1
	+
	frame_bury 0 // i: uint64
	b *for_11

*for_11_end:
	// contracts/InjectedRewardsPool.algo.ts:402
	// return {
	//       account: globals.zeroAddress,
	//       stake: 0,
	//       stakeDuration: 0,
	//       stakeStartTime: 0,
	//       userStakingWeight: 0,
	//       lastRewardRate: 0,
	//       lastUpdateTime: 0,
	//       algoAccuredRewards: 0,
	//       userShare: 0,
	//       userSharePercentage: 0
	//     }
	global ZeroAddress
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat

*getStaker*return:
	// set the subroutine return value
	frame_bury 0
	retsub

// setStaker(stakerAccount: Address, staker: StakeInfo): void
setStaker:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/InjectedRewardsPool.algo.ts:416
	// for (let i = 0; i < this.stakers.value.length; i += 1)
	int 0
	frame_bury 0 // i: uint64

*for_12:
	// contracts/InjectedRewardsPool.algo.ts:416
	// i < this.stakers.value.length
	frame_dig 0 // i: uint64
	int 100
	<
	bz *for_12_end

	// *if25_condition
	// contracts/InjectedRewardsPool.algo.ts:417
	// this.stakers.value[i].account === stakerAccount
	frame_dig 0 // i: uint64
	int 104
	* // acc * typeLength
	int 0
	+
	int 32
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	frame_dig -1 // stakerAccount: Address
	==
	bz *if25_end

	// *if25_consequent
	// contracts/InjectedRewardsPool.algo.ts:418
	// this.stakers.value[i] = staker
	frame_dig 0 // i: uint64
	int 104
	* // acc * typeLength
	frame_dig -2 // staker: StakeInfo
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace

	// contracts/InjectedRewardsPool.algo.ts:419
	// return;
	retsub

*if25_end:

*for_12_continue:
	// contracts/InjectedRewardsPool.algo.ts:416
	// i += 1
	frame_dig 0 // i: uint64
	int 1
	+
	frame_bury 0 // i: uint64
	b *for_12

*for_12_end:
	retsub

// claimRewards()void
*abi_route_claimRewards:
	// execute claimRewards()void
	callsub claimRewards
	int 1
	return

// claimRewards(): void
claimRewards:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// *if26_condition
	// contracts/InjectedRewardsPool.algo.ts:425
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if26_end

	// *if26_consequent
	// contracts/InjectedRewardsPool.algo.ts:426
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if26_end:
	// contracts/InjectedRewardsPool.algo.ts:428
	// staker = this.getStaker(this.txn.sender)
	txn Sender
	callsub getStaker
	frame_bury 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// *if27_condition
	// contracts/InjectedRewardsPool.algo.ts:430
	// staker.algoAccuredRewards > 0
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 72 8
	btoi
	int 0
	>
	bz *if27_end

	// *if27_consequent
	// contracts/InjectedRewardsPool.algo.ts:431
	// sendPayment({
	//         amount: staker.algoAccuredRewards,
	//         receiver: this.txn.sender,
	//         sender: this.app.address,
	//         fee: 1_000,
	//       })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/InjectedRewardsPool.algo.ts:432
	// amount: staker.algoAccuredRewards
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 72 8
	btoi
	itxn_field Amount

	// contracts/InjectedRewardsPool.algo.ts:433
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/InjectedRewardsPool.algo.ts:434
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/InjectedRewardsPool.algo.ts:435
	// fee: 1_000
	int 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/InjectedRewardsPool.algo.ts:437
	// staker.algoAccuredRewards = 0
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	byte 0x0000000000000000
	replace2 72
	frame_bury 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

*if27_end:
	// contracts/InjectedRewardsPool.algo.ts:440
	// for (var j = 0; j < this.rewardAssets.value.length; j += 1)
	int 0
	frame_bury 1 // j: uint64

*for_13:
	// contracts/InjectedRewardsPool.algo.ts:440
	// j < this.rewardAssets.value.length
	frame_dig 1 // j: uint64
	int 5
	<
	bz *for_13_end

	// *if28_condition
	// contracts/InjectedRewardsPool.algo.ts:441
	// this.accruedRewards(this.txn.sender).value[j] > 0
	txn Sender
	byte 0x6163637275656452657761726473 // "accruedRewards"
	app_local_get
	frame_dig 1 // j: uint64
	int 8
	* // acc * typeLength
	int 8
	extract3
	btoi
	int 0
	>
	bz *if28_end

	// *if28_consequent
	// contracts/InjectedRewardsPool.algo.ts:442
	// sendAssetTransfer({
	//           xferAsset: AssetID.fromUint64(this.rewardAssets.value[j]),
	//           assetReceiver: this.txn.sender,
	//           sender: this.app.address,
	//           assetAmount: this.accruedRewards(this.txn.sender).value[j],
	//           fee: 1_000,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/InjectedRewardsPool.algo.ts:443
	// xferAsset: AssetID.fromUint64(this.rewardAssets.value[j])
	frame_dig 1 // j: uint64
	int 8
	* // acc * typeLength
	int 8
	byte 0x726577617264417373657473 // "rewardAssets"
	cover 2
	box_extract
	btoi
	itxn_field XferAsset

	// contracts/InjectedRewardsPool.algo.ts:444
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/InjectedRewardsPool.algo.ts:445
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/InjectedRewardsPool.algo.ts:446
	// assetAmount: this.accruedRewards(this.txn.sender).value[j]
	txn Sender
	byte 0x6163637275656452657761726473 // "accruedRewards"
	app_local_get
	frame_dig 1 // j: uint64
	int 8
	* // acc * typeLength
	int 8
	extract3
	btoi
	itxn_field AssetAmount

	// contracts/InjectedRewardsPool.algo.ts:447
	// fee: 1_000
	int 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if28_end:
	// contracts/InjectedRewardsPool.algo.ts:450
	// this.accruedRewards(this.txn.sender).value[j] = 0
	txn Sender
	byte 0x6163637275656452657761726473 // "accruedRewards"
	app_local_get
	frame_dig 1 // j: uint64
	int 8
	* // acc * typeLength
	byte 0x0000000000000000
	replace3
	txn Sender
	byte 0x6163637275656452657761726473 // "accruedRewards"
	uncover 2
	app_local_put

*for_13_continue:
	// contracts/InjectedRewardsPool.algo.ts:440
	// j += 1
	frame_dig 1 // j: uint64
	int 1
	+
	frame_bury 1 // j: uint64
	b *for_13

*for_13_end:
	// contracts/InjectedRewardsPool.algo.ts:454
	// staker.lastUpdateTime = globals.latestTimestamp
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 80 // headOffset
	global LatestTimestamp
	itob
	replace3
	frame_bury 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/InjectedRewardsPool.algo.ts:455
	// this.setStaker(staker.account, staker)
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 0 32
	callsub setStaker
	retsub

// unstake(uint64)void
*abi_route_unstake:
	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// execute unstake(uint64)void
	callsub unstake
	int 1
	return

// unstake(quantity: uint64): void
unstake:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// *if29_condition
	// contracts/InjectedRewardsPool.algo.ts:461
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if29_end

	// *if29_consequent
	// contracts/InjectedRewardsPool.algo.ts:462
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if29_end:
	// contracts/InjectedRewardsPool.algo.ts:465
	// staker = this.getStaker(this.txn.sender)
	txn Sender
	callsub getStaker
	frame_bury 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/InjectedRewardsPool.algo.ts:467
	// assert(staker.account !== globals.zeroAddress, 'Invalid staker')
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 0 32
	global ZeroAddress
	!=

	// Invalid staker
	assert

	// contracts/InjectedRewardsPool.algo.ts:468
	// assert(staker.stake > 0, 'No staked assets')
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	int 0
	>

	// No staked assets
	assert

	// *if30_condition
	// contracts/InjectedRewardsPool.algo.ts:470
	// staker.stake > 0
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	int 0
	>
	bz *if30_end

	// *if30_consequent
	// *if31_condition
	// contracts/InjectedRewardsPool.algo.ts:471
	// this.stakedAssetId.value === 0
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	app_global_get
	int 0
	==
	bz *if31_else

	// *if31_consequent
	// contracts/InjectedRewardsPool.algo.ts:472
	// sendPayment({
	//           amount: quantity === 0 ? staker.stake : quantity,
	//           receiver: this.txn.sender,
	//           sender: this.app.address,
	//           fee: 1_000,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/InjectedRewardsPool.algo.ts:473
	// amount: quantity === 0 ? staker.stake : quantity
	frame_dig -1 // quantity: uint64
	int 0
	==
	bz *ternary0_false
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	b *ternary0_end

*ternary0_false:
	frame_dig -1 // quantity: uint64

*ternary0_end:
	itxn_field Amount

	// contracts/InjectedRewardsPool.algo.ts:474
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/InjectedRewardsPool.algo.ts:475
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/InjectedRewardsPool.algo.ts:476
	// fee: 1_000
	int 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if31_end

*if31_else:
	// contracts/InjectedRewardsPool.algo.ts:480
	// sendAssetTransfer({
	//           xferAsset: AssetID.fromUint64(this.stakedAssetId.value),
	//           assetReceiver: this.txn.sender,
	//           sender: this.app.address,
	//           assetAmount: quantity === 0 ? staker.stake : quantity,
	//           fee: 1_000,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/InjectedRewardsPool.algo.ts:481
	// xferAsset: AssetID.fromUint64(this.stakedAssetId.value)
	byte 0x7374616b656441737365744964 // "stakedAssetId"
	app_global_get
	itxn_field XferAsset

	// contracts/InjectedRewardsPool.algo.ts:482
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/InjectedRewardsPool.algo.ts:483
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/InjectedRewardsPool.algo.ts:484
	// assetAmount: quantity === 0 ? staker.stake : quantity
	frame_dig -1 // quantity: uint64
	int 0
	==
	bz *ternary1_false
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	b *ternary1_end

*ternary1_false:
	frame_dig -1 // quantity: uint64

*ternary1_end:
	itxn_field AssetAmount

	// contracts/InjectedRewardsPool.algo.ts:485
	// fee: 1_000
	int 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if31_end:

*if30_end:
	// *if32_condition
	// contracts/InjectedRewardsPool.algo.ts:491
	// staker.algoAccuredRewards > 0
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 72 8
	btoi
	int 0
	>
	bz *if32_end

	// *if32_consequent
	// contracts/InjectedRewardsPool.algo.ts:492
	// sendPayment({
	//         amount: staker.algoAccuredRewards,
	//         receiver: this.txn.sender,
	//         sender: this.app.address,
	//         fee: 1_000,
	//       })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/InjectedRewardsPool.algo.ts:493
	// amount: staker.algoAccuredRewards
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 72 8
	btoi
	itxn_field Amount

	// contracts/InjectedRewardsPool.algo.ts:494
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/InjectedRewardsPool.algo.ts:495
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/InjectedRewardsPool.algo.ts:496
	// fee: 1_000
	int 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/InjectedRewardsPool.algo.ts:498
	// staker.algoAccuredRewards = 0
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	byte 0x0000000000000000
	replace2 72
	frame_bury 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

*if32_end:
	// contracts/InjectedRewardsPool.algo.ts:501
	// for (let j = 0; j < this.rewardAssets.value.length; j += 1)
	int 0
	frame_bury 1 // j: uint64

*for_14:
	// contracts/InjectedRewardsPool.algo.ts:501
	// j < this.rewardAssets.value.length
	frame_dig 1 // j: uint64
	int 5
	<
	bz *for_14_end

	// *if33_condition
	// contracts/InjectedRewardsPool.algo.ts:502
	// this.accruedRewards(this.txn.sender).value[j] > 0
	txn Sender
	byte 0x6163637275656452657761726473 // "accruedRewards"
	app_local_get
	frame_dig 1 // j: uint64
	int 8
	* // acc * typeLength
	int 8
	extract3
	btoi
	int 0
	>
	bz *if33_end

	// *if33_consequent
	// contracts/InjectedRewardsPool.algo.ts:503
	// sendAssetTransfer({
	//           xferAsset: AssetID.fromUint64(this.rewardAssets.value[j]),
	//           assetReceiver: this.txn.sender,
	//           sender: this.app.address,
	//           assetAmount: this.accruedRewards(this.txn.sender).value[j],
	//           fee: 1_000,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/InjectedRewardsPool.algo.ts:504
	// xferAsset: AssetID.fromUint64(this.rewardAssets.value[j])
	frame_dig 1 // j: uint64
	int 8
	* // acc * typeLength
	int 8
	byte 0x726577617264417373657473 // "rewardAssets"
	cover 2
	box_extract
	btoi
	itxn_field XferAsset

	// contracts/InjectedRewardsPool.algo.ts:505
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/InjectedRewardsPool.algo.ts:506
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/InjectedRewardsPool.algo.ts:507
	// assetAmount: this.accruedRewards(this.txn.sender).value[j]
	txn Sender
	byte 0x6163637275656452657761726473 // "accruedRewards"
	app_local_get
	frame_dig 1 // j: uint64
	int 8
	* // acc * typeLength
	int 8
	extract3
	btoi
	itxn_field AssetAmount

	// contracts/InjectedRewardsPool.algo.ts:508
	// fee: 1_000
	int 1_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/InjectedRewardsPool.algo.ts:510
	// this.accruedRewards(this.txn.sender).value[j] = 0
	txn Sender
	byte 0x6163637275656452657761726473 // "accruedRewards"
	app_local_get
	frame_dig 1 // j: uint64
	int 8
	* // acc * typeLength
	byte 0x0000000000000000
	replace3
	txn Sender
	byte 0x6163637275656452657761726473 // "accruedRewards"
	uncover 2
	app_local_put

*if33_end:

*for_14_continue:
	// contracts/InjectedRewardsPool.algo.ts:501
	// j += 1
	frame_dig 1 // j: uint64
	int 1
	+
	frame_bury 1 // j: uint64
	b *for_14

*for_14_end:
	// contracts/InjectedRewardsPool.algo.ts:515
	// this.totalStakingWeight.value = this.totalStakingWeight.value - (staker.userStakingWeight as uint128)
	byte 0x746f74616c5374616b696e67576569676874 // "totalStakingWeight"
	dup
	app_global_get
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 56 8
	btoi
	itob
	b-
	dup
	bitlen
	int 128
	<=

	// this.totalStakingWeight.value - (staker.userStakingWeight as uint128) overflowed 128 bits
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 16
	-
	swap
	substring3
	app_global_put

	// contracts/InjectedRewardsPool.algo.ts:516
	// this.totalStaked.value = this.totalStaked.value - staker.stake
	byte 0x746f74616c5374616b6564 // "totalStaked"
	dup
	app_global_get
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	-
	app_global_put

	// *if34_condition
	// contracts/InjectedRewardsPool.algo.ts:518
	// quantity === 0
	frame_dig -1 // quantity: uint64
	int 0
	==
	bz *if34_else

	// *if34_consequent
	// contracts/InjectedRewardsPool.algo.ts:519
	// removedStaker: StakeInfo = {
	//         account: globals.zeroAddress,
	//         stake: 0,
	//         stakeDuration: 0,
	//         stakeStartTime: 0,
	//         userStakingWeight: 0,
	//         lastRewardRate: 0,
	//         lastUpdateTime: 0,
	//         userShare: 0,
	//         userSharePercentage: 0,
	//         algoAccuredRewards: 0,
	//       }
	global ZeroAddress
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	frame_bury 2 // removedStaker: StakeInfo

	// contracts/InjectedRewardsPool.algo.ts:531
	// this.setStaker(staker.account, removedStaker)
	frame_dig 2 // removedStaker: StakeInfo
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 0 32
	callsub setStaker

	// contracts/InjectedRewardsPool.algo.ts:532
	// this.accruedRewards(this.txn.sender).value = [0, 0, 0, 0, 0]
	txn Sender
	byte 0x6163637275656452657761726473 // "accruedRewards"
	byte 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000
	app_local_put

	// contracts/InjectedRewardsPool.algo.ts:533
	// this.numStakers.value = this.numStakers.value - 1
	byte 0x6e756d5374616b657273 // "numStakers"
	dup
	app_global_get
	int 1
	-
	app_global_put
	b *if34_end

*if34_else:
	// contracts/InjectedRewardsPool.algo.ts:535
	// staker.stake = staker.stake - quantity
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 32 // headOffset
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig -1 // quantity: uint64
	-
	itob
	replace3
	frame_bury 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/InjectedRewardsPool.algo.ts:536
	// this.accruedRewards(this.txn.sender).value = [0, 0, 0, 0, 0]
	txn Sender
	byte 0x6163637275656452657761726473 // "accruedRewards"
	byte 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000
	app_local_put

*if34_end:
	// contracts/InjectedRewardsPool.algo.ts:538
	// staker.lastUpdateTime = globals.latestTimestamp
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	int 80 // headOffset
	global LatestTimestamp
	itob
	replace3
	frame_bury 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)

	// contracts/InjectedRewardsPool.algo.ts:539
	// this.setStaker(staker.account, staker)
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	frame_dig 0 // staker: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	extract 0 32
	callsub setStaker
	retsub

// setFreeze(bool)void
*abi_route_setFreeze:
	// enabled: bool
	txna ApplicationArgs 1
	dup
	len
	int 1
	==

	// argument 0 (enabled) for setFreeze must be a bool
	assert
	int 0
	getbit

	// execute setFreeze(bool)void
	callsub setFreeze
	int 1
	return

// setFreeze(enabled: boolean): void
setFreeze:
	proto 1 0

	// contracts/InjectedRewardsPool.algo.ts:543
	// assert(this.txn.sender === this.adminAddress.value, 'Only admin can freeze payouts')
	txn Sender
	byte 0x61646d696e41646472657373 // "adminAddress"
	app_global_get
	==

	// Only admin can freeze payouts
	assert

	// contracts/InjectedRewardsPool.algo.ts:544
	// this.freeze.value = enabled
	byte 0x667265657a65 // "freeze"
	frame_dig -1 // enabled: boolean
	byte 0x00
	int 0
	uncover 2
	setbit
	app_global_put
	retsub

// gas()void
*abi_route_gas:
	// execute gas()void
	callsub gas
	int 1
	return

// gas(): void
gas:
	proto 0 0
	retsub

*create_NoOp:
	method "createApplication(address)void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	method "initApplication(uint64,uint64[5],uint64,address)void"
	method "updateMinStakePeriod(uint64)void"
	method "updateTotalStakingWeight(uint64)void"
	method "updateAdminAddress(address)void"
	method "updateOracleAdminAddress(address)void"
	method "getMBRForPoolCreation()(uint64)"
	method "initStorage(pay)void"
	method "addRewardAsset(uint64)void"
	method "removeRewardAsset(uint64)void"
	method "injectRewards(axfer,uint64,uint64)void"
	method "injectAlgoRewards(pay,uint64)void"
	method "stake(axfer,uint64)void"
	method "calculateShares()void"
	method "accrueRewards()void"
	method "claimRewards()void"
	method "unstake(uint64)void"
	method "setFreeze(bool)void"
	method "gas()void"
	txna ApplicationArgs 0
	match *abi_route_initApplication *abi_route_updateMinStakePeriod *abi_route_updateTotalStakingWeight *abi_route_updateAdminAddress *abi_route_updateOracleAdminAddress *abi_route_getMBRForPoolCreation *abi_route_initStorage *abi_route_addRewardAsset *abi_route_removeRewardAsset *abi_route_injectRewards *abi_route_injectAlgoRewards *abi_route_stake *abi_route_calculateShares *abi_route_accrueRewards *abi_route_claimRewards *abi_route_unstake *abi_route_setFreeze *abi_route_gas

	// this contract does not implement the given ABI method for call NoOp
	err

*call_OptIn:
	method "optInToApplication()void"
	txna ApplicationArgs 0
	match *abi_route_optInToApplication

	// this contract does not implement the given ABI method for call OptIn
	err

*call_DeleteApplication:
	method "deleteApplication()void"
	txna ApplicationArgs 0
	match *abi_route_deleteApplication

	// this contract does not implement the given ABI method for call DeleteApplication
	err